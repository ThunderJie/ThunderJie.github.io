<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="编写硬盘驱动程序创建新磁盘文件下面我们需要逐步实现文件系统，在此之前我们需要实现一个硬盘驱动程序，我们之前一直操作的hd60M.img为主盘，里面存放的是我们的内核，我们需要创建一个从盘，用于存放后面的文件系统，具体操作如下，创建一个大小为80MB的hd80M.img磁盘 12345678910111213141516171819202122232425262728293031323334/hom">
<meta name="keywords" content="OS Learning">
<meta property="og:type" content="article">
<meta property="og:title" content="简单内核实现笔记-part-4">
<meta property="og:url" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/index.html">
<meta property="og:site_name" content="Thunder_J">
<meta property="og:description" content="编写硬盘驱动程序创建新磁盘文件下面我们需要逐步实现文件系统，在此之前我们需要实现一个硬盘驱动程序，我们之前一直操作的hd60M.img为主盘，里面存放的是我们的内核，我们需要创建一个从盘，用于存放后面的文件系统，具体操作如下，创建一个大小为80MB的hd80M.img磁盘 12345678910111213141516171819202122232425262728293031323334/hom">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/85.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/86.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/87.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/88.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/89.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/90.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/91.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/92.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/93.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/94.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/95.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/96.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/97.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/98.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/99.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/100.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/101.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/102.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/103.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/104.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/105.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/106.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/107.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/108.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/109.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/110.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/111.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/112.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/113.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/114.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/115.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/116.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/117.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/118.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/119.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/120.png">
<meta property="og:updated_time" content="2020-06-18T03:14:45.534Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="简单内核实现笔记-part-4">
<meta name="twitter:description" content="编写硬盘驱动程序创建新磁盘文件下面我们需要逐步实现文件系统，在此之前我们需要实现一个硬盘驱动程序，我们之前一直操作的hd60M.img为主盘，里面存放的是我们的内核，我们需要创建一个从盘，用于存放后面的文件系统，具体操作如下，创建一个大小为80MB的hd80M.img磁盘 12345678910111213141516171819202122232425262728293031323334/hom">
<meta name="twitter:image" content="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/85.png">



  <link rel="alternate" href="/atom.xml" title="Thunder_J" type="application/atom+xml">




  <link rel="canonical" href="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>简单内核实现笔记-part-4 | Thunder_J</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Thunder_J</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Just for fun</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/11/简单内核实现笔记-part-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Thunder_J">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thunder_J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">简单内核实现笔记-part-4
              
            
          </h1>
        

        <div class="post-meta">
		
		

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-11 08:57:52" itemprop="dateCreated datePublished" datetime="2020-06-11T08:57:52+08:00">2020-06-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-06-18 11:14:45" itemprop="dateModified" datetime="2020-06-18T11:14:45+08:00">2020-06-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">164k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">2:29</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="编写硬盘驱动程序"><a href="#编写硬盘驱动程序" class="headerlink" title="编写硬盘驱动程序"></a>编写硬盘驱动程序</h1><h2 id="创建新磁盘文件"><a href="#创建新磁盘文件" class="headerlink" title="创建新磁盘文件"></a>创建新磁盘文件</h2><p>下面我们需要逐步实现文件系统，在此之前我们需要实现一个硬盘驱动程序，我们之前一直操作的hd60M.img为主盘，里面存放的是我们的内核，我们需要创建一个从盘，用于存放后面的文件系统，具体操作如下，创建一个大小为80MB的hd80M.img磁盘</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/home/guang/soft/bochs-2.6.2/bin &gt; ls // 进入bin目录</span><br><span class="line">bochs  bochs.out  bochsrc.disk  bxcommit  bximage  hd60M.img  kernel  mbr</span><br><span class="line">/home/guang/soft/bochs-2.6.2/bin &gt; sudo ./bximage // 创建磁盘</span><br><span class="line">========================================================================</span><br><span class="line">                                bximage</span><br><span class="line">                  Disk Image Creation Tool for Bochs</span><br><span class="line">          $Id: bximage.c 11315 2012-08-05 18:13:38Z vruppert $</span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line">Do you want to create a floppy disk image or a hard disk image?</span><br><span class="line">Please type hd or fd. [hd] // 回车</span><br><span class="line"></span><br><span class="line">What kind of image should I create?</span><br><span class="line">Please type flat, sparse or growing. [flat] // 回车</span><br><span class="line"></span><br><span class="line">Enter the hard disk size in megabytes, between 1 and 8257535</span><br><span class="line">[10] 80 // 大小选80</span><br><span class="line"></span><br><span class="line">I will create a 'flat' hard disk image with</span><br><span class="line">  cyl=162</span><br><span class="line">  heads=16</span><br><span class="line">  sectors per track=63</span><br><span class="line">  total sectors=163296</span><br><span class="line">  total size=79.73 megabytes</span><br><span class="line"></span><br><span class="line">What should I name the image?</span><br><span class="line">[c.img] hd80M.img // 名称</span><br><span class="line"></span><br><span class="line">Writing: [] Done.</span><br><span class="line"></span><br><span class="line">I wrote 83607552 bytes to hd80M.img.</span><br><span class="line"></span><br><span class="line">The following line should appear in your bochsrc:</span><br><span class="line">  ata0-master: type=disk, path="hd80M.img", mode=flat, cylinders=162, heads=16, spt=63</span><br></pre></td></tr></table></figure>
<p>运行bochs观察0x475处物理地址是否显示硬盘数1，表示之前创建的内核镜像hd60M.img</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:2&gt; c</span><br><span class="line">^CNext at t=83451366</span><br><span class="line">(0) [0x000000001dcd] 0008:c0001dcd (unk. ctxt): mov ebp, esp              ; 89e5</span><br><span class="line">&lt;bochs:3&gt; xp/b 0x475         </span><br><span class="line">[bochs]:</span><br><span class="line">0x00000475 &lt;bogus+       0&gt;:	0x01</span><br><span class="line">&lt;bochs:4&gt;</span><br></pre></td></tr></table></figure>
<p>然后我们需要修改bochsrc.disk文件，将参数写入配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Configuration file for Bochs</span><br><span class="line"># 设置Bochs在运行过程中能够使用的内存: 32 MB</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line"># 设置真实机器的BIOS和VGA BIOS</span><br><span class="line"># 修改成你们对应的地址</span><br><span class="line"></span><br><span class="line">romimage: file=/home/guang/soft/bochs-2.6.2/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=/home/guang/soft/bochs-2.6.2/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"># 设置Bochs所使用的磁盘</span><br><span class="line"># 设置启动盘符</span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line"># 设置日志文件的输出</span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line"># 开启或关闭某些功能，修改成你们对应的地址</span><br><span class="line">mouse: enabled=0</span><br><span class="line">keyboard:keymap=/home/guang/soft/bochs-2.6.2/share/bochs/keymaps/x11-pc-us.map</span><br><span class="line"></span><br><span class="line"># 硬盘设置</span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63</span><br><span class="line">ata0-slave: type=disk, path=&quot;hd80M.img&quot;, mode=flat, cylinders=162, heads=16, spt=63</span><br><span class="line"></span><br><span class="line"># 增加gdb支持</span><br><span class="line"># gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0</span><br></pre></td></tr></table></figure>
<p>再次运行bochs测试，成功写入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:1&gt; c</span><br><span class="line">^CNext at t=46045793</span><br><span class="line">(0) [0x000000003d5c] 0008:c0003d5c (unk. ctxt): mov dword ptr ss:[ebp-4], eax ; 8945fc</span><br><span class="line">&lt;bochs:2&gt; xp/b 0x475 </span><br><span class="line">[bochs]:</span><br><span class="line">0x00000475 &lt;bogus+       0&gt;:	0x02 // 安装成功</span><br><span class="line">&lt;bochs:3&gt;</span><br></pre></td></tr></table></figure>
<h2 id="创建磁盘分区表"><a href="#创建磁盘分区表" class="headerlink" title="创建磁盘分区表"></a>创建磁盘分区表</h2><p>首先我们需要配置hd80M.img，将其分区，因Ubuntu 16.04需要给 EFI 代码留磁盘最开始的1M空间，所以分区是从2048开始的，具体的分区结果如下所示，其中5-9分区属性类型设为未知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设备         启动 Start 末尾 扇区   Size Id 类型</span><br><span class="line">./hd80M.img1       2048   4096   2049     1M 83 Linux</span><br><span class="line">./hd80M.img4       6144 163295 157152  76.8M  5 扩展</span><br><span class="line">./hd80M.img5       8192   9000    809 404.5K 66 未知</span><br><span class="line">./hd80M.img6      11049  12000    952   476K 66 未知</span><br><span class="line">./hd80M.img7      14049  14500    452   226K 66 未知</span><br><span class="line">./hd80M.img8      16549  17000    452   226K 66 未知</span><br><span class="line">./hd80M.img9      19049  20000    952   476K 66 未知</span><br></pre></td></tr></table></figure>
<h2 id="编写硬盘驱动"><a href="#编写硬盘驱动" class="headerlink" title="编写硬盘驱动"></a>编写硬盘驱动</h2><p>现在硬盘上有两个ata通道，第一个通道其中断信号都是挂在8259A的IRQ14上的，第二个通道接在8259A从片的IRQ15上。来自8259A从片的中断都是由8259A主片想处理器传达的，8259A从片是级联在主片的IRQ2接口的，为了让处理器响应8259A从片的中断，需要我们修改interrupt文件，打开中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化可编程中断控制器8259A */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pic_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="comment">/* IRQ2用于级联从片,必须打开,否则无法响应从片上的中断</span></span><br><span class="line"><span class="comment">  主片上打开的中断有IRQ0的时钟,IRQ1的键盘和级联从片的IRQ2,其它全部关闭 */</span></span><br><span class="line">   outb (PIC_M_DATA, <span class="number">0xf8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开从片上的IRQ14,此引脚接收硬盘控制器的中断 */</span></span><br><span class="line">   outb (PIC_S_DATA, <span class="number">0xbf</span>);</span><br><span class="line"></span><br><span class="line">   put_str(<span class="string">"   pic_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在内核实现一个内核打印函数，这样就不需要用console系列打印了，具体实现和printf很相似就不详细说明了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 供内核使用的格式化输出函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printk</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span> </span>&#123;</span><br><span class="line">   va_list args;</span><br><span class="line">   va_start(args, format);</span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="built_in">vsprintf</span>(buf, format, args);</span><br><span class="line">   va_end(args);</span><br><span class="line">   console_put_str(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来具体实现硬盘驱动，首先我们需要引入结构体，具体实现在device目录下创建ide文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分区结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partition</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> start_lba;		 <span class="comment">// 起始扇区</span></span><br><span class="line">   <span class="keyword">uint32_t</span> sec_cnt;		 <span class="comment">// 扇区数</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">disk</span>* <span class="title">my_disk</span>;</span>	 <span class="comment">// 分区所属的硬盘</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">part_tag</span>;</span>	 <span class="comment">// 用于队列中的标记</span></span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">8</span>];		 <span class="comment">// 分区名称</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">sb</span>;</span>	 <span class="comment">// 本分区的超级块</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">block_bitmap</span>;</span>	 <span class="comment">// 块位图</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">inode_bitmap</span>;</span>	 <span class="comment">// i结点位图</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">open_inodes</span>;</span>	 <span class="comment">// 本分区打开的i结点队列</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 硬盘结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">disk</span> &#123;</span></span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">8</span>];			   <span class="comment">// 本硬盘的名称，如sda等</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ide_channel</span>* <span class="title">my_channel</span>;</span>	   <span class="comment">// 此块硬盘归属于哪个ide通道</span></span><br><span class="line">   <span class="keyword">uint8_t</span> dev_no;			   <span class="comment">// 本硬盘是主0还是从1</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">partition</span> <span class="title">prim_parts</span>[4];</span>	   <span class="comment">// 主分区顶多是4个</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">partition</span> <span class="title">logic_parts</span>[8];</span>	   <span class="comment">// 逻辑分区数量无限,但总得有个支持的上限,那就支持8个</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ata通道结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ide_channel</span> &#123;</span></span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">8</span>];		 <span class="comment">// 本ata通道名称 </span></span><br><span class="line">   <span class="keyword">uint16_t</span> port_base;		 <span class="comment">// 本通道的起始端口号</span></span><br><span class="line">   <span class="keyword">uint8_t</span> irq_no;		 <span class="comment">// 本通道所用的中断号</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">lock</span>;</span>		 <span class="comment">// 通道锁</span></span><br><span class="line">   <span class="keyword">bool</span> expecting_intr;		 <span class="comment">// 表示等待硬盘的中断</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">disk_done</span>;</span>	 <span class="comment">// 用于阻塞、唤醒驱动程序</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">disk</span> <span class="title">devices</span>[2];</span>	 <span class="comment">// 一个通道上连接两个硬盘，一主一从</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体实现中我们用到了三个操作命令，分别是identify指令、读扇区指令、写扇区指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一些硬盘操作的指令 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMD_IDENTIFY	   0xec	    <span class="comment">// identify指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMD_READ_SECTOR	   0x20     <span class="comment">// 读扇区指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMD_WRITE_SECTOR   0x30	    <span class="comment">// 写扇区指令</span></span></span><br></pre></td></tr></table></figure>
<p>初始化函数如下，通过获取0x475物理地址处的内容得到硬盘数量，然后通过<code>DIV_ROUND_UP</code>向上取正的宏计算通道数，然后再循环处理每一个通道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> channel_cnt;	   <span class="comment">// 按硬盘数计算的通道数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ide_channel</span> <span class="title">channels</span>[2];</span>	 <span class="comment">// 有两个ide通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 硬盘数据结构初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ide_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   printk(<span class="string">"ide_init start\n"</span>);</span><br><span class="line">   <span class="keyword">uint8_t</span> hd_cnt = *((<span class="keyword">uint8_t</span>*)(<span class="number">0x475</span>));	      <span class="comment">// 获取硬盘的数量</span></span><br><span class="line">   ASSERT(hd_cnt &gt; <span class="number">0</span>);</span><br><span class="line">   channel_cnt = DIV_ROUND_UP(hd_cnt, <span class="number">2</span>);	   <span class="comment">// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ide_channel</span>* <span class="title">channel</span>;</span></span><br><span class="line">   <span class="keyword">uint8_t</span> channel_no = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 处理每个通道上的硬盘 */</span></span><br><span class="line">   <span class="keyword">while</span> (channel_no &lt; channel_cnt) &#123;</span><br><span class="line">      channel = &amp;channels[channel_no];</span><br><span class="line">      <span class="built_in">sprintf</span>(channel-&gt;name, <span class="string">"ide%d"</span>, channel_no);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 为每个ide通道初始化端口基址及中断向量 */</span></span><br><span class="line">      <span class="keyword">switch</span> (channel_no) &#123;</span><br><span class="line">	 <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	    channel-&gt;port_base	 = <span class="number">0x1f0</span>;	   <span class="comment">// ide0通道的起始端口号是0x1f0</span></span><br><span class="line">	    channel-&gt;irq_no	 = <span class="number">0x20</span> + <span class="number">14</span>;	   <span class="comment">// 从片8259a上倒数第二的中断引脚,温盘,也就是ide0通道的的中断向量号</span></span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	    channel-&gt;port_base	 = <span class="number">0x170</span>;	   <span class="comment">// ide1通道的起始端口号是0x170</span></span><br><span class="line">	    channel-&gt;irq_no	 = <span class="number">0x20</span> + <span class="number">15</span>;	   <span class="comment">// 从8259A上的最后一个中断引脚,我们用来响应ide1通道上的硬盘中断</span></span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      channel-&gt;expecting_intr = <span class="literal">false</span>;		   <span class="comment">// 未向硬盘写入指令时不期待硬盘的中断</span></span><br><span class="line">      lock_init(&amp;channel-&gt;lock);		     </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化为0,目的是向硬盘控制器请求数据后,硬盘驱动sema_down此信号量会阻塞线程,</span></span><br><span class="line"><span class="comment">   直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */</span></span><br><span class="line">      sema_init(&amp;channel-&gt;disk_done, <span class="number">0</span>);</span><br><span class="line">      channel_no++;				   <span class="comment">// 下一个channel</span></span><br><span class="line">   &#125;</span><br><span class="line">   printk(<span class="string">"ide_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完善基础构件"><a href="#完善基础构件" class="headerlink" title="完善基础构件"></a>完善基础构件</h2><p>在下一步之前我们需要完善一些基础构建，首先我们需要实现thread_yield，其作用是主动把CPU使用权让出来，代码添加在thread文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 主动让出cpu,换其它线程运行 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_yield</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span>   </span><br><span class="line">   <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">   ASSERT(!elem_find(&amp;thread_ready_list, &amp;cur-&gt;general_tag));</span><br><span class="line">   list_append(&amp;thread_ready_list, &amp;cur-&gt;general_tag); <span class="comment">// 当前任务添加到就绪队列队尾</span></span><br><span class="line">   cur-&gt;status = TASK_READY; <span class="comment">// 设置标志</span></span><br><span class="line">   schedule(); <span class="comment">// 调度</span></span><br><span class="line">   intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步实现idle线程，此线程作用就是当就绪队列中没有任务时运行，以免系统悬停在其他地方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 系统空闲时运行的线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">idle</span><span class="params">(<span class="keyword">void</span>* arg UNUSED)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      thread_block(TASK_BLOCKED);     </span><br><span class="line">      <span class="comment">//执行hlt时必须要保证目前处在开中断的情况下</span></span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"sti; hlt"</span> : : : <span class="string">"memory"</span>)</span></span>; <span class="comment">// hlt指令使处理器挂起</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们需要实现休眠函数，也就是经常使用的sleep函数，为的是当磁盘操作的时候使CPU去执行其他任务，避免资源浪费，改动在timer文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ0_FREQUENCY	   100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mil_seconds_per_intr (1000 / IRQ0_FREQUENCY) <span class="comment">// 每秒100次中断</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> ticks;          <span class="comment">// ticks是内核自中断开启以来总共的嘀嗒数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以tick为单位的sleep,任何时间形式的sleep会转换此ticks形式 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ticks_to_sleep</span><span class="params">(<span class="keyword">uint32_t</span> sleep_ticks)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> start_tick = ticks;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 若间隔的ticks数不够便让出cpu */</span></span><br><span class="line">   <span class="keyword">while</span> (ticks - start_tick &lt; sleep_ticks) &#123;</span><br><span class="line">      thread_yield();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以毫秒为单位的sleep   1秒= 1000毫秒 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mtime_sleep</span><span class="params">(<span class="keyword">uint32_t</span> m_seconds)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> sleep_ticks = DIV_ROUND_UP(m_seconds, mil_seconds_per_intr); <span class="comment">// 毫秒转化为时钟滴答数</span></span><br><span class="line">  ASSERT(sleep_ticks &gt; <span class="number">0</span>);</span><br><span class="line">  ticks_to_sleep(sleep_ticks); <span class="comment">// 底层还是调用ticks_to_sleep</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来继续实现硬盘中断处理函数，下面是选择主盘和从盘的函数，原理就是判断DEV位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择读写的硬盘 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select_disk</span><span class="params">(struct disk* hd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint8_t</span> reg_device = BIT_DEV_MBS | BIT_DEV_LBA;</span><br><span class="line">   <span class="keyword">if</span> (hd-&gt;dev_no == <span class="number">1</span>) &#123;	<span class="comment">// 若是从盘就置DEV位为1</span></span><br><span class="line">      reg_device |= BIT_DEV_DEV;</span><br><span class="line">   &#125;</span><br><span class="line">   outb(reg_dev(hd-&gt;my_channel), reg_device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入硬盘控制器函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 向硬盘控制器写入起始扇区地址及要读写的扇区数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select_sector</span><span class="params">(struct disk* hd, <span class="keyword">uint32_t</span> lba, <span class="keyword">uint8_t</span> sec_cnt)</span> </span>&#123;</span><br><span class="line">   ASSERT(lba &lt;= max_lba);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ide_channel</span>* <span class="title">channel</span> = <span class="title">hd</span>-&gt;<span class="title">my_channel</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 写入要读写的扇区数*/</span></span><br><span class="line">   outb(reg_sect_cnt(channel), sec_cnt);	 <span class="comment">// 如果sec_cnt为0,则表示写入256个扇区</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 写入lba地址(即扇区号) */</span></span><br><span class="line">   outb(reg_lba_l(channel), lba);		 <span class="comment">// lba地址的低8位,不用单独取出低8位.outb函数中的汇编指令outb %b0, %w1会只用al。</span></span><br><span class="line">   outb(reg_lba_m(channel), lba &gt;&gt; <span class="number">8</span>);		 <span class="comment">// lba地址的8~15位</span></span><br><span class="line">   outb(reg_lba_h(channel), lba &gt;&gt; <span class="number">16</span>);		 <span class="comment">// lba地址的16~23位</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 因为lba地址的24~27位要存储在device寄存器的0～3位,</span></span><br><span class="line"><span class="comment">    * 无法单独写入这4位,所以在此处把device寄存器再重新写入一次*/</span></span><br><span class="line">   outb(reg_dev(channel), BIT_DEV_MBS | BIT_DEV_LBA | (hd-&gt;dev_no == <span class="number">1</span> ? BIT_DEV_DEV : <span class="number">0</span>) | lba &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令发送函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 向通道channel发命令cmd */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_out</span><span class="params">(struct ide_channel* channel, <span class="keyword">uint8_t</span> cmd)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 只要向硬盘发出了命令便将此标记置为true,硬盘中断处理程序需要根据它来判断 */</span></span><br><span class="line">   channel-&gt;expecting_intr = <span class="literal">true</span>;</span><br><span class="line">   outb(reg_cmd(channel), cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读写硬盘中数据的函数和等待函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 硬盘读入sec_cnt个扇区的数据到buf */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_from_sector</span><span class="params">(struct disk* hd, <span class="keyword">void</span>* buf, <span class="keyword">uint8_t</span> sec_cnt)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> size_in_byte;</span><br><span class="line">   <span class="keyword">if</span> (sec_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */</span></span><br><span class="line">      size_in_byte = <span class="number">256</span> * <span class="number">512</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      size_in_byte = sec_cnt * <span class="number">512</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   insw(reg_data(hd-&gt;my_channel), buf, size_in_byte / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将buf中sec_cnt扇区的数据写入硬盘 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write2sector</span><span class="params">(struct disk* hd, <span class="keyword">void</span>* buf, <span class="keyword">uint8_t</span> sec_cnt)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> size_in_byte;</span><br><span class="line">   <span class="keyword">if</span> (sec_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */</span></span><br><span class="line">      size_in_byte = <span class="number">256</span> * <span class="number">512</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      size_in_byte = sec_cnt * <span class="number">512</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   outsw(reg_data(hd-&gt;my_channel), buf, size_in_byte / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待30秒 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">busy_wait</span><span class="params">(struct disk* hd)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ide_channel</span>* <span class="title">channel</span> = <span class="title">hd</span>-&gt;<span class="title">my_channel</span>;</span></span><br><span class="line">   <span class="keyword">uint16_t</span> time_limit = <span class="number">30</span> * <span class="number">1000</span>;	     <span class="comment">// 可以等待30000毫秒</span></span><br><span class="line">   <span class="keyword">while</span> (time_limit -= <span class="number">10</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(inb(reg_status(channel)) &amp; BIT_STAT_BSY)) &#123;</span><br><span class="line">	 <span class="keyword">return</span> (inb(reg_status(channel)) &amp; BIT_STAT_DRQ);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 mtime_sleep(<span class="number">10</span>);		     <span class="comment">// 睡眠10毫秒</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读写硬盘函数和中断处理函数，注意和上面函数的区别，下面的函数是从硬盘hd的扇区地址lba处读取sec_cnt个扇区到buf，上面的函数是从硬盘hd中读入sec_cnt个扇区的数据到buf</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从硬盘读取sec_cnt个扇区到buf */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ide_read</span><span class="params">(struct disk* hd, <span class="keyword">uint32_t</span> lba, <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> sec_cnt)</span> </span>&#123; </span><br><span class="line">   ASSERT(lba &lt;= max_lba);</span><br><span class="line">   ASSERT(sec_cnt &gt; <span class="number">0</span>);</span><br><span class="line">   lock_acquire (&amp;hd-&gt;my_channel-&gt;lock); <span class="comment">// 先上锁保证操作唯一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1 先选择操作的硬盘 */</span></span><br><span class="line">   select_disk(hd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> secs_op;		 <span class="comment">// 每次操作的扇区数</span></span><br><span class="line">   <span class="keyword">uint32_t</span> secs_done = <span class="number">0</span>;	 <span class="comment">// 已完成的扇区数</span></span><br><span class="line">   <span class="keyword">while</span>(secs_done &lt; sec_cnt) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((secs_done + <span class="number">256</span>) &lt;= sec_cnt) &#123;</span><br><span class="line">	 secs_op = <span class="number">256</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 secs_op = sec_cnt - secs_done;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 写入待读入的扇区数和起始扇区号 */</span></span><br><span class="line">      select_sector(hd, lba + secs_done, secs_op);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3 执行的命令写入reg_cmd寄存器 */</span></span><br><span class="line">      cmd_out(hd-&gt;my_channel, CMD_READ_SECTOR);	  <span class="comment">// 准备开始读数据</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*********************   阻塞自己的时机  ***********************</span></span><br><span class="line"><span class="comment">      在硬盘已经开始工作(开始在内部读数据或写数据)后才能阻塞自己,现在硬盘已经开始忙了,</span></span><br><span class="line"><span class="comment">      将自己阻塞,等待硬盘完成读操作后通过中断处理程序唤醒自己*/</span></span><br><span class="line">      sema_down(&amp;hd-&gt;my_channel-&gt;disk_done);</span><br><span class="line">   <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 检测硬盘状态是否可读 */</span></span><br><span class="line">      <span class="comment">/* 醒来后开始执行下面代码*/</span></span><br><span class="line">      <span class="keyword">if</span> (!busy_wait(hd)) &#123;	 <span class="comment">// 若失败</span></span><br><span class="line">	 <span class="keyword">char</span> error[<span class="number">64</span>];</span><br><span class="line">	 <span class="built_in">sprintf</span>(error, <span class="string">"%s read sector %d failed!!!!!!\n"</span>, hd-&gt;name, lba);</span><br><span class="line">	 PANIC(error);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 5 把数据从硬盘的缓冲区中读出 */</span></span><br><span class="line">      read_from_sector(hd, (<span class="keyword">void</span>*)((<span class="keyword">uint32_t</span>)buf + secs_done * <span class="number">512</span>), secs_op);</span><br><span class="line">      secs_done += secs_op;</span><br><span class="line">   &#125;</span><br><span class="line">   lock_release(&amp;hd-&gt;my_channel-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将buf中sec_cnt扇区数据写入硬盘 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ide_write</span><span class="params">(struct disk* hd, <span class="keyword">uint32_t</span> lba, <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> sec_cnt)</span> </span>&#123;</span><br><span class="line">   ASSERT(lba &lt;= max_lba);</span><br><span class="line">   ASSERT(sec_cnt &gt; <span class="number">0</span>);</span><br><span class="line">   lock_acquire (&amp;hd-&gt;my_channel-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1 先选择操作的硬盘 */</span></span><br><span class="line">   select_disk(hd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> secs_op;		 <span class="comment">// 每次操作的扇区数</span></span><br><span class="line">   <span class="keyword">uint32_t</span> secs_done = <span class="number">0</span>;	 <span class="comment">// 已完成的扇区数</span></span><br><span class="line">   <span class="keyword">while</span>(secs_done &lt; sec_cnt) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((secs_done + <span class="number">256</span>) &lt;= sec_cnt) &#123;</span><br><span class="line">	 secs_op = <span class="number">256</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 secs_op = sec_cnt - secs_done;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 写入待写入的扇区数和起始扇区号 */</span></span><br><span class="line">      select_sector(hd, lba + secs_done, secs_op);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3 执行的命令写入reg_cmd寄存器 */</span></span><br><span class="line">      cmd_out(hd-&gt;my_channel, CMD_WRITE_SECTOR);	      <span class="comment">// 准备开始写数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 检测硬盘状态是否可读 */</span></span><br><span class="line">      <span class="keyword">if</span> (!busy_wait(hd)) &#123;			      <span class="comment">// 若失败</span></span><br><span class="line">	 <span class="keyword">char</span> error[<span class="number">64</span>];</span><br><span class="line">	 <span class="built_in">sprintf</span>(error, <span class="string">"%s write sector %d failed!!!!!!\n"</span>, hd-&gt;name, lba);</span><br><span class="line">	 PANIC(error);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5 将数据写入硬盘 */</span></span><br><span class="line">      write2sector(hd, (<span class="keyword">void</span>*)((<span class="keyword">uint32_t</span>)buf + secs_done * <span class="number">512</span>), secs_op);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 在硬盘响应期间阻塞自己 */</span></span><br><span class="line">      sema_down(&amp;hd-&gt;my_channel-&gt;disk_done);</span><br><span class="line">      secs_done += secs_op;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 醒来后开始释放锁*/</span></span><br><span class="line">   lock_release(&amp;hd-&gt;my_channel-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 硬盘中断处理程序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intr_hd_handler</span><span class="params">(<span class="keyword">uint8_t</span> irq_no)</span> </span>&#123;</span><br><span class="line">   ASSERT(irq_no == <span class="number">0x2e</span> || irq_no == <span class="number">0x2f</span>);</span><br><span class="line">   <span class="keyword">uint8_t</span> ch_no = irq_no - <span class="number">0x2e</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ide_channel</span>* <span class="title">channel</span> = &amp;<span class="title">channels</span>[<span class="title">ch_no</span>];</span></span><br><span class="line">   ASSERT(channel-&gt;irq_no == irq_no);</span><br><span class="line"><span class="comment">/* 不必担心此中断是否对应的是这一次的expecting_intr,</span></span><br><span class="line"><span class="comment"> * 每次读写硬盘时会申请锁,从而保证了同步一致性 */</span></span><br><span class="line">   <span class="keyword">if</span> (channel-&gt;expecting_intr) &#123;</span><br><span class="line">      channel-&gt;expecting_intr = <span class="literal">false</span>;</span><br><span class="line">      sema_up(&amp;channel-&gt;disk_done);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取状态寄存器使硬盘控制器认为此次的中断已被处理,从而硬盘可以继续执行新的读写 */</span></span><br><span class="line">      inb(reg_status(channel));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取硬盘信息和扫描分区表"><a href="#获取硬盘信息和扫描分区表" class="headerlink" title="获取硬盘信息和扫描分区表"></a>获取硬盘信息和扫描分区表</h2><p>获取硬盘信息需要用到identify命令，其返回内容如下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/85.png" alt="image-20200612181835991"></p>
<p>扫描分区表需要从MBR开始一步一步遍历主分区，找到扩展分区，然后递归每一个子扩展分区，找到逻辑分区，还是在ide文件中，下面是添加的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用于记录总扩展分区的起始lba,初始为0,partition_scan时以此为标记 */</span></span><br><span class="line"><span class="keyword">int32_t</span> ext_lba_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> p_no = <span class="number">0</span>, l_no = <span class="number">0</span>;	 <span class="comment">// 用来记录硬盘主分区和逻辑分区的下标</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">partition_list</span>;</span>	 <span class="comment">// 分区队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构建一个16字节大小的结构体,用来存分区表项 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partition_table_entry</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint8_t</span>  bootable;		 <span class="comment">// 是否可引导	</span></span><br><span class="line">   <span class="keyword">uint8_t</span>  start_head;		 <span class="comment">// 起始磁头号</span></span><br><span class="line">   <span class="keyword">uint8_t</span>  start_sec;		 <span class="comment">// 起始扇区号</span></span><br><span class="line">   <span class="keyword">uint8_t</span>  start_chs;		 <span class="comment">// 起始柱面号</span></span><br><span class="line">   <span class="keyword">uint8_t</span>  fs_type;		 <span class="comment">// 分区类型</span></span><br><span class="line">   <span class="keyword">uint8_t</span>  end_head;		 <span class="comment">// 结束磁头号</span></span><br><span class="line">   <span class="keyword">uint8_t</span>  end_sec;		 <span class="comment">// 结束扇区号</span></span><br><span class="line">   <span class="keyword">uint8_t</span>  end_chs;		 <span class="comment">// 结束柱面号</span></span><br><span class="line"><span class="comment">/* 更需要关注的是下面这两项 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> start_lba;		 <span class="comment">// 本分区起始扇区的lba地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> sec_cnt;		 <span class="comment">// 本分区的扇区数目</span></span><br><span class="line">&#125; __attribute__ ((packed));	 <span class="comment">// 保证此结构是16字节大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引导扇区,mbr或ebr所在的扇区 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">boot_sector</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint8_t</span>  other[<span class="number">446</span>];		 <span class="comment">// 引导代码</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span>   <span class="title">partition_table_entry</span> <span class="title">partition_table</span>[4];</span>       <span class="comment">// 分区表中有4项,共64字节</span></span><br><span class="line">   <span class="keyword">uint16_t</span> signature;		 <span class="comment">// 启动扇区的结束标志是0x55,0xaa,</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>
<p>下面是获取硬盘参数的具体实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将dst中len个相邻字节交换位置后存入buf */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap_pairs_bytes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dst, <span class="keyword">char</span>* buf, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint8_t</span> idx;</span><br><span class="line">   <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; len; idx += <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">/* buf中存储dst中两相邻元素交换位置后的字符串*/</span></span><br><span class="line">      buf[idx + <span class="number">1</span>] = *dst++;   </span><br><span class="line">      buf[idx]     = *dst++;   </span><br><span class="line">   &#125;</span><br><span class="line">   buf[idx] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得硬盘参数信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">identify_disk</span><span class="params">(struct disk* hd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> id_info[<span class="number">512</span>];</span><br><span class="line">   select_disk(hd);</span><br><span class="line">   cmd_out(hd-&gt;my_channel, CMD_IDENTIFY);</span><br><span class="line"><span class="comment">/* 向硬盘发送指令后便通过信号量阻塞自己,</span></span><br><span class="line"><span class="comment"> * 待硬盘处理完成后,通过中断处理程序将自己唤醒 */</span></span><br><span class="line">   sema_down(&amp;hd-&gt;my_channel-&gt;disk_done);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 醒来后开始执行下面代码*/</span></span><br><span class="line">   <span class="keyword">if</span> (!busy_wait(hd)) &#123;     <span class="comment">//  若失败</span></span><br><span class="line">      <span class="keyword">char</span> error[<span class="number">64</span>];</span><br><span class="line">      <span class="built_in">sprintf</span>(error, <span class="string">"%s identify failed!!!!!!\n"</span>, hd-&gt;name);</span><br><span class="line">      PANIC(error);</span><br><span class="line">   &#125;</span><br><span class="line">   read_from_sector(hd, id_info, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">   <span class="keyword">uint8_t</span> sn_start = <span class="number">10</span> * <span class="number">2</span>, sn_len = <span class="number">20</span>, md_start = <span class="number">27</span> * <span class="number">2</span>, md_len = <span class="number">40</span>;</span><br><span class="line">   swap_pairs_bytes(&amp;id_info[sn_start], buf, sn_len);</span><br><span class="line">   printk(<span class="string">"   disk %s info:\n      SN: %s\n"</span>, hd-&gt;name, buf);</span><br><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">   swap_pairs_bytes(&amp;id_info[md_start], buf, md_len);</span><br><span class="line">   printk(<span class="string">"      MODULE: %s\n"</span>, buf);</span><br><span class="line">   <span class="keyword">uint32_t</span> sectors = *(<span class="keyword">uint32_t</span>*)&amp;id_info[<span class="number">60</span> * <span class="number">2</span>];</span><br><span class="line">   printk(<span class="string">"      SECTORS: %d\n"</span>, sectors);</span><br><span class="line">   printk(<span class="string">"      CAPACITY: %dMB\n"</span>, sectors * <span class="number">512</span> / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是扫描分区表的具体实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 扫描硬盘hd中地址为ext_lba的扇区中的所有分区 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partition_scan</span><span class="params">(struct disk* hd, <span class="keyword">uint32_t</span> ext_lba)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">boot_sector</span>* <span class="title">bs</span> = <span class="title">sys_malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">boot_sector</span>));</span> <span class="comment">// 动态申请内存存放，避免栈溢出</span></span><br><span class="line">   ide_read(hd, ext_lba, bs, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">uint8_t</span> part_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">partition_table_entry</span>* <span class="title">p</span> = <span class="title">bs</span>-&gt;<span class="title">partition_table</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 遍历分区表4个分区表项 */</span></span><br><span class="line">   <span class="keyword">while</span> (part_idx++ &lt; <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fs_type == <span class="number">0x5</span>) &#123;	 <span class="comment">// 若为扩展分区</span></span><br><span class="line">	 <span class="keyword">if</span> (ext_lba_base != <span class="number">0</span>) &#123; </span><br><span class="line">	 <span class="comment">/* 子扩展分区的start_lba是相对于主引导扇区中的总扩展分区地址 */</span></span><br><span class="line">	    partition_scan(hd, p-&gt;start_lba + ext_lba_base);</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123; <span class="comment">// ext_lba_base为0表示是第一次读取引导块,也就是主引导记录所在的扇区</span></span><br><span class="line">	 <span class="comment">/* 记录下扩展分区的起始lba地址,后面所有的扩展分区地址都相对于此 */</span></span><br><span class="line">	    ext_lba_base = p-&gt;start_lba;</span><br><span class="line">	    partition_scan(hd, p-&gt;start_lba);</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;fs_type != <span class="number">0</span>) &#123; <span class="comment">// 若是有效的分区类型</span></span><br><span class="line">	 <span class="keyword">if</span> (ext_lba == <span class="number">0</span>) &#123;	 <span class="comment">// 此时全是主分区</span></span><br><span class="line">	    hd-&gt;prim_parts[p_no].start_lba = ext_lba + p-&gt;start_lba;</span><br><span class="line">	    hd-&gt;prim_parts[p_no].sec_cnt = p-&gt;sec_cnt;</span><br><span class="line">	    hd-&gt;prim_parts[p_no].my_disk = hd;</span><br><span class="line">	    list_append(&amp;partition_list, &amp;hd-&gt;prim_parts[p_no].part_tag);</span><br><span class="line">	    <span class="built_in">sprintf</span>(hd-&gt;prim_parts[p_no].name, <span class="string">"%s%d"</span>, hd-&gt;name, p_no + <span class="number">1</span>);</span><br><span class="line">	    p_no++;</span><br><span class="line">	    ASSERT(p_no &lt; <span class="number">4</span>);	    <span class="comment">// 0,1,2,3</span></span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    hd-&gt;logic_parts[l_no].start_lba = ext_lba + p-&gt;start_lba;</span><br><span class="line">	    hd-&gt;logic_parts[l_no].sec_cnt = p-&gt;sec_cnt;</span><br><span class="line">	    hd-&gt;logic_parts[l_no].my_disk = hd;</span><br><span class="line">	    list_append(&amp;partition_list, &amp;hd-&gt;logic_parts[l_no].part_tag);</span><br><span class="line">	    <span class="built_in">sprintf</span>(hd-&gt;logic_parts[l_no].name, <span class="string">"%s%d"</span>, hd-&gt;name, l_no + <span class="number">5</span>);	 <span class="comment">// 逻辑分区数字是从5开始,主分区是1～4.</span></span><br><span class="line">	    l_no++;</span><br><span class="line">	    <span class="keyword">if</span> (l_no &gt;= <span class="number">8</span>)    <span class="comment">// 只支持8个逻辑分区,避免数组越界</span></span><br><span class="line">	       <span class="keyword">return</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; </span><br><span class="line">      p++;</span><br><span class="line">   &#125;</span><br><span class="line">   sys_free(bs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印分区信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">partition_info</span><span class="params">(struct list_elem* pelem, <span class="keyword">int</span> arg UNUSED)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">partition</span>* <span class="title">part</span> = <span class="title">elem2entry</span>(<span class="title">struct</span> <span class="title">partition</span>, <span class="title">part_tag</span>, <span class="title">pelem</span>);</span></span><br><span class="line">   printk(<span class="string">"   %s start_lba:0x%x, sec_cnt:0x%x\n"</span>,part-&gt;name, part-&gt;start_lba, part-&gt;sec_cnt);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在此处return false与函数本身功能无关,</span></span><br><span class="line"><span class="comment"> * 只是为了让主调函数list_traversal继续向下遍历元素 */</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下所示</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/86.png" alt="86"></p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>扇区：硬盘是低速设备，其读写单位是扇区。</p>
<p>块：Windows系统中称为簇，一个块由多个扇区组成，磁盘在进行读写数据的时候，不可能有一扇区的数据就读或写一次，而是等数据累计到一定量后，在统一进行读写，而这个数据量就叫块。</p>
<p>块是文件系统的读写单位，故文件起码得有一个块大小，若大于一个块，就需要我们用不同的文件系统对其进行管理，其中FAT采用的就是链式文件系统，如下所示，其弊端是每次寻找块的时候需要从头开始遍历，效率很低，这也是早期Windows采用的管理方法</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/87.png" alt="image-20200612181835991"></p>
<p>索引式文件系统是进入UNIX时代的产物，它为文件的所有块建立一个索引表，索引表就是块地址数组，每个数组元素就是块的地址，第n个数组元素指向文件中的第n个块，这样访问任意一个块的时候，只需要从索引表中获得块地址就可以了。而且文件中的块依然可以分散到不连续的零散空间中，索引表的索引结构称为inode，一个文件对应一个inode</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/88.png" alt="image-20200612181835991"></p>
<p>和页表机制类似，索引表本身占用内存，当其很大的时候就有一级间接索引表、二级间接索引表、三级间接索引表，结构如下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/89.png" alt="image-20200612181835991"></p>
<p>接下来说说目录和目录项，目录本身也是通过inode表示，区分目录和文件的方法是通过查看inode中数据块，普通文件的inode的数据块是指向普通文件自己的数据的，目录的inode的数据块是指向位于该目录下的目录项的。在目录项中会记录该文件的类型，是属于普通文件，还是属于一个目录。目录项结构图如下，索引文件数据的步骤：</p>
<ol>
<li>首先通过文件名找到位于该目录项中对应的inode编号</li>
<li>然后通过通过这个inode编号在inode数组中找到该文件对应的inode</li>
<li>最后通过这个文件对应的inode找到该文件对应的数据。</li>
</ol>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/90.png" alt="image-20200612181835991"></p>
<p>用于管理inode结构和记录的数据结构叫做超级块，超级块的位置和大小是固定的，它被固定存储在各个分区的第2个扇区中，通常占用1扇区的大小，可以类比PCB结构，结构图如下所示</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/91.png" alt="image-20200612181835991"></p>
<h2 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h2><p>接下来开始一步一步实现，文件系统部分的函数很多，不建议纠结一个函数的作用，要从整体上思考其作用何在，接下来我们开始创建上述的一些数据结构，下面是超级块结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 超级块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;         <span class="comment">// 用来标识文件系统类型,支持多文件系统的操作系统通过此标志来识别文件系统类型</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sec_cnt;       <span class="comment">// 本分区总共的扇区数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> inode_cnt;     <span class="comment">// 本分区中inode数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> part_lba_base; <span class="comment">// 本分区的起始lba地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> block_bitmap_lba;   <span class="comment">// 块位图本身起始扇区地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> block_bitmap_sects; <span class="comment">// 扇区位图本身占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> inode_bitmap_lba;   <span class="comment">// inode位图起始扇区lba地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> inode_bitmap_sects; <span class="comment">// inode位图占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> inode_table_lba;   <span class="comment">// inode表起始扇区lba地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> inode_table_sects; <span class="comment">// inode表占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> data_start_lba; <span class="comment">// 数据区开始的第一个扇区号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> root_inode_no;  <span class="comment">// 根目录所在的I结点号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dir_entry_size; <span class="comment">// 目录项大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> pad[<span class="number">460</span>]; <span class="comment">// 加上460字节,凑够512字节1扇区大小</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>inode结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i_no;  <span class="comment">// inode编号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i_size; <span class="comment">// 此inode为文件时，表示文件的大小。为目录时，表示该目录下所有目录项大小之和 </span></span><br><span class="line">    <span class="keyword">uint32_t</span> i_open_cnts; <span class="comment">// 文件被打开的次数</span></span><br><span class="line">    <span class="keyword">bool</span> write_deny;  <span class="comment">// 写文件的标识，防止多个进行同时对一个文件写</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> i_sectors[<span class="number">13</span>]; <span class="comment">// 一个文件只支持13个块，12个直接块，1个间接块。在这个文件系统中，块的大小直接等于1扇区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">inode_tag</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>目录和目录项的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> file_types </span><br><span class="line">&#123;</span><br><span class="line">    FT_UNKNOWN,   </span><br><span class="line">    FT_REGULAR,   </span><br><span class="line">    FT_DIRECTORY  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目录结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span>;</span>   </span><br><span class="line">   <span class="keyword">uint32_t</span> dir_pos;	  <span class="comment">// 记录在目录内的偏移</span></span><br><span class="line">   <span class="keyword">uint8_t</span> dir_buf[<span class="number">512</span>];  <span class="comment">// 目录的数据缓存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目录项结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> &#123;</span></span><br><span class="line">   <span class="keyword">char</span> filename[MAX_FILE_NAME_LEN];  <span class="comment">// 普通文件或目录名称</span></span><br><span class="line">   <span class="keyword">uint32_t</span> i_no;		      <span class="comment">// 普通文件或目录对应的inode编号</span></span><br><span class="line">   <span class="keyword">enum</span> file_types f_type;	      <span class="comment">// 文件类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建文件系统有以下几步：</p>
<ol>
<li>根据分区大小，计算分区文件系统各元信息需要的扇区数及位置</li>
<li>在内存中创建超级块，将上面的元信息写入超级块</li>
<li>将超级块写入磁盘</li>
<li>将元信息写入磁盘上各自的位置</li>
<li>将根目录写入磁盘</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 格式化分区,也就是初始化分区的元信息,创建文件系统 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partition_format</span><span class="params">(struct partition* part)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 为方便实现,一个块大小是一扇区 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> boot_sector_sects = <span class="number">1</span>;	  </span><br><span class="line">   <span class="keyword">uint32_t</span> super_block_sects = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> inode_bitmap_sects = DIV_ROUND_UP(MAX_FILES_PER_PART, BITS_PER_SECTOR);	   <span class="comment">// I结点位图占用的扇区数.最多支持4096个文件</span></span><br><span class="line">   <span class="keyword">uint32_t</span> inode_table_sects = DIV_ROUND_UP(((<span class="keyword">sizeof</span>(struct inode) * MAX_FILES_PER_PART)), SECTOR_SIZE);</span><br><span class="line">   <span class="keyword">uint32_t</span> used_sects = boot_sector_sects + super_block_sects + inode_bitmap_sects + inode_table_sects;</span><br><span class="line">   <span class="keyword">uint32_t</span> free_sects = part-&gt;sec_cnt - used_sects;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/************** 简单处理块位图占据的扇区数 ***************/</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_bitmap_sects;</span><br><span class="line">   block_bitmap_sects = DIV_ROUND_UP(free_sects, BITS_PER_SECTOR);</span><br><span class="line">   <span class="comment">/* block_bitmap_bit_len是位图中位的长度,也是可用块的数量 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_bitmap_bit_len = free_sects - block_bitmap_sects; </span><br><span class="line">   block_bitmap_sects = DIV_ROUND_UP(block_bitmap_bit_len, BITS_PER_SECTOR); </span><br><span class="line"><span class="comment">/*********************************************************/</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 超级块初始化 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> <span class="title">sb</span>;</span></span><br><span class="line">   sb.magic = <span class="number">0x19590318</span>;</span><br><span class="line">   sb.sec_cnt = part-&gt;sec_cnt;</span><br><span class="line">   sb.inode_cnt = MAX_FILES_PER_PART;</span><br><span class="line">   sb.part_lba_base = part-&gt;start_lba;</span><br><span class="line"></span><br><span class="line">   sb.block_bitmap_lba = sb.part_lba_base + <span class="number">2</span>;	 <span class="comment">// 第0块是引导块,第1块是超级块</span></span><br><span class="line">   sb.block_bitmap_sects = block_bitmap_sects;</span><br><span class="line"></span><br><span class="line">   sb.inode_bitmap_lba = sb.block_bitmap_lba + sb.block_bitmap_sects;</span><br><span class="line">   sb.inode_bitmap_sects = inode_bitmap_sects;</span><br><span class="line"></span><br><span class="line">   sb.inode_table_lba = sb.inode_bitmap_lba + sb.inode_bitmap_sects;</span><br><span class="line">   sb.inode_table_sects = inode_table_sects; </span><br><span class="line"></span><br><span class="line">   sb.data_start_lba = sb.inode_table_lba + sb.inode_table_sects;</span><br><span class="line">   sb.root_inode_no = <span class="number">0</span>;</span><br><span class="line">   sb.dir_entry_size = <span class="keyword">sizeof</span>(struct dir_entry);</span><br><span class="line"></span><br><span class="line">   printk(<span class="string">"%s info:\n"</span>, part-&gt;name);</span><br><span class="line">   printk(<span class="string">"   magic:0x%x\n   part_lba_base:0x%x\n   all_sectors:0x%x\n   inode_cnt:0x%x\n   block_bitmap_lba:0x%x\n   block_bitmap_sectors:0x%x\n   inode_bitmap_lba:0x%x\n   inode_bitmap_sectors:0x%x\n   inode_table_lba:0x%x\n   inode_table_sectors:0x%x\n   data_start_lba:0x%x\n"</span>, sb.magic, sb.part_lba_base, sb.sec_cnt, sb.inode_cnt, sb.block_bitmap_lba, sb.block_bitmap_sects, sb.inode_bitmap_lba, sb.inode_bitmap_sects, sb.inode_table_lba, sb.inode_table_sects, sb.data_start_lba);</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">disk</span>* <span class="title">hd</span> = <span class="title">part</span>-&gt;<span class="title">my_disk</span>;</span></span><br><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment"> * 1 将超级块写入本分区的1扇区 *</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line">   ide_write(hd, part-&gt;start_lba + <span class="number">1</span>, &amp;sb, <span class="number">1</span>);</span><br><span class="line">   printk(<span class="string">"   super_block_lba:0x%x\n"</span>, part-&gt;start_lba + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 找出数据量最大的元信息,用其尺寸做存储缓冲区*/</span></span><br><span class="line">   <span class="keyword">uint32_t</span> buf_size = (sb.block_bitmap_sects &gt;= sb.inode_bitmap_sects ? sb.block_bitmap_sects : sb.inode_bitmap_sects);</span><br><span class="line">   buf_size = (buf_size &gt;= sb.inode_table_sects ? buf_size : sb.inode_table_sects) * SECTOR_SIZE;</span><br><span class="line">   <span class="keyword">uint8_t</span>* buf = (<span class="keyword">uint8_t</span>*)sys_malloc(buf_size);	<span class="comment">// 申请的内存由内存管理系统清0后返回</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">/**************************************</span></span><br><span class="line"><span class="comment"> * 2 将块位图初始化并写入sb.block_bitmap_lba *</span></span><br><span class="line"><span class="comment"> *************************************/</span></span><br><span class="line">   <span class="comment">/* 初始化块位图block_bitmap */</span></span><br><span class="line">   buf[<span class="number">0</span>] |= <span class="number">0x01</span>;       <span class="comment">// 第0个块预留给根目录,位图中先占位</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_bitmap_last_byte = block_bitmap_bit_len / <span class="number">8</span>;</span><br><span class="line">   <span class="keyword">uint8_t</span>  block_bitmap_last_bit  = block_bitmap_bit_len % <span class="number">8</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> last_size = SECTOR_SIZE - (block_bitmap_last_byte % SECTOR_SIZE);	     <span class="comment">// last_size是位图所在最后一个扇区中，不足一扇区的其余部分</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 1 先将位图最后一字节到其所在的扇区的结束全置为1,即超出实际块数的部分直接置为已占用*/</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;buf[block_bitmap_last_byte], <span class="number">0xff</span>, last_size);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 2 再将上一步中覆盖的最后一字节内的有效位重新置0 */</span></span><br><span class="line">   <span class="keyword">uint8_t</span> bit_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (bit_idx &lt;= block_bitmap_last_bit) &#123;</span><br><span class="line">      buf[block_bitmap_last_byte] &amp;= ~(<span class="number">1</span> &lt;&lt; bit_idx++);</span><br><span class="line">   &#125;</span><br><span class="line">   ide_write(hd, sb.block_bitmap_lba, buf, sb.block_bitmap_sects);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment"> * 3 将inode位图初始化并写入sb.inode_bitmap_lba *</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line">   <span class="comment">/* 先清空缓冲区*/</span></span><br><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0</span>, buf_size);</span><br><span class="line">   buf[<span class="number">0</span>] |= <span class="number">0x1</span>;      <span class="comment">// 第0个inode分给了根目录</span></span><br><span class="line">   <span class="comment">/* 由于inode_table中共4096个inode,位图inode_bitmap正好占用1扇区,</span></span><br><span class="line"><span class="comment">    * 即inode_bitmap_sects等于1, 所以位图中的位全都代表inode_table中的inode,</span></span><br><span class="line"><span class="comment">    * 无须再像block_bitmap那样单独处理最后一扇区的剩余部分,</span></span><br><span class="line"><span class="comment">    * inode_bitmap所在的扇区中没有多余的无效位 */</span></span><br><span class="line">   ide_write(hd, sb.inode_bitmap_lba, buf, sb.inode_bitmap_sects);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment"> * 4 将inode数组初始化并写入sb.inode_table_lba *</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"> <span class="comment">/* 准备写inode_table中的第0项,即根目录所在的inode */</span></span><br><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0</span>, buf_size);  <span class="comment">// 先清空缓冲区buf</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">i</span> = (<span class="title">struct</span> <span class="title">inode</span>*)<span class="title">buf</span>;</span> </span><br><span class="line">   i-&gt;i_size = sb.dir_entry_size * <span class="number">2</span>;	 <span class="comment">// .和..</span></span><br><span class="line">   i-&gt;i_no = <span class="number">0</span>;   <span class="comment">// 根目录占inode数组中第0个inode</span></span><br><span class="line">   i-&gt;i_sectors[<span class="number">0</span>] = sb.data_start_lba;	     <span class="comment">// 由于上面的memset,i_sectors数组的其它元素都初始化为0 </span></span><br><span class="line">   ide_write(hd, sb.inode_table_lba, buf, sb.inode_table_sects);</span><br><span class="line">   </span><br><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment"> * 5 将根目录初始化并写入sb.data_start_lba</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line">   <span class="comment">/* 写入根目录的两个目录项.和.. */</span></span><br><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0</span>, buf_size);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">p_de</span> = (<span class="title">struct</span> <span class="title">dir_entry</span>*)<span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化当前目录"." */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(p_de-&gt;filename, <span class="string">"."</span>, <span class="number">1</span>);</span><br><span class="line">   p_de-&gt;i_no = <span class="number">0</span>;</span><br><span class="line">   p_de-&gt;f_type = FT_DIRECTORY;</span><br><span class="line">   p_de++;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化当前目录父目录".." */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(p_de-&gt;filename, <span class="string">".."</span>, <span class="number">2</span>);</span><br><span class="line">   p_de-&gt;i_no = <span class="number">0</span>;   <span class="comment">// 根目录的父目录依然是根目录自己</span></span><br><span class="line">   p_de-&gt;f_type = FT_DIRECTORY;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* sb.data_start_lba已经分配给了根目录,里面是根目录的目录项 */</span></span><br><span class="line">   ide_write(hd, sb.data_start_lba, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   printk(<span class="string">"   root_dir_lba:0x%x\n"</span>, sb.data_start_lba);</span><br><span class="line">   printk(<span class="string">"%s format done\n"</span>, part-&gt;name);</span><br><span class="line">   sys_free(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建之后的示意图如下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/92.png" alt="image-20200612181835991"></p>
<p>接下来就是调用上面代码的初始化函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在磁盘上搜索文件系统,若没有则格式化分区创建文件系统 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">filesys_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint8_t</span> channel_no = <span class="number">0</span>, dev_no, part_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* sb_buf用来存储从硬盘上读入的超级块 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">sb_buf</span> = (<span class="title">struct</span> <span class="title">super_block</span>*)<span class="title">sys_malloc</span>(<span class="title">SECTOR_SIZE</span>);</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (sb_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      PANIC(<span class="string">"alloc memory failed!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   printk(<span class="string">"searching filesystem......\n"</span>);</span><br><span class="line">   <span class="keyword">while</span> (channel_no &lt; channel_cnt) &#123; <span class="comment">// 遍历通道</span></span><br><span class="line">      dev_no = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(dev_no &lt; <span class="number">2</span>) &#123; <span class="comment">// 遍历通道中的硬盘</span></span><br><span class="line">	 <span class="keyword">if</span> (dev_no == <span class="number">0</span>) &#123;   <span class="comment">// 跨过裸盘hd60M.img</span></span><br><span class="line">	    dev_no++;</span><br><span class="line">	    <span class="keyword">continue</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">disk</span>* <span class="title">hd</span> = &amp;<span class="title">channels</span>[<span class="title">channel_no</span>].<span class="title">devices</span>[<span class="title">dev_no</span>];</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">partition</span>* <span class="title">part</span> = <span class="title">hd</span>-&gt;<span class="title">prim_parts</span>;</span></span><br><span class="line">	 <span class="keyword">while</span>(part_idx &lt; <span class="number">12</span>) &#123;   <span class="comment">// 遍历分区，4个主分区+8个逻辑</span></span><br><span class="line">	    <span class="keyword">if</span> (part_idx == <span class="number">4</span>) &#123;  <span class="comment">// 开始处理逻辑分区</span></span><br><span class="line">	       part = hd-&gt;logic_parts;</span><br><span class="line">	    &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">/* channels数组是全局变量,默认值为0,disk属于其嵌套结构,</span></span><br><span class="line"><span class="comment">	  * partition又为disk的嵌套结构,因此partition中的成员默认也为0.</span></span><br><span class="line"><span class="comment">	  * 若partition未初始化,则partition中的成员仍为0. </span></span><br><span class="line"><span class="comment">	  * 下面处理存在的分区. */</span></span><br><span class="line">	    <span class="keyword">if</span> (part-&gt;sec_cnt != <span class="number">0</span>) &#123;  <span class="comment">// 如果分区存在</span></span><br><span class="line">	       <span class="built_in">memset</span>(sb_buf, <span class="number">0</span>, SECTOR_SIZE);</span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* 读出分区的超级块,根据魔数是否正确来判断是否存在文件系统 */</span></span><br><span class="line">	       ide_read(hd, part-&gt;start_lba + <span class="number">1</span>, sb_buf, <span class="number">1</span>);   </span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* 只支持自己的文件系统.若磁盘上已经有文件系统就不再格式化了 */</span></span><br><span class="line">	       <span class="keyword">if</span> (sb_buf-&gt;magic == <span class="number">0x19590318</span>) &#123;</span><br><span class="line">		  printk(<span class="string">"%s has filesystem\n"</span>, part-&gt;name);</span><br><span class="line">	       &#125; <span class="keyword">else</span> &#123;			  <span class="comment">// 其它文件系统不支持,一律按无文件系统处理</span></span><br><span class="line">		  printk(<span class="string">"formatting %s`s partition %s......\n"</span>, hd-&gt;name, part-&gt;name);</span><br><span class="line">		  partition_format(part);</span><br><span class="line">	       &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    part_idx++;</span><br><span class="line">	    part++;	<span class="comment">// 下一分区</span></span><br><span class="line">	 &#125;</span><br><span class="line">	 dev_no++;	<span class="comment">// 下一磁盘</span></span><br><span class="line">      &#125;</span><br><span class="line">      channel_no++;	<span class="comment">// 下一通道</span></span><br><span class="line">   &#125;</span><br><span class="line">   sys_free(sb_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要运行两次，第一次负责创建，第二次运行显示创建完毕</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/93.png" alt="image-20200612181835991"></p>
<h2 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h2><p>为了操作任意一个分区，实现对分区的”拿”和”收”，我们需要完成挂载分区，其实质是把该分区的文件系统的元信息从硬盘上读出来加载到内存中，这样硬盘资源的变化都用内存中元信息来跟踪</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partition</span>* <span class="title">cur_part</span>;</span>	 <span class="comment">// 默认情况下操作的是哪个分区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在分区链表中找到名为part_name的分区,并将其指针赋值给cur_part */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">mount_partition</span><span class="params">(struct list_elem* pelem, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span>* part_name = (<span class="keyword">char</span>*)arg;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">partition</span>* <span class="title">part</span> = <span class="title">elem2entry</span>(<span class="title">struct</span> <span class="title">partition</span>, <span class="title">part_tag</span>, <span class="title">pelem</span>);</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(part-&gt;name, part_name)) &#123;</span><br><span class="line">      cur_part = part;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">disk</span>* <span class="title">hd</span> = <span class="title">cur_part</span>-&gt;<span class="title">my_disk</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* sb_buf用来存储从硬盘上读入的超级块 */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">sb_buf</span> = (<span class="title">struct</span> <span class="title">super_block</span>*)<span class="title">sys_malloc</span>(<span class="title">SECTOR_SIZE</span>);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 在内存中创建分区cur_part的超级块 */</span></span><br><span class="line">      cur_part-&gt;sb = (struct super_block*)sys_malloc(<span class="keyword">sizeof</span>(struct super_block));</span><br><span class="line">      <span class="keyword">if</span> (cur_part-&gt;sb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	 PANIC(<span class="string">"alloc memory failed!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 读入超级块 */</span></span><br><span class="line">      <span class="built_in">memset</span>(sb_buf, <span class="number">0</span>, SECTOR_SIZE);</span><br><span class="line">      ide_read(hd, cur_part-&gt;start_lba + <span class="number">1</span>, sb_buf, <span class="number">1</span>);   </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 把sb_buf中超级块的信息复制到分区的超级块sb中。*/</span></span><br><span class="line">      <span class="built_in">memcpy</span>(cur_part-&gt;sb, sb_buf, <span class="keyword">sizeof</span>(struct super_block)); </span><br><span class="line"></span><br><span class="line">      <span class="comment">/**********     将硬盘上的块位图读入到内存    ****************/</span></span><br><span class="line">      cur_part-&gt;block_bitmap.bits = (<span class="keyword">uint8_t</span>*)sys_malloc(sb_buf-&gt;block_bitmap_sects * SECTOR_SIZE);</span><br><span class="line">      <span class="keyword">if</span> (cur_part-&gt;block_bitmap.bits == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	 PANIC(<span class="string">"alloc memory failed!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      cur_part-&gt;block_bitmap.btmp_bytes_len = sb_buf-&gt;block_bitmap_sects * SECTOR_SIZE;</span><br><span class="line">      <span class="comment">/* 从硬盘上读入块位图到分区的block_bitmap.bits */</span></span><br><span class="line">      ide_read(hd, sb_buf-&gt;block_bitmap_lba, cur_part-&gt;block_bitmap.bits, sb_buf-&gt;block_bitmap_sects);   </span><br><span class="line">      <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**********     将硬盘上的inode位图读入到内存    ************/</span></span><br><span class="line">      cur_part-&gt;inode_bitmap.bits = (<span class="keyword">uint8_t</span>*)sys_malloc(sb_buf-&gt;inode_bitmap_sects * SECTOR_SIZE);</span><br><span class="line">      <span class="keyword">if</span> (cur_part-&gt;inode_bitmap.bits == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	 PANIC(<span class="string">"alloc memory failed!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      cur_part-&gt;inode_bitmap.btmp_bytes_len = sb_buf-&gt;inode_bitmap_sects * SECTOR_SIZE;</span><br><span class="line">      <span class="comment">/* 从硬盘上读入inode位图到分区的inode_bitmap.bits */</span></span><br><span class="line">      ide_read(hd, sb_buf-&gt;inode_bitmap_lba, cur_part-&gt;inode_bitmap.bits, sb_buf-&gt;inode_bitmap_sects);   </span><br><span class="line">      <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">      list_init(&amp;cur_part-&gt;open_inodes);</span><br><span class="line">      printk(<span class="string">"mount %s done!\n"</span>, part-&gt;name);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 此处返回true是为了迎合主调函数list_traversal的实现,与函数本身功能无关。</span></span><br><span class="line"><span class="comment">      只有返回true时list_traversal才会停止遍历,减少了后面元素无意义的遍历.*/</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">// 使list_traversal继续遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>文件描述符是用户能够交互的对象，它与inode不同的是inode是操作系统为自己的文件系统准备的数据结构，仅供其内部使用，用户难以接触到。用户进程可以多次打开同一个文件，一个文件也可也被多个进程同时打开，每次打开文件的时候，我们就需要记录当时文件的状态，比如当时读取的位置，也叫文件偏移量、文件打开的标志信息，inode指针等，基本结构如下图所示</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/94.png" alt="image-20200612181835991"></p>
<p>熟悉Linux编程的朋友肯定知道open函数，其成功调用返回值就是文件描述符，通常情况下是一个int类型的数值0~2，它实际上作为进程pcb中文件描述符数组的下标索引，其指向一个文件结构，在结构中才能获取到文件信息，pcb不直接指向描述符的原因是每次打开文件的时候就需要记录一次，如果这样的话pcb就会变得很大而损失效率，所以采取索引的方式记录，关系图如下所示</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/95.png" alt="image-20200612181835991"></p>
<p>下面是具体定义，增加描述符数组在thread文件的task_struct结构中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FILES_OPEN_PER_PROC 8</span></span><br><span class="line"><span class="comment">/* 进程或线程的pcb,程序控制块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">[...]</span><br><span class="line"><span class="keyword">int32_t</span> fd_table[MAX_FILES_OPEN_PER_PROC];	<span class="comment">// 文件描述符数组</span></span><br><span class="line">[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件描述符的初始化如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化线程基本信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_thread</span><span class="params">(struct task_struct* pthread, <span class="keyword">char</span>* name, <span class="keyword">int</span> prio)</span> </span>&#123;</span><br><span class="line">   [...]</span><br><span class="line">   <span class="comment">/* 预留标准输入输出 */</span></span><br><span class="line">   pthread-&gt;fd_table[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   pthread-&gt;fd_table[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   pthread-&gt;fd_table[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">   <span class="comment">/* 其余的全置为-1 */</span></span><br><span class="line">   <span class="keyword">uint8_t</span> fd_idx = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">while</span> (fd_idx &lt; MAX_FILES_OPEN_PER_PROC) &#123;</span><br><span class="line">      pthread-&gt;fd_table[fd_idx] = <span class="number">-1</span>;</span><br><span class="line">      fd_idx++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   pthread-&gt;stack_magic = <span class="number">0x19870916</span>;	  <span class="comment">// 自定义的魔数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inode相关函数"><a href="#inode相关函数" class="headerlink" title="inode相关函数"></a>inode相关函数</h2><p>要想操作文件使其创建、打开、读写，首先得准备一些对inode相关操作的函数，存储inode信息的结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用来存储inode位置 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_position</span> &#123;</span></span><br><span class="line">   <span class="keyword">bool</span>	 two_sec;	<span class="comment">// inode是否跨扇区</span></span><br><span class="line">   <span class="keyword">uint32_t</span> sec_lba;	<span class="comment">// inode所在的扇区号</span></span><br><span class="line">   <span class="keyword">uint32_t</span> off_size;	<span class="comment">// inode在扇区内的字节偏移量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是获取inode所在扇区和扇区内的偏移函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取inode所在的扇区和扇区内的偏移量 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inode_locate</span><span class="params">(struct partition* part, <span class="keyword">uint32_t</span> inode_no, struct inode_position* inode_pos)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* inode_table在硬盘上是连续的 */</span></span><br><span class="line">   ASSERT(inode_no &lt; <span class="number">4096</span>);</span><br><span class="line">   <span class="keyword">uint32_t</span> inode_table_lba = part-&gt;sb-&gt;inode_table_lba;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> inode_size = <span class="keyword">sizeof</span>(struct inode);</span><br><span class="line">   <span class="keyword">uint32_t</span> off_size = inode_no * inode_size;	    <span class="comment">// 第inode_no号I结点相对于inode_table_lba的字节偏移量</span></span><br><span class="line">   <span class="keyword">uint32_t</span> off_sec  = off_size / <span class="number">512</span>;		    <span class="comment">// 第inode_no号I结点相对于inode_table_lba的扇区偏移量</span></span><br><span class="line">   <span class="keyword">uint32_t</span> off_size_in_sec = off_size % <span class="number">512</span>;	    <span class="comment">// 待查找的inode所在扇区中的起始地址</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 判断此i结点是否跨越2个扇区 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> left_in_sec = <span class="number">512</span> - off_size_in_sec;</span><br><span class="line">   <span class="keyword">if</span> (left_in_sec &lt; inode_size ) &#123;	  <span class="comment">// 若扇区内剩下的空间不足以容纳一个inode,必然是I结点跨越了2个扇区</span></span><br><span class="line">      inode_pos-&gt;two_sec = <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;				  <span class="comment">// 否则,所查找的inode未跨扇区</span></span><br><span class="line">      inode_pos-&gt;two_sec = <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   inode_pos-&gt;sec_lba = inode_table_lba + off_sec;</span><br><span class="line">   inode_pos-&gt;off_size = off_size_in_sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将inode写入到分区part</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将inode写入到分区part */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inode_sync</span><span class="params">(struct partition* part, struct inode* inode, <span class="keyword">void</span>* io_buf)</span> </span>&#123;	 <span class="comment">// io_buf是用于硬盘io的缓冲区</span></span><br><span class="line">   <span class="keyword">uint8_t</span> inode_no = inode-&gt;i_no;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode_position</span> <span class="title">inode_pos</span>;</span></span><br><span class="line">   inode_locate(part, inode_no, &amp;inode_pos);	       <span class="comment">// inode位置信息会存入inode_pos</span></span><br><span class="line">   ASSERT(inode_pos.sec_lba &lt;= (part-&gt;start_lba + part-&gt;sec_cnt));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 硬盘中的inode中的成员inode_tag和i_open_cnts是不需要的,</span></span><br><span class="line"><span class="comment">    * 它们只在内存中记录链表位置和被多少进程共享 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">pure_inode</span>;</span></span><br><span class="line">   <span class="built_in">memcpy</span>(&amp;pure_inode, inode, <span class="keyword">sizeof</span>(struct inode));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 以下inode的三个成员只存在于内存中,现在将inode同步到硬盘,清掉这三项即可 */</span></span><br><span class="line">   pure_inode.i_open_cnts = <span class="number">0</span>;</span><br><span class="line">   pure_inode.write_deny = <span class="literal">false</span>;	 <span class="comment">// 置为false,以保证在硬盘中读出时为可写</span></span><br><span class="line">   pure_inode.inode_tag.prev = pure_inode.inode_tag.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span>* inode_buf = (<span class="keyword">char</span>*)io_buf;</span><br><span class="line">   <span class="keyword">if</span> (inode_pos.two_sec) &#123;	    <span class="comment">// 若是跨了两个扇区,就要读出两个扇区再写入两个扇区</span></span><br><span class="line">   <span class="comment">/* 读写硬盘是以扇区为单位,若写入的数据小于一扇区,要将原硬盘上的内容先读出来再和新数据拼成一扇区后再写入  */</span></span><br><span class="line">      ide_read(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">2</span>);	<span class="comment">// inode在format中写入硬盘时是连续写入的,所以读入2块扇区</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 开始将待写入的inode拼入到这2个扇区中的相应位置 */</span></span><br><span class="line">      <span class="built_in">memcpy</span>((inode_buf + inode_pos.off_size), &amp;pure_inode, <span class="keyword">sizeof</span>(struct inode));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 将拼接好的数据再写入磁盘 */</span></span><br><span class="line">      ide_write(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">2</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;			    <span class="comment">// 若只是一个扇区</span></span><br><span class="line">      ide_read(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">memcpy</span>((inode_buf + inode_pos.off_size), &amp;pure_inode, <span class="keyword">sizeof</span>(struct inode));</span><br><span class="line">      ide_write(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开和关闭节点的操作函数，其中part-&gt;open_inodes的存在是为了提高效率，减少直接访问磁盘的频率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 根据i结点号返回相应的i结点 */</span></span><br><span class="line"><span class="function">struct inode* <span class="title">inode_open</span><span class="params">(struct partition* part, <span class="keyword">uint32_t</span> inode_no)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 先在已打开inode链表中找inode,此链表是为提速创建的缓冲区 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> = <span class="title">part</span>-&gt;<span class="title">open_inodes</span>.<span class="title">head</span>.<span class="title">next</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode_found</span>;</span></span><br><span class="line">   <span class="keyword">while</span> (elem != &amp;part-&gt;open_inodes.tail) &#123;</span><br><span class="line">      inode_found = elem2entry(struct inode, inode_tag, elem);</span><br><span class="line">      <span class="keyword">if</span> (inode_found-&gt;i_no == inode_no) &#123;</span><br><span class="line">	 inode_found-&gt;i_open_cnts++;</span><br><span class="line">	 <span class="keyword">return</span> inode_found;</span><br><span class="line">      &#125;</span><br><span class="line">      elem = elem-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*由于open_inodes链表中找不到,下面从硬盘上读入此inode并加入到此链表 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode_position</span> <span class="title">inode_pos</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* inode位置信息会存入inode_pos, 包括inode所在扇区地址和扇区内的字节偏移量 */</span></span><br><span class="line">   inode_locate(part, inode_no, &amp;inode_pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为使通过sys_malloc创建的新inode被所有任务共享,</span></span><br><span class="line"><span class="comment"> * 需要将inode置于内核空间,故需要临时</span></span><br><span class="line"><span class="comment"> * 将cur_pbc-&gt;pgdir置为NULL */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* cur_pagedir_bak = cur-&gt;pgdir;</span><br><span class="line">   cur-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="comment">/* 以上三行代码完成后下面分配的内存将位于内核区 */</span></span><br><span class="line">   inode_found = (struct inode*)sys_malloc(<span class="keyword">sizeof</span>(struct inode));</span><br><span class="line">   <span class="comment">/* 恢复pgdir */</span></span><br><span class="line">   cur-&gt;pgdir = cur_pagedir_bak;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span>* inode_buf;</span><br><span class="line">   <span class="keyword">if</span> (inode_pos.two_sec) &#123;	<span class="comment">// 考虑跨扇区的情况</span></span><br><span class="line">      inode_buf = (<span class="keyword">char</span>*)sys_malloc(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* i结点表是被partition_format函数连续写入扇区的,</span></span><br><span class="line"><span class="comment">    * 所以下面可以连续读出来 */</span></span><br><span class="line">      ide_read(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">2</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 否则,所查找的inode未跨扇区,一个扇区大小的缓冲区足够</span></span><br><span class="line">      inode_buf = (<span class="keyword">char</span>*)sys_malloc(<span class="number">512</span>);</span><br><span class="line">      ide_read(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">memcpy</span>(inode_found, inode_buf + inode_pos.off_size, <span class="keyword">sizeof</span>(struct inode));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 因为一会很可能要用到此inode,故将其插入到队首便于提前检索到 */</span></span><br><span class="line">   list_push(&amp;part-&gt;open_inodes, &amp;inode_found-&gt;inode_tag);</span><br><span class="line">   inode_found-&gt;i_open_cnts = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   sys_free(inode_buf);</span><br><span class="line">   <span class="keyword">return</span> inode_found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭inode或减少inode的打开数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inode_close</span><span class="params">(struct inode* inode)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 若没有进程再打开此文件,将此inode去掉并释放空间 */</span></span><br><span class="line">   <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">   <span class="keyword">if</span> (--inode-&gt;i_open_cnts == <span class="number">0</span>) &#123;</span><br><span class="line">      list_remove(&amp;inode-&gt;inode_tag);	  <span class="comment">// 将I结点从part-&gt;open_inodes中去掉</span></span><br><span class="line">   <span class="comment">/* inode_open时为实现inode被所有进程共享,</span></span><br><span class="line"><span class="comment">    * 已经在sys_malloc为inode分配了内核空间,</span></span><br><span class="line"><span class="comment">    * 释放inode时也要确保释放的是内核内存池 */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">      <span class="keyword">uint32_t</span>* cur_pagedir_bak = cur-&gt;pgdir;</span><br><span class="line">      cur-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line">      sys_free(inode);</span><br><span class="line">      cur-&gt;pgdir = cur_pagedir_bak;</span><br><span class="line">   &#125;</span><br><span class="line">   intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化inode函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化new_inode */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inode_init</span><span class="params">(<span class="keyword">uint32_t</span> inode_no, struct inode* new_inode)</span> </span>&#123;</span><br><span class="line">   new_inode-&gt;i_no = inode_no;</span><br><span class="line">   new_inode-&gt;i_size = <span class="number">0</span>;</span><br><span class="line">   new_inode-&gt;i_open_cnts = <span class="number">0</span>;</span><br><span class="line">   new_inode-&gt;write_deny = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化块索引数组i_sector */</span></span><br><span class="line">   <span class="keyword">uint8_t</span> sec_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (sec_idx &lt; <span class="number">13</span>) &#123;</span><br><span class="line">   <span class="comment">/* i_sectors[12]为一级间接块地址 */</span></span><br><span class="line">      new_inode-&gt;i_sectors[sec_idx] = <span class="number">0</span>;</span><br><span class="line">      sec_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件相关函数"><a href="#文件相关函数" class="headerlink" title="文件相关函数"></a>文件相关函数</h2><p>文件的一些基本结构定义如下，在fs目录下的file文件中实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> fd_pos;      <span class="comment">// 记录当前文件操作的偏移地址,以0为起始,最大为文件大小-1</span></span><br><span class="line">   <span class="keyword">uint32_t</span> fd_flag;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">fd_inode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标准输入输出描述符 */</span></span><br><span class="line"><span class="keyword">enum</span> std_fd &#123;</span><br><span class="line">   stdin_no,   <span class="comment">// 0 标准输入</span></span><br><span class="line">   stdout_no,  <span class="comment">// 1 标准输出</span></span><br><span class="line">   stderr_no   <span class="comment">// 2 标准错误</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 位图类型 */</span></span><br><span class="line"><span class="keyword">enum</span> bitmap_type &#123;</span><br><span class="line">   INODE_BITMAP,     <span class="comment">// inode位图</span></span><br><span class="line">   BLOCK_BITMAP	     <span class="comment">// 块位图</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是一些文件操作函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件表 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file_table</span>[<span class="title">MAX_FILE_OPEN</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从文件表file_table中获取一个空闲位,成功返回下标,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> get_free_slot_in_global(<span class="keyword">void</span>) &#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> fd_idx = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">while</span> (fd_idx &lt; MAX_FILE_OPEN) &#123;</span><br><span class="line">      <span class="keyword">if</span> (file_table[fd_idx].fd_inode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	 <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fd_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (fd_idx == MAX_FILE_OPEN) &#123;</span><br><span class="line">      printk(<span class="string">"exceed max open files\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fd_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将全局描述符下标安装到进程或线程自己的文件描述符数组fd_table中,</span></span><br><span class="line"><span class="comment"> * 成功返回下标,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> pcb_fd_install(<span class="keyword">int32_t</span> globa_fd_idx) &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">   <span class="keyword">uint8_t</span> local_fd_idx = <span class="number">3</span>; <span class="comment">// 跨过stdin,stdout,stderr</span></span><br><span class="line">   <span class="keyword">while</span> (local_fd_idx &lt; MAX_FILES_OPEN_PER_PROC) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cur-&gt;fd_table[local_fd_idx] == <span class="number">-1</span>) &#123;	<span class="comment">// -1表示free_slot,可用</span></span><br><span class="line">	 cur-&gt;fd_table[local_fd_idx] = globa_fd_idx;</span><br><span class="line">	 <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      local_fd_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (local_fd_idx == MAX_FILES_OPEN_PER_PROC) &#123;</span><br><span class="line">      printk(<span class="string">"exceed max open files_per_proc\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> local_fd_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配一个i结点,返回i结点号 */</span></span><br><span class="line"><span class="keyword">int32_t</span> inode_bitmap_alloc(struct partition* part) &#123;</span><br><span class="line">   <span class="keyword">int32_t</span> bit_idx = bitmap_scan(&amp;part-&gt;inode_bitmap, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (bit_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   bitmap_set(&amp;part-&gt;inode_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> bit_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="目录相关函数"><a href="#目录相关函数" class="headerlink" title="目录相关函数"></a>目录相关函数</h2><p>下面是一些目录操作的基本函数，下面几个函数功能主要是打开和索引</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir</span> <span class="title">root_dir</span>;</span>             <span class="comment">// 根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开根目录 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_root_dir</span><span class="params">(struct partition* part)</span> </span>&#123;</span><br><span class="line">   root_dir.inode = inode_open(part, part-&gt;sb-&gt;root_inode_no);</span><br><span class="line">   root_dir.dir_pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在分区part上打开i结点为inode_no的目录并返回目录指针 */</span></span><br><span class="line"><span class="function">struct dir* <span class="title">dir_open</span><span class="params">(struct partition* part, <span class="keyword">uint32_t</span> inode_no)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">pdir</span> = (<span class="title">struct</span> <span class="title">dir</span>*)<span class="title">sys_malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">dir</span>));</span></span><br><span class="line">   pdir-&gt;inode = inode_open(part, inode_no);</span><br><span class="line">   pdir-&gt;dir_pos = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> pdir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在part分区内的pdir目录内寻找名为name的文件或目录,</span></span><br><span class="line"><span class="comment"> * 找到后返回true并将其目录项存入dir_e,否则返回false */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search_dir_entry</span><span class="params">(struct partition* part, struct dir* pdir, \</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="keyword">const</span> <span class="keyword">char</span>* name, struct dir_entry* dir_e)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> block_cnt = <span class="number">140</span>;	 <span class="comment">// 12个直接块+128个一级间接块=140块</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 12个直接块大小+128个间接块,共560字节 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* all_blocks = (<span class="keyword">uint32_t</span>*)sys_malloc(<span class="number">48</span> + <span class="number">512</span>);</span><br><span class="line">   <span class="keyword">if</span> (all_blocks == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"search_dir_entry: sys_malloc for all_blocks failed"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> block_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">12</span>) &#123;</span><br><span class="line">      all_blocks[block_idx] = pdir-&gt;inode-&gt;i_sectors[block_idx];</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   block_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pdir-&gt;inode-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>) &#123;	<span class="comment">// 若含有一级间接块表</span></span><br><span class="line">      ide_read(part-&gt;my_disk, pdir-&gt;inode-&gt;i_sectors[<span class="number">12</span>], all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/* 至此,all_blocks存储的是该文件或目录的所有扇区地址 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 写目录项的时候已保证目录项不跨扇区,</span></span><br><span class="line"><span class="comment">    * 这样读目录项时容易处理, 只申请容纳1个扇区的内存 */</span></span><br><span class="line">   <span class="keyword">uint8_t</span>* buf = (<span class="keyword">uint8_t</span>*)sys_malloc(SECTOR_SIZE);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">p_de</span> = (<span class="title">struct</span> <span class="title">dir_entry</span>*)<span class="title">buf</span>;</span>	    <span class="comment">// p_de为指向目录项的指针,值为buf起始地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entry_size = part-&gt;sb-&gt;dir_entry_size;</span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entry_cnt = SECTOR_SIZE / dir_entry_size;   <span class="comment">// 1扇区内可容纳的目录项个数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 开始在所有块中查找目录项 */</span></span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; block_cnt) &#123;		  </span><br><span class="line">   <span class="comment">/* 块地址为0时表示该块中无数据,继续在其它块中找 */</span></span><br><span class="line">      <span class="keyword">if</span> (all_blocks[block_idx] == <span class="number">0</span>) &#123;</span><br><span class="line">	 block_idx++;</span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ide_read(part-&gt;my_disk, all_blocks[block_idx], buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">uint32_t</span> dir_entry_idx = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/* 遍历扇区中所有目录项 */</span></span><br><span class="line">      <span class="keyword">while</span> (dir_entry_idx &lt; dir_entry_cnt) &#123;</span><br><span class="line">	 <span class="comment">/* 若找到了,就直接复制整个目录项 */</span></span><br><span class="line">	 <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(p_de-&gt;filename, name)) &#123;</span><br><span class="line">	    <span class="built_in">memcpy</span>(dir_e, p_de, dir_entry_size);</span><br><span class="line">	    sys_free(buf);</span><br><span class="line">	    sys_free(all_blocks);</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 dir_entry_idx++;</span><br><span class="line">	 p_de++;</span><br><span class="line">      &#125;</span><br><span class="line">      block_idx++;</span><br><span class="line">      p_de = (struct dir_entry*)buf;  <span class="comment">// 此时p_de已经指向扇区内最后一个完整目录项了,需要恢复p_de指向为buf</span></span><br><span class="line">      <span class="built_in">memset</span>(buf, <span class="number">0</span>, SECTOR_SIZE);	  <span class="comment">// 将buf清0,下次再用</span></span><br><span class="line">   &#125;</span><br><span class="line">   sys_free(buf);</span><br><span class="line">   sys_free(all_blocks);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的两个函数负责关闭目录和初始化目录项，需要注意的是根目录不能关闭</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 关闭目录 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dir_close</span><span class="params">(struct dir* dir)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*************      根目录不能关闭     ***************</span></span><br><span class="line"><span class="comment"> *1 根目录自打开后就不应该关闭,否则还需要再次open_root_dir();</span></span><br><span class="line"><span class="comment"> *2 root_dir所在的内存是低端1M之内,并非在堆中,free会出问题 */</span></span><br><span class="line">   <span class="keyword">if</span> (dir == &amp;root_dir) &#123;</span><br><span class="line">   <span class="comment">/* 不做任何处理直接返回*/</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   inode_close(dir-&gt;inode);</span><br><span class="line">   sys_free(dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在内存中初始化目录项p_de */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_dir_entry</span><span class="params">(<span class="keyword">char</span>* filename, <span class="keyword">uint32_t</span> inode_no, <span class="keyword">uint8_t</span> file_type, struct dir_entry* p_de)</span> </span>&#123;</span><br><span class="line">   ASSERT(<span class="built_in">strlen</span>(filename) &lt;=  MAX_FILE_NAME_LEN);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化目录项 */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(p_de-&gt;filename, filename, <span class="built_in">strlen</span>(filename));</span><br><span class="line">   p_de-&gt;i_no = inode_no;</span><br><span class="line">   p_de-&gt;f_type = file_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后这个函数负责将目录项p_de写入父目录parent_dir中，io_buf由主调函数提供</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将目录项p_de写入父目录parent_dir中,io_buf由主调函数提供 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sync_dir_entry</span><span class="params">(struct dir* parent_dir, struct dir_entry* p_de, <span class="keyword">void</span>* io_buf)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">dir_inode</span> = <span class="title">parent_dir</span>-&gt;<span class="title">inode</span>;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> dir_size = dir_inode-&gt;i_size;</span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entry_size = cur_part-&gt;sb-&gt;dir_entry_size;</span><br><span class="line"></span><br><span class="line">   ASSERT(dir_size % dir_entry_size == <span class="number">0</span>);	 <span class="comment">// dir_size应该是dir_entry_size的整数倍</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entrys_per_sec = (<span class="number">512</span> / dir_entry_size);       <span class="comment">// 每扇区最大的目录项数目</span></span><br><span class="line">   <span class="keyword">int32_t</span> block_lba = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 将该目录的所有扇区地址(12个直接块+ 128个间接块)存入all_blocks */</span></span><br><span class="line">   <span class="keyword">uint8_t</span> block_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> all_blocks[<span class="number">140</span>] = &#123;<span class="number">0</span>&#125;;	  <span class="comment">// all_blocks保存目录所有的块</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 将12个直接块存入all_blocks */</span></span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">12</span>) &#123;</span><br><span class="line">      all_blocks[block_idx] = dir_inode-&gt;i_sectors[block_idx];</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">dir_e</span> = (<span class="title">struct</span> <span class="title">dir_entry</span>*)<span class="title">io_buf</span>;</span>	       <span class="comment">// dir_e用来在io_buf中遍历目录项</span></span><br><span class="line">   <span class="keyword">int32_t</span> block_bitmap_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 开始遍历所有块以寻找目录项空位,若已有扇区中没有空闲位,</span></span><br><span class="line"><span class="comment">    * 在不超过文件大小的情况下申请新扇区来存储新目录项 */</span></span><br><span class="line">   block_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">140</span>) &#123;  <span class="comment">// 文件(包括目录)最大支持12个直接块+128个间接块＝140个块</span></span><br><span class="line">      block_bitmap_idx = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span> (all_blocks[block_idx] == <span class="number">0</span>) &#123;   <span class="comment">// 在三种情况下分配块</span></span><br><span class="line">	 block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">	 <span class="keyword">if</span> (block_lba == <span class="number">-1</span>) &#123;</span><br><span class="line">	    printk(<span class="string">"alloc block bitmap for sync_dir_entry failed\n"</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 每分配一个块就同步一次block_bitmap */</span></span><br><span class="line">	 block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	 ASSERT(block_bitmap_idx != <span class="number">-1</span>);</span><br><span class="line">	 bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line"></span><br><span class="line">	 block_bitmap_idx = <span class="number">-1</span>;</span><br><span class="line">	 <span class="keyword">if</span> (block_idx &lt; <span class="number">12</span>) &#123;	    <span class="comment">// 若是直接块</span></span><br><span class="line">	    dir_inode-&gt;i_sectors[block_idx] = all_blocks[block_idx] = block_lba;</span><br><span class="line">	 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (block_idx == <span class="number">12</span>) &#123;	  <span class="comment">// 若是尚未分配一级间接块表(block_idx等于12表示第0个间接块地址为0)</span></span><br><span class="line">	    dir_inode-&gt;i_sectors[<span class="number">12</span>] = block_lba;       <span class="comment">// 将上面分配的块做为一级间接块表地址</span></span><br><span class="line">	    block_lba = <span class="number">-1</span>;</span><br><span class="line">	    block_lba = block_bitmap_alloc(cur_part);	       <span class="comment">// 再分配一个块做为第0个间接块</span></span><br><span class="line">	    <span class="keyword">if</span> (block_lba == <span class="number">-1</span>) &#123;</span><br><span class="line">	       block_bitmap_idx = dir_inode-&gt;i_sectors[<span class="number">12</span>] - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	       bitmap_set(&amp;cur_part-&gt;block_bitmap, block_bitmap_idx, <span class="number">0</span>);</span><br><span class="line">	       dir_inode-&gt;i_sectors[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">	       printk(<span class="string">"alloc block bitmap for sync_dir_entry failed\n"</span>);</span><br><span class="line">	       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 每分配一个块就同步一次block_bitmap */</span></span><br><span class="line">	    block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	    ASSERT(block_bitmap_idx != <span class="number">-1</span>);</span><br><span class="line">	    bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line"></span><br><span class="line">	    all_blocks[<span class="number">12</span>] = block_lba;</span><br><span class="line">	    <span class="comment">/* 把新分配的第0个间接块地址写入一级间接块表 */</span></span><br><span class="line">	    ide_write(cur_part-&gt;my_disk, dir_inode-&gt;i_sectors[<span class="number">12</span>], all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;	   <span class="comment">// 若是间接块未分配</span></span><br><span class="line">	    all_blocks[block_idx] = block_lba;</span><br><span class="line">	    <span class="comment">/* 把新分配的第(block_idx-12)个间接块地址写入一级间接块表 */</span></span><br><span class="line">	    ide_write(cur_part-&gt;my_disk, dir_inode-&gt;i_sectors[<span class="number">12</span>], all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 再将新目录项p_de写入新分配的间接块 */</span></span><br><span class="line">	 <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, <span class="number">512</span>);</span><br><span class="line">	 <span class="built_in">memcpy</span>(io_buf, p_de, dir_entry_size);</span><br><span class="line">	 ide_write(cur_part-&gt;my_disk, all_blocks[block_idx], io_buf, <span class="number">1</span>);</span><br><span class="line">	 dir_inode-&gt;i_size += dir_entry_size;</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 若第block_idx块已存在,将其读进内存,然后在该块中查找空目录项 */</span></span><br><span class="line">      ide_read(cur_part-&gt;my_disk, all_blocks[block_idx], io_buf, <span class="number">1</span>); </span><br><span class="line">      <span class="comment">/* 在扇区内查找空目录项 */</span></span><br><span class="line">      <span class="keyword">uint8_t</span> dir_entry_idx = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (dir_entry_idx &lt; dir_entrys_per_sec) &#123;</span><br><span class="line">	 <span class="keyword">if</span> ((dir_e + dir_entry_idx)-&gt;f_type == FT_UNKNOWN) &#123;	<span class="comment">// FT_UNKNOWN为0,无论是初始化或是删除文件后,都会将f_type置为FT_UNKNOWN.</span></span><br><span class="line">	    <span class="built_in">memcpy</span>(dir_e + dir_entry_idx, p_de, dir_entry_size);    </span><br><span class="line">	    ide_write(cur_part-&gt;my_disk, all_blocks[block_idx], io_buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	    dir_inode-&gt;i_size += dir_entry_size;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 dir_entry_idx++;</span><br><span class="line">      &#125;</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;   </span><br><span class="line">   printk(<span class="string">"directory is full!\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径解析相关函数"><a href="#路径解析相关函数" class="headerlink" title="路径解析相关函数"></a>路径解析相关函数</h2><p>路及解析就是把路径按照路径分隔符拆分成多层文件名，逐层在磁盘上查找以确认文件名是否存在，如<code>/a/b/c</code>拆分为<code>a</code>，<code>b</code>，<code>c</code>。下面的代码比较好理解，就不多解释了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将最上层路径名称解析出来 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">path_parse</span><span class="params">(<span class="keyword">char</span>* pathname, <span class="keyword">char</span>* name_store)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (pathname[<span class="number">0</span>] == <span class="string">'/'</span>) &#123;   <span class="comment">// 根目录不需要单独解析</span></span><br><span class="line">    <span class="comment">/* 路径中出现1个或多个连续的字符'/',将这些'/'跳过,如"///a/b" */</span></span><br><span class="line">       <span class="keyword">while</span>(*(++pathname) == <span class="string">'/'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 开始一般的路径解析 */</span></span><br><span class="line">   <span class="keyword">while</span> (*pathname != <span class="string">'/'</span> &amp;&amp; *pathname != <span class="number">0</span>) &#123;</span><br><span class="line">      *name_store++ = *pathname++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pathname[<span class="number">0</span>] == <span class="number">0</span>) &#123;   <span class="comment">// 若路径字符串为空则返回NULL</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> pathname; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回路径深度,比如/a/b/c,深度为3 */</span></span><br><span class="line"><span class="keyword">int32_t</span> path_depth_cnt(<span class="keyword">char</span>* pathname) &#123;</span><br><span class="line">   ASSERT(pathname != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">char</span>* p = pathname;</span><br><span class="line">   <span class="keyword">char</span> name[MAX_FILE_NAME_LEN];       <span class="comment">// 用于path_parse的参数做路径解析</span></span><br><span class="line">   <span class="keyword">uint32_t</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 解析路径,从中拆分出各级名称 */</span> </span><br><span class="line">   p = path_parse(p, name);</span><br><span class="line">   <span class="keyword">while</span> (name[<span class="number">0</span>]) &#123;</span><br><span class="line">      depth++;</span><br><span class="line">      <span class="built_in">memset</span>(name, <span class="number">0</span>, MAX_FILE_NAME_LEN);</span><br><span class="line">      <span class="keyword">if</span> (p) &#123;	     <span class="comment">// 如果p不等于NULL,继续分析路径</span></span><br><span class="line">	p  = path_parse(p, name);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现文件检索功能"><a href="#实现文件检索功能" class="headerlink" title="实现文件检索功能"></a>实现文件检索功能</h2><p>文件检索主要负责判断文件是否存在，判断文件同名的这种情况，下面是fs中更新的一些结构体，path_search_record负责查找文件过程中已经处理过的上级路径，比如查找<code>/a/b/c</code>若找不到的话就需要知道是c不存在还是上级目录a和b不存在，若c不存在searched_path值就为<code>/a/b/c</code>，若b不存在searched_path的值就为<code>/a/b</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PATH_LEN 512	    <span class="comment">// 路径最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件类型 */</span></span><br><span class="line"><span class="keyword">enum</span> file_types &#123;</span><br><span class="line">   FT_UNKNOWN,	  <span class="comment">// 不支持的文件类型</span></span><br><span class="line">   FT_REGULAR,	  <span class="comment">// 普通文件</span></span><br><span class="line">   FT_DIRECTORY	  <span class="comment">// 目录</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开文件的选项 */</span></span><br><span class="line"><span class="keyword">enum</span> oflags &#123;</span><br><span class="line">   O_RDONLY,	  <span class="comment">// 只读</span></span><br><span class="line">   O_WRONLY,	  <span class="comment">// 只写</span></span><br><span class="line">   O_RDWR,	  <span class="comment">// 读写</span></span><br><span class="line">   O_CREAT = <span class="number">4</span>	  <span class="comment">// 创建</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用来记录查找文件过程中已找到的上级路径,也就是查找文件过程中"走过的地方" */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path_search_record</span> &#123;</span></span><br><span class="line">   <span class="keyword">char</span> searched_path[MAX_PATH_LEN];	    <span class="comment">// 查找过程中的父路径</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">parent_dir</span>;</span>		    <span class="comment">// 文件或目录所在的直接父目录</span></span><br><span class="line">   <span class="keyword">enum</span> file_types file_type;		    <span class="comment">// 找到的是普通文件还是目录,找不到将为未知类型(FT_UNKNOWN)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是具体实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 搜索文件pathname,若找到则返回其inode号,否则返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, struct path_search_record* searched_record)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 如果待查找的是根目录,为避免下面无用的查找,直接返回已知根目录信息 */</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pathname, <span class="string">"/"</span>) || !<span class="built_in">strcmp</span>(pathname, <span class="string">"/."</span>) || !<span class="built_in">strcmp</span>(pathname, <span class="string">"/.."</span>)) &#123;</span><br><span class="line">      searched_record-&gt;parent_dir = &amp;root_dir;</span><br><span class="line">      searched_record-&gt;file_type = FT_DIRECTORY;</span><br><span class="line">      searched_record-&gt;searched_path[<span class="number">0</span>] = <span class="number">0</span>;	   <span class="comment">// 搜索路径置空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> path_len = <span class="built_in">strlen</span>(pathname);</span><br><span class="line">   <span class="comment">/* 保证pathname至少是这样的路径/x且小于最大长度 */</span></span><br><span class="line">   ASSERT(pathname[<span class="number">0</span>] == <span class="string">'/'</span> &amp;&amp; path_len &gt; <span class="number">1</span> &amp;&amp; path_len &lt; MAX_PATH_LEN);</span><br><span class="line">   <span class="keyword">char</span>* sub_path = (<span class="keyword">char</span>*)pathname;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">parent_dir</span> = &amp;<span class="title">root_dir</span>;</span>	</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> <span class="title">dir_e</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 记录路径解析出来的各级名称,如路径"/a/b/c",</span></span><br><span class="line"><span class="comment">    * 数组name每次的值分别是"a","b","c" */</span></span><br><span class="line">   <span class="keyword">char</span> name[MAX_FILE_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">   searched_record-&gt;parent_dir = parent_dir;</span><br><span class="line">   searched_record-&gt;file_type = FT_UNKNOWN;</span><br><span class="line">   <span class="keyword">uint32_t</span> parent_inode_no = <span class="number">0</span>;  <span class="comment">// 父目录的inode号</span></span><br><span class="line">   </span><br><span class="line">   sub_path = path_parse(sub_path, name); <span class="comment">// 开始路径解析</span></span><br><span class="line">   <span class="keyword">while</span> (name[<span class="number">0</span>]) &#123;	   <span class="comment">// 若第一个字符就是结束符,结束循环</span></span><br><span class="line">      <span class="comment">/* 记录查找过的路径,但不能超过searched_path的长度512字节 */</span></span><br><span class="line">      ASSERT(<span class="built_in">strlen</span>(searched_record-&gt;searched_path) &lt; <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 记录已存在的父目录 */</span></span><br><span class="line">      <span class="built_in">strcat</span>(searched_record-&gt;searched_path, <span class="string">"/"</span>);</span><br><span class="line">      <span class="built_in">strcat</span>(searched_record-&gt;searched_path, name);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 在所给的目录中查找文件 */</span></span><br><span class="line">      <span class="keyword">if</span> (search_dir_entry(cur_part, parent_dir, name, &amp;dir_e)) &#123;</span><br><span class="line">	 <span class="built_in">memset</span>(name, <span class="number">0</span>, MAX_FILE_NAME_LEN);</span><br><span class="line">	 <span class="comment">/* 若sub_path不等于NULL,也就是未结束时继续拆分路径 */</span></span><br><span class="line">	 <span class="keyword">if</span> (sub_path) &#123;</span><br><span class="line">	    sub_path = path_parse(sub_path, name);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">if</span> (FT_DIRECTORY == dir_e.f_type) &#123;   <span class="comment">// 如果被打开的是目录</span></span><br><span class="line">	    parent_inode_no = parent_dir-&gt;inode-&gt;i_no;</span><br><span class="line">	    dir_close(parent_dir);</span><br><span class="line">	    parent_dir = dir_open(cur_part, dir_e.i_no); <span class="comment">// 更新父目录</span></span><br><span class="line">	    searched_record-&gt;parent_dir = parent_dir;</span><br><span class="line">	    <span class="keyword">continue</span>;</span><br><span class="line">	 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FT_REGULAR == dir_e.f_type) &#123;	 <span class="comment">// 若是普通文件</span></span><br><span class="line">	    searched_record-&gt;file_type = FT_REGULAR;</span><br><span class="line">	    <span class="keyword">return</span> dir_e.i_no;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;		   <span class="comment">//若找不到,则返回-1</span></span><br><span class="line">	 <span class="comment">/* 找不到目录项时,要留着parent_dir不要关闭,</span></span><br><span class="line"><span class="comment">	  * 若是创建新文件的话需要在parent_dir中创建 */</span></span><br><span class="line">	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 执行到此,必然是遍历了完整路径并且查找的文件或目录只有同名目录存在 */</span></span><br><span class="line">   dir_close(searched_record-&gt;parent_dir);	      </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 保存被查找目录的直接父目录 */</span></span><br><span class="line">   searched_record-&gt;parent_dir = dir_open(cur_part, parent_inode_no);	   </span><br><span class="line">   searched_record-&gt;file_type = FT_DIRECTORY;</span><br><span class="line">   <span class="keyword">return</span> dir_e.i_no;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>首先我们需要实现file_create函数，在实现之前先梳理创建文件的过程：</p>
<ol>
<li>inode负责描述文件的属性，所以首先为文件创建inode，该过程需要向inode的管理单元inode_bitmap申请inode号，并更新inode_bitmap</li>
<li>确定文件存储的扇区地址，这个需要在block_bitmap中申请可用的块，并更新block_bitmap</li>
<li>新增的文件必然位于某个目录中，所以该目录的目录项数量要加1，并且要将新增的目录项写入目录对应的扇区中，如果原有的扇区已满，需要申请新扇区来存储目录项</li>
<li>若其中某步失败则回滚之前成功的操作</li>
<li>将上面过程中被改变的数据写入硬盘中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建文件,若成功则返回文件描述符,否则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> file_create(struct dir* parent_dir, <span class="keyword">char</span>* filename, <span class="keyword">uint8_t</span> flag) &#123;</span><br><span class="line">   <span class="comment">/* 后续操作的公共缓冲区 */</span></span><br><span class="line">   <span class="keyword">void</span>* io_buf = sys_malloc(<span class="number">1024</span>);</span><br><span class="line">   <span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"in file_creat: sys_malloc for io_buf failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint8_t</span> rollback_step = <span class="number">0</span>;	       <span class="comment">// 用于操作失败时回滚各资源状态</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 为新文件分配inode */</span></span><br><span class="line">   <span class="keyword">int32_t</span> inode_no = inode_bitmap_alloc(cur_part); </span><br><span class="line">   <span class="keyword">if</span> (inode_no == <span class="number">-1</span>) &#123;</span><br><span class="line">      printk(<span class="string">"in file_creat: allocate inode failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此inode要从堆中申请内存,不可生成局部变量(函数退出时会释放)</span></span><br><span class="line"><span class="comment"> * 因为file_table数组中的文件描述符的inode指针要指向它.*/</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">new_file_inode</span> = (<span class="title">struct</span> <span class="title">inode</span>*)<span class="title">sys_malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">inode</span>));</span> </span><br><span class="line">   <span class="keyword">if</span> (new_file_inode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"file_create: sys_malloc for inode failded\n"</span>);</span><br><span class="line">      rollback_step = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> rollback;</span><br><span class="line">   &#125;</span><br><span class="line">   inode_init(inode_no, new_file_inode);	    <span class="comment">// 初始化i结点</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 返回的是file_table数组的下标 */</span></span><br><span class="line">   <span class="keyword">int</span> fd_idx = get_free_slot_in_global();</span><br><span class="line">   <span class="keyword">if</span> (fd_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">      printk(<span class="string">"exceed max open files\n"</span>);</span><br><span class="line">      rollback_step = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">goto</span> rollback;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   file_table[fd_idx].fd_inode = new_file_inode;</span><br><span class="line">   file_table[fd_idx].fd_pos = <span class="number">0</span>;</span><br><span class="line">   file_table[fd_idx].fd_flag = flag;</span><br><span class="line">   file_table[fd_idx].fd_inode-&gt;write_deny = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> <span class="title">new_dir_entry</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;new_dir_entry, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct dir_entry));</span><br><span class="line"></span><br><span class="line">   create_dir_entry(filename, inode_no, FT_REGULAR, &amp;new_dir_entry);	<span class="comment">// create_dir_entry只是内存操作不出意外,不会返回失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同步内存数据到硬盘 */</span></span><br><span class="line">   <span class="comment">/* a 在目录parent_dir下安装目录项new_dir_entry, 写入硬盘后返回true,否则false */</span></span><br><span class="line">   <span class="keyword">if</span> (!sync_dir_entry(parent_dir, &amp;new_dir_entry, io_buf)) &#123;</span><br><span class="line">      printk(<span class="string">"sync dir_entry to disk failed\n"</span>);</span><br><span class="line">      rollback_step = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">goto</span> rollback;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">   <span class="comment">/* b 将父目录i结点的内容同步到硬盘 */</span></span><br><span class="line">   inode_sync(cur_part, parent_dir-&gt;inode, io_buf);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">   <span class="comment">/* c 将新创建文件的i结点内容同步到硬盘 */</span></span><br><span class="line">   inode_sync(cur_part, new_file_inode, io_buf);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* d 将inode_bitmap位图同步到硬盘 */</span></span><br><span class="line">   bitmap_sync(cur_part, inode_no, INODE_BITMAP);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* e 将创建的文件i结点添加到open_inodes链表 */</span></span><br><span class="line">   list_push(&amp;cur_part-&gt;open_inodes, &amp;new_file_inode-&gt;inode_tag);</span><br><span class="line">   new_file_inode-&gt;i_open_cnts = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   sys_free(io_buf);</span><br><span class="line">   <span class="keyword">return</span> pcb_fd_install(fd_idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建文件需要创建相关的多个资源,若某步失败则会执行到下面的回滚步骤 */</span></span><br><span class="line">rollback:</span><br><span class="line">   <span class="keyword">switch</span> (rollback_step) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	 <span class="comment">/* 失败时,将file_table中的相应位清空 */</span></span><br><span class="line">	 <span class="built_in">memset</span>(&amp;file_table[fd_idx], <span class="number">0</span>, <span class="keyword">sizeof</span>(struct file)); </span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	 sys_free(new_file_inode);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	 <span class="comment">/* 如果新文件的i结点创建失败,之前位图中分配的inode_no也要恢复 */</span></span><br><span class="line">	 bitmap_set(&amp;cur_part-&gt;inode_bitmap, inode_no, <span class="number">0</span>);</span><br><span class="line">	 <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   sys_free(io_buf);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现sys-open"><a href="#实现sys-open" class="headerlink" title="实现sys_open"></a>实现sys_open</h2><p>open函数的功能相当强大，通过它的打开标志，修改其调用参数，不仅可以打开一个文件，同样可以创建一个文件，所以不单独实现create类函数，文件的创建过程中主要是对绝对路径的解析。在路径没有问题且该文件不存在的前提下，标志设置为<code>O_CREAT</code>，就会调用之前的file_create函数创建文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开或创建文件成功后,返回文件描述符,否则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_open(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">uint8_t</span> flags) &#123;</span><br><span class="line">  <span class="comment">/* 对目录要用dir_open,这里只有open文件 */</span></span><br><span class="line">   <span class="keyword">if</span> (pathname[<span class="built_in">strlen</span>(pathname) - <span class="number">1</span>] == <span class="string">'/'</span>) &#123;</span><br><span class="line">      printk(<span class="string">"can`t open a directory %s\n"</span>,pathname);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ASSERT(flags &lt;= <span class="number">7</span>);</span><br><span class="line">   <span class="keyword">int32_t</span> fd = <span class="number">-1</span>;	   <span class="comment">// 默认为找不到</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">path_search_record</span> <span class="title">searched_record</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;searched_record, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct path_search_record));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 记录目录深度.帮助判断中间某个目录不存在的情况 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> pathname_depth = path_depth_cnt((<span class="keyword">char</span>*)pathname);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 先检查文件是否存在 */</span></span><br><span class="line">   <span class="keyword">int</span> inode_no = search_file(pathname, &amp;searched_record);</span><br><span class="line">   <span class="keyword">bool</span> found = inode_no != <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (searched_record.file_type == FT_DIRECTORY) &#123;</span><br><span class="line">      printk(<span class="string">"can`t open a direcotry with open(), use opendir() to instead\n"</span>);</span><br><span class="line">      dir_close(searched_record.parent_dir);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> path_searched_depth = path_depth_cnt(searched_record.searched_path);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 先判断是否把pathname的各层目录都访问到了,即是否在某个中间目录就失败了 */</span></span><br><span class="line">   <span class="keyword">if</span> (pathname_depth != path_searched_depth) &#123;   <span class="comment">// 说明并没有访问到全部的路径,某个中间目录是不存在的</span></span><br><span class="line">      printk(<span class="string">"cannot access %s: Not a directory, subpath %s is`t exist\n"</span>, \</span><br><span class="line">	    pathname, searched_record.searched_path);</span><br><span class="line">      dir_close(searched_record.parent_dir);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 若是在最后一个路径上没找到,并且并不是要创建文件,直接返回-1 */</span></span><br><span class="line">   <span class="keyword">if</span> (!found &amp;&amp; !(flags &amp; O_CREAT)) &#123;</span><br><span class="line">      printk(<span class="string">"in path %s, file %s is`t exist\n"</span>, \</span><br><span class="line">	    searched_record.searched_path, \</span><br><span class="line">	    (<span class="built_in">strrchr</span>(searched_record.searched_path, <span class="string">'/'</span>) + <span class="number">1</span>));</span><br><span class="line">      dir_close(searched_record.parent_dir);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (found &amp;&amp; flags &amp; O_CREAT) &#123;  <span class="comment">// 若要创建的文件已存在</span></span><br><span class="line">      printk(<span class="string">"%s has already exist!\n"</span>, pathname);</span><br><span class="line">      dir_close(searched_record.parent_dir);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> (flags &amp; O_CREAT) &#123;</span><br><span class="line">      <span class="keyword">case</span> O_CREAT:</span><br><span class="line">	 printk(<span class="string">"creating file\n"</span>);</span><br><span class="line">	 fd = file_create(searched_record.parent_dir, (<span class="built_in">strrchr</span>(pathname, <span class="string">'/'</span>) + <span class="number">1</span>), flags);</span><br><span class="line">	 dir_close(searched_record.parent_dir);</span><br><span class="line">      <span class="comment">// 其余为打开文件</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 此fd是指任务pcb-&gt;fd_table数组中的元素下标,</span></span><br><span class="line"><span class="comment">    * 并不是指全局file_table中的下标 */</span></span><br><span class="line">   <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面修改main函数并验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   process_execute(u_prog_a, <span class="string">"u_prog_a"</span>);</span><br><span class="line">   process_execute(u_prog_b, <span class="string">"u_prog_b"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_a"</span>, <span class="number">31</span>, k_thread_a, <span class="string">"I am thread_a"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_b"</span>, <span class="number">31</span>, k_thread_b, <span class="string">"I am thread_b"</span>);</span><br><span class="line">   sys_open(<span class="string">"/file1"</span>, O_CREAT);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下，第二次运行显示文件已经存在</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/96.png" alt="image-20200612181835991"></p>
<p>接下来我们需要继续改进sys_open，使其支持更多功能，打开文件的核心操作是file_open，实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开编号为inode_no的inode对应的文件,若成功则返回文件描述符,否则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> file_open(<span class="keyword">uint32_t</span> inode_no, <span class="keyword">uint8_t</span> flag) &#123;</span><br><span class="line">   <span class="keyword">int</span> fd_idx = get_free_slot_in_global();</span><br><span class="line">   <span class="keyword">if</span> (fd_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">      printk(<span class="string">"exceed max open files\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   file_table[fd_idx].fd_inode = inode_open(cur_part, inode_no);</span><br><span class="line">   file_table[fd_idx].fd_pos = <span class="number">0</span>;	     <span class="comment">// 每次打开文件,要将fd_pos还原为0,即让文件内的指针指向开头</span></span><br><span class="line">   file_table[fd_idx].fd_flag = flag;</span><br><span class="line">   <span class="keyword">bool</span>* write_deny = &amp;file_table[fd_idx].fd_inode-&gt;write_deny; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (flag &amp; O_WRONLY || flag &amp; O_RDWR) &#123;	<span class="comment">// 只要是关于写文件,判断是否有其它进程正写此文件</span></span><br><span class="line">						<span class="comment">// 若是读文件,不考虑write_deny</span></span><br><span class="line">   <span class="comment">/* 以下进入临界区前先关中断 */</span></span><br><span class="line">      <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">      <span class="keyword">if</span> (!(*write_deny)) &#123;    <span class="comment">// 若当前没有其它进程写该文件,将其占用.</span></span><br><span class="line">	 *write_deny = <span class="literal">true</span>;   <span class="comment">// 置为true,避免多个进程同时写此文件</span></span><br><span class="line">	 intr_set_status(old_status);	  <span class="comment">// 恢复中断</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;		<span class="comment">// 直接失败返回</span></span><br><span class="line">	 intr_set_status(old_status);</span><br><span class="line">	 printk(<span class="string">"file can`t be write now, try again later\n"</span>);</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  <span class="comment">// 若是读文件或创建文件,不用理会write_deny,保持默认</span></span><br><span class="line">   <span class="keyword">return</span> pcb_fd_install(fd_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sys_open中增加一个case判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (flags &amp; O_CREAT) &#123;</span><br><span class="line">   <span class="keyword">case</span> O_CREAT:</span><br><span class="line">printk(<span class="string">"creating file\n"</span>);</span><br><span class="line">fd = file_create(searched_record.parent_dir, (<span class="built_in">strrchr</span>(pathname, <span class="string">'/'</span>) + <span class="number">1</span>), flags);</span><br><span class="line">dir_close(searched_record.parent_dir);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* 其余情况均为打开已存在文件:</span></span><br><span class="line"><span class="comment"> * O_RDONLY,O_WRONLY,O_RDWR */</span></span><br><span class="line">fd = file_open(inode_no, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现sys-close"><a href="#实现sys-close" class="headerlink" title="实现sys_close"></a>实现sys_close</h2><p>close函数原型是<code>int close(int fd)</code>，其底层核心是file_close</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 关闭文件 */</span></span><br><span class="line"><span class="keyword">int32_t</span> file_close(struct file* file) &#123;</span><br><span class="line">   <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   file-&gt;fd_inode-&gt;write_deny = <span class="literal">false</span>;</span><br><span class="line">   inode_close(file-&gt;fd_inode);</span><br><span class="line">   file-&gt;fd_inode = <span class="literal">NULL</span>;   <span class="comment">// 使文件结构可用</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sys_close实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将文件描述符转化为文件表的下标 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint32_t <span class="title">fd_local2global</span><span class="params">(<span class="keyword">uint32_t</span> local_fd)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">   <span class="keyword">int32_t</span> global_fd = cur-&gt;fd_table[local_fd];  </span><br><span class="line">   ASSERT(global_fd &gt;= <span class="number">0</span> &amp;&amp; global_fd &lt; MAX_FILE_OPEN);</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)global_fd;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭文件描述符fd指向的文件,成功返回0,否则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_close(<span class="keyword">int32_t</span> fd) &#123;</span><br><span class="line">   <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;   <span class="comment">// 返回值默认为-1,即失败</span></span><br><span class="line">   <span class="keyword">if</span> (fd &gt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> _fd = fd_local2global(fd);</span><br><span class="line">      ret = file_close(&amp;file_table[_fd]);</span><br><span class="line">      running_thread()-&gt;fd_table[fd] = <span class="number">-1</span>; <span class="comment">// 使该文件描述符位可用</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数中测试一下刚才的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   process_execute(u_prog_a, <span class="string">"u_prog_a"</span>);</span><br><span class="line">   process_execute(u_prog_b, <span class="string">"u_prog_b"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_a"</span>, <span class="number">31</span>, k_thread_a, <span class="string">"I am thread_a"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_b"</span>, <span class="number">31</span>, k_thread_b, <span class="string">"I am thread_b"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> fd = sys_open(<span class="string">"/file1"</span>, O_RDONLY);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"fd:%d\n"</span>, fd);</span><br><span class="line">   sys_close(fd);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d closed now\n"</span>, fd);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们成功将file1关闭</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/97.png" alt="image-20200612181835991"></p>
<h2 id="实现文件写入"><a href="#实现文件写入" class="headerlink" title="实现文件写入"></a>实现文件写入</h2><p>首先我们需要实现file_write函数，其作用是系统调用write的内核实现，文件最大尺寸是140个块，也就是支持140*512字节数据。写入文件时要判断是否需要分配新的数据块。如果12个直接块不够存储该数据，就分配间接块来存储，当所需的数据块分配好了之后，就会逐块的往硬盘上写入数据，直到所有的数据被写入硬盘，最后返回写入的字节数，代码略长</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把buf中的count个字节写入file,成功则返回写入的字节数,失败则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> file_write(struct file* file, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   <span class="keyword">if</span> ((file-&gt;fd_inode-&gt;i_size + count) &gt; (BLOCK_SIZE * <span class="number">140</span>))	&#123;   <span class="comment">// 文件目前最大只支持512*140=71680字节</span></span><br><span class="line">      printk(<span class="string">"exceed max file_size 71680 bytes, write file failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">uint8_t</span>* io_buf = sys_malloc(BLOCK_SIZE);</span><br><span class="line">   <span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"file_write: sys_malloc for io_buf failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">uint32_t</span>* all_blocks = (<span class="keyword">uint32_t</span>*)sys_malloc(BLOCK_SIZE + <span class="number">48</span>);	  <span class="comment">// 用来记录文件所有的块地址</span></span><br><span class="line">   <span class="keyword">if</span> (all_blocks == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"file_write: sys_malloc for all_blocks failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">uint8_t</span>* src = buf;	    <span class="comment">// 用src指向buf中待写入的数据 </span></span><br><span class="line">   <span class="keyword">uint32_t</span> bytes_written = <span class="number">0</span>;	    <span class="comment">// 用来记录已写入数据大小</span></span><br><span class="line">   <span class="keyword">uint32_t</span> size_left = count;	    <span class="comment">// 用来记录未写入数据大小</span></span><br><span class="line">   <span class="keyword">int32_t</span> block_lba = <span class="number">-1</span>;	    <span class="comment">// 块地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_bitmap_idx = <span class="number">0</span>;   <span class="comment">// 用来记录block对应于block_bitmap中的索引,做为参数传给bitmap_sync</span></span><br><span class="line">   <span class="keyword">uint32_t</span> sec_idx;	      <span class="comment">// 用来索引扇区</span></span><br><span class="line">   <span class="keyword">uint32_t</span> sec_lba;	      <span class="comment">// 扇区地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> sec_off_bytes;    <span class="comment">// 扇区内字节偏移量</span></span><br><span class="line">   <span class="keyword">uint32_t</span> sec_left_bytes;   <span class="comment">// 扇区内剩余字节量</span></span><br><span class="line">   <span class="keyword">uint32_t</span> chunk_size;	      <span class="comment">// 每次写入硬盘的数据块大小</span></span><br><span class="line">   <span class="keyword">int32_t</span> indirect_block_table;      <span class="comment">// 用来获取一级间接表地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_idx;		      <span class="comment">// 块索引</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 判断文件是否是第一次写,如果是,先为其分配一个块 */</span></span><br><span class="line">   <span class="keyword">if</span> (file-&gt;fd_inode-&gt;i_sectors[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">      block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">      <span class="keyword">if</span> (block_lba == <span class="number">-1</span>) &#123;</span><br><span class="line">	 printk(<span class="string">"file_write: block_bitmap_alloc failed\n"</span>);</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      file-&gt;fd_inode-&gt;i_sectors[<span class="number">0</span>] = block_lba;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 每分配一个块就将位图同步到硬盘 */</span></span><br><span class="line">      block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">      ASSERT(block_bitmap_idx != <span class="number">0</span>);</span><br><span class="line">      bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 写入count个字节前,该文件已经占用的块数 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> file_has_used_blocks = file-&gt;fd_inode-&gt;i_size / BLOCK_SIZE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 存储count字节后该文件将占用的块数 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> file_will_use_blocks = (file-&gt;fd_inode-&gt;i_size + count) / BLOCK_SIZE + <span class="number">1</span>;</span><br><span class="line">   ASSERT(file_will_use_blocks &lt;= <span class="number">140</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 通过此增量判断是否需要分配扇区,如增量为0,表示原扇区够用 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> add_blocks = file_will_use_blocks - file_has_used_blocks;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开始将文件所有块地址收集到all_blocks,(系统中块大小等于扇区大小)</span></span><br><span class="line"><span class="comment"> * 后面都统一在all_blocks中获取写入扇区地址 */</span></span><br><span class="line">   <span class="keyword">if</span> (add_blocks == <span class="number">0</span>) &#123; </span><br><span class="line">   <span class="comment">/* 在同一扇区内写入数据,不涉及到分配新扇区 */</span></span><br><span class="line">      <span class="keyword">if</span> (file_has_used_blocks &lt;= <span class="number">12</span> ) &#123;	<span class="comment">// 文件数据量将在12块之内</span></span><br><span class="line">	 block_idx = file_has_used_blocks - <span class="number">1</span>;  <span class="comment">// 指向最后一个已有数据的扇区</span></span><br><span class="line">	 all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">/* 未写入新数据之前已经占用了间接块,需要将间接块地址读进来 */</span></span><br><span class="line">	 ASSERT(file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>);</span><br><span class="line">         indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>];</span><br><span class="line">	 ide_read(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">/* 若有增量,便涉及到分配新扇区及是否分配一级间接块表,下面要分三种情况处理 */</span></span><br><span class="line">   <span class="comment">/* 第一种情况:12个直接块够用*/</span></span><br><span class="line">      <span class="keyword">if</span> (file_will_use_blocks &lt;= <span class="number">12</span> ) &#123;</span><br><span class="line">      <span class="comment">/* 先将有剩余空间的可继续用的扇区地址写入all_blocks */</span></span><br><span class="line">	 block_idx = file_has_used_blocks - <span class="number">1</span>;</span><br><span class="line">	 ASSERT(file-&gt;fd_inode-&gt;i_sectors[block_idx] != <span class="number">0</span>);</span><br><span class="line">	 all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 再将未来要用的扇区分配好后写入all_blocks */</span></span><br><span class="line">	 block_idx = file_has_used_blocks;      <span class="comment">// 指向第一个要分配的新扇区</span></span><br><span class="line">	 <span class="keyword">while</span> (block_idx &lt; file_will_use_blocks) &#123;</span><br><span class="line">	    block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">	    <span class="keyword">if</span> (block_lba == <span class="number">-1</span>) &#123;</span><br><span class="line">	       printk(<span class="string">"file_write: block_bitmap_alloc for situation 1 failed\n"</span>);</span><br><span class="line">	       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 写文件时,不应该存在块未使用但已经分配扇区的情况,当文件删除时,就会把块地址清0 */</span></span><br><span class="line">	    ASSERT(file-&gt;fd_inode-&gt;i_sectors[block_idx] == <span class="number">0</span>);     <span class="comment">// 确保尚未分配扇区地址</span></span><br><span class="line">	    file-&gt;fd_inode-&gt;i_sectors[block_idx] = all_blocks[block_idx] = block_lba;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* 每分配一个块就将位图同步到硬盘 */</span></span><br><span class="line">	    block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	    bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line"></span><br><span class="line">	    block_idx++;   <span class="comment">// 下一个分配的新扇区</span></span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file_has_used_blocks &lt;= <span class="number">12</span> &amp;&amp; file_will_use_blocks &gt; <span class="number">12</span>) &#123; </span><br><span class="line">	 <span class="comment">/* 第二种情况: 旧数据在12个直接块内,新数据将使用间接块*/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 先将有剩余空间的可继续用的扇区地址收集到all_blocks */</span></span><br><span class="line">	 block_idx = file_has_used_blocks - <span class="number">1</span>;      <span class="comment">// 指向旧数据所在的最后一个扇区</span></span><br><span class="line">	 all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx];</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 创建一级间接块表 */</span></span><br><span class="line">	 block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">	 <span class="keyword">if</span> (block_lba == <span class="number">-1</span>) &#123;</span><br><span class="line">	    printk(<span class="string">"file_write: block_bitmap_alloc for situation 2 failed\n"</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 ASSERT(file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] == <span class="number">0</span>);  <span class="comment">// 确保一级间接块表未分配</span></span><br><span class="line">	 <span class="comment">/* 分配一级间接块索引表 */</span></span><br><span class="line">	 indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] = block_lba;</span><br><span class="line"></span><br><span class="line">	 block_idx = file_has_used_blocks;	<span class="comment">// 第一个未使用的块,即本文件最后一个已经使用的直接块的下一块</span></span><br><span class="line">	 <span class="keyword">while</span> (block_idx &lt; file_will_use_blocks) &#123;</span><br><span class="line">	    block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">	    <span class="keyword">if</span> (block_lba == <span class="number">-1</span>) &#123;</span><br><span class="line">	       printk(<span class="string">"file_write: block_bitmap_alloc for situation 2 failed\n"</span>);</span><br><span class="line">	       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (block_idx &lt; <span class="number">12</span>) &#123;      <span class="comment">// 新创建的0~11块直接存入all_blocks数组</span></span><br><span class="line">	       ASSERT(file-&gt;fd_inode-&gt;i_sectors[block_idx] == <span class="number">0</span>);      <span class="comment">// 确保尚未分配扇区地址</span></span><br><span class="line">	       file-&gt;fd_inode-&gt;i_sectors[block_idx] = all_blocks[block_idx] = block_lba;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;     <span class="comment">// 间接块只写入到all_block数组中,待全部分配完成后一次性同步到硬盘</span></span><br><span class="line">	       all_blocks[block_idx] = block_lba;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* 每分配一个块就将位图同步到硬盘 */</span></span><br><span class="line">	    block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	    bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line"></span><br><span class="line">	    block_idx++;   <span class="comment">// 下一个新扇区</span></span><br><span class="line">	 &#125;</span><br><span class="line">	 ide_write(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>);      <span class="comment">// 同步一级间接块表到硬盘</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file_has_used_blocks &gt; <span class="number">12</span>) &#123;</span><br><span class="line">	 <span class="comment">/* 第三种情况:新数据占据间接块*/</span></span><br><span class="line">	 ASSERT(file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>); <span class="comment">// 已经具备了一级间接块表</span></span><br><span class="line">	 indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>];	 <span class="comment">// 获取一级间接表地址</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 已使用的间接块也将被读入all_blocks,无须单独收录 */</span></span><br><span class="line">	 ide_read(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>); <span class="comment">// 获取所有间接块地址</span></span><br><span class="line"></span><br><span class="line">	 block_idx = file_has_used_blocks;	  <span class="comment">// 第一个未使用的间接块,即已经使用的间接块的下一块</span></span><br><span class="line">	 <span class="keyword">while</span> (block_idx &lt; file_will_use_blocks) &#123;</span><br><span class="line">	    block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">	    <span class="keyword">if</span> (block_lba == <span class="number">-1</span>) &#123;</span><br><span class="line">	       printk(<span class="string">"file_write: block_bitmap_alloc for situation 3 failed\n"</span>);</span><br><span class="line">	       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    all_blocks[block_idx++] = block_lba;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* 每分配一个块就将位图同步到硬盘 */</span></span><br><span class="line">	    block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	    bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line">	 &#125;</span><br><span class="line">	 ide_write(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>);   <span class="comment">// 同步一级间接块表到硬盘</span></span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">bool</span> first_write_block = <span class="literal">true</span>;      <span class="comment">// 含有剩余空间的扇区标识</span></span><br><span class="line">   <span class="comment">/* 块地址已经收集到all_blocks中,下面开始写数据 */</span></span><br><span class="line">   file-&gt;fd_pos = file-&gt;fd_inode-&gt;i_size - <span class="number">1</span>;   <span class="comment">// 置fd_pos为文件大小-1,下面在写数据时随时更新</span></span><br><span class="line">   <span class="keyword">while</span> (bytes_written &lt; count) &#123;      <span class="comment">// 直到写完所有数据</span></span><br><span class="line">      <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, BLOCK_SIZE);</span><br><span class="line">      sec_idx = file-&gt;fd_inode-&gt;i_size / BLOCK_SIZE;</span><br><span class="line">      sec_lba = all_blocks[sec_idx];</span><br><span class="line">      sec_off_bytes = file-&gt;fd_inode-&gt;i_size % BLOCK_SIZE;</span><br><span class="line">      sec_left_bytes = BLOCK_SIZE - sec_off_bytes;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断此次写入硬盘的数据大小 */</span></span><br><span class="line">      chunk_size = size_left &lt; sec_left_bytes ? size_left : sec_left_bytes;</span><br><span class="line">      <span class="keyword">if</span> (first_write_block) &#123;</span><br><span class="line">	 ide_read(cur_part-&gt;my_disk, sec_lba, io_buf, <span class="number">1</span>);</span><br><span class="line">	 first_write_block = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(io_buf + sec_off_bytes, src, chunk_size);</span><br><span class="line">      ide_write(cur_part-&gt;my_disk, sec_lba, io_buf, <span class="number">1</span>);</span><br><span class="line">      printk(<span class="string">"file write at lba 0x%x\n"</span>, sec_lba);    <span class="comment">//调试,完成后去掉</span></span><br><span class="line"></span><br><span class="line">      src += chunk_size;   <span class="comment">// 将指针推移到下个新数据</span></span><br><span class="line">      file-&gt;fd_inode-&gt;i_size += chunk_size;  <span class="comment">// 更新文件大小</span></span><br><span class="line">      file-&gt;fd_pos += chunk_size;   </span><br><span class="line">      bytes_written += chunk_size;</span><br><span class="line">      size_left -= chunk_size;</span><br><span class="line">   &#125;</span><br><span class="line">   inode_sync(cur_part, file-&gt;fd_inode, io_buf);</span><br><span class="line">   sys_free(all_blocks);</span><br><span class="line">   sys_free(io_buf);</span><br><span class="line">   <span class="keyword">return</span> bytes_written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来改进sys_write</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将buf中连续count个字节写入文件描述符fd,成功则返回写入的字节数,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_write(<span class="keyword">int32_t</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      printk(<span class="string">"sys_write: fd error\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (fd == stdout_no) &#123;  </span><br><span class="line">      <span class="keyword">char</span> tmp_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="built_in">memcpy</span>(tmp_buf, buf, count);</span><br><span class="line">      console_put_str(tmp_buf);</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">uint32_t</span> _fd = fd_local2global(fd);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">wr_file</span> = &amp;<span class="title">file_table</span>[_<span class="title">fd</span>];</span></span><br><span class="line">   <span class="keyword">if</span> (wr_file-&gt;fd_flag &amp; O_WRONLY || wr_file-&gt;fd_flag &amp; O_RDWR) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> bytes_written  = file_write(wr_file, buf, count);</span><br><span class="line">      <span class="keyword">return</span> bytes_written;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      console_put_str(<span class="string">"sys_write: not allowed to write file without flag O_RDWR or O_WRONLY\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>write系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把buf中count个字符写入文件描述符fd */</span></span><br><span class="line"><span class="keyword">uint32_t</span> write(<span class="keyword">int32_t</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall3(SYS_WRITE, fd, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面修改一些其他文件就可以对新版write进行测试，main中测试代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   process_execute(u_prog_a, <span class="string">"u_prog_a"</span>);</span><br><span class="line">   process_execute(u_prog_b, <span class="string">"u_prog_b"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_a"</span>, <span class="number">31</span>, k_thread_a, <span class="string">"I am thread_a"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_b"</span>, <span class="number">31</span>, k_thread_b, <span class="string">"I am thread_b"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> fd = sys_open(<span class="string">"/file1"</span>, O_RDWR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"fd:%d\n"</span>, fd);</span><br><span class="line">   sys_write(fd, <span class="string">"hello,world\n"</span>, <span class="number">12</span>);</span><br><span class="line">   sys_close(fd);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d closed now\n"</span>, fd);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下，这里写入了0xA65处的内存</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/98.png" alt="image-20200612181835991"></p>
<p>下面用脚本文件查看0xA65处的内存，这里我连续运行了三次，数据写入和更新正确</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/99.png" alt></p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>上面实现了写入的功能，下面添加读取文件file_read函数，还是老规矩，file文件中先添加框架，然后在fs文件中添加系统调用，实现和write类似，要判断是否超过12个块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从文件file中读取count个字节写入buf, 返回读出的字节数,若到文件尾则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> file_read(struct file* file, <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   <span class="keyword">uint8_t</span>* buf_dst = (<span class="keyword">uint8_t</span>*)buf;</span><br><span class="line">   <span class="keyword">uint32_t</span> size = count, size_left = size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 若要读取的字节数超过了文件可读的剩余量, 就用剩余量做为待读取的字节数 */</span></span><br><span class="line">   <span class="keyword">if</span> ((file-&gt;fd_pos + count) &gt; file-&gt;fd_inode-&gt;i_size)	&#123; <span class="comment">// 判断文件是否已读到文件尾</span></span><br><span class="line">      size = file-&gt;fd_inode-&gt;i_size - file-&gt;fd_pos;</span><br><span class="line">      size_left = size;</span><br><span class="line">      <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;	   <span class="comment">// 若到文件尾则返回-1</span></span><br><span class="line">	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint8_t</span>* io_buf = sys_malloc(BLOCK_SIZE);</span><br><span class="line">   <span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"file_read: sys_malloc for io_buf failed\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">uint32_t</span>* all_blocks = (<span class="keyword">uint32_t</span>*)sys_malloc(BLOCK_SIZE + <span class="number">48</span>);	  <span class="comment">// 用来记录文件所有的块地址</span></span><br><span class="line">   <span class="keyword">if</span> (all_blocks == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"file_read: sys_malloc for all_blocks failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> block_read_start_idx = file-&gt;fd_pos / BLOCK_SIZE;		       <span class="comment">// 数据所在块的起始地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_read_end_idx = (file-&gt;fd_pos + size) / BLOCK_SIZE;	       <span class="comment">// 数据所在块的终止地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> read_blocks = block_read_start_idx - block_read_end_idx;	       <span class="comment">// 如增量为0,表示数据在同一扇区</span></span><br><span class="line">   ASSERT(block_read_start_idx &lt; <span class="number">139</span> &amp;&amp; block_read_end_idx &lt; <span class="number">139</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int32_t</span> indirect_block_table;       <span class="comment">// 用来获取一级间接表地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_idx;		       <span class="comment">// 获取待读的块地址 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下开始构建all_blocks块地址数组,专门存储用到的块地址(本程序中块大小同扇区大小) */</span></span><br><span class="line">   <span class="keyword">if</span> (read_blocks == <span class="number">0</span>) &#123;       <span class="comment">// 在同一扇区内读数据,不涉及到跨扇区读取</span></span><br><span class="line">      ASSERT(block_read_end_idx == block_read_start_idx);</span><br><span class="line">      <span class="keyword">if</span> (block_read_end_idx &lt; <span class="number">12</span> ) &#123;	   <span class="comment">// 待读的数据在12个直接块之内</span></span><br><span class="line">	 block_idx = block_read_end_idx;</span><br><span class="line">	 all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;		<span class="comment">// 若用到了一级间接块表,需要将表中间接块读进来</span></span><br><span class="line">	 indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>];</span><br><span class="line">	 ide_read(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;      <span class="comment">// 若要读多个块</span></span><br><span class="line">   <span class="comment">/* 第一种情况: 起始块和终止块属于直接块*/</span></span><br><span class="line">      <span class="keyword">if</span> (block_read_end_idx &lt; <span class="number">12</span> ) &#123;	  <span class="comment">// 数据结束所在的块属于直接块</span></span><br><span class="line">	 block_idx = block_read_start_idx; </span><br><span class="line">	 <span class="keyword">while</span> (block_idx &lt;= block_read_end_idx) &#123;</span><br><span class="line">	    all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx]; </span><br><span class="line">	    block_idx++;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (block_read_start_idx &lt; <span class="number">12</span> &amp;&amp; block_read_end_idx &gt;= <span class="number">12</span>) &#123;</span><br><span class="line">   <span class="comment">/* 第二种情况: 待读入的数据跨越直接块和间接块两类*/</span></span><br><span class="line">       <span class="comment">/* 先将直接块地址写入all_blocks */</span></span><br><span class="line">	 block_idx = block_read_start_idx;</span><br><span class="line">	 <span class="keyword">while</span> (block_idx &lt; <span class="number">12</span>) &#123;</span><br><span class="line">	    all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx];</span><br><span class="line">	    block_idx++;</span><br><span class="line">	 &#125;</span><br><span class="line">	 ASSERT(file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>);	    <span class="comment">// 确保已经分配了一级间接块表</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 再将间接块地址写入all_blocks */</span></span><br><span class="line">	 indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>];</span><br><span class="line">	 ide_read(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>);	      <span class="comment">// 将一级间接块表读进来写入到第13个块的位置之后</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;	</span><br><span class="line">   <span class="comment">/* 第三种情况: 数据在间接块中*/</span></span><br><span class="line">	 ASSERT(file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>);	    <span class="comment">// 确保已经分配了一级间接块表</span></span><br><span class="line">	 indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>];	      <span class="comment">// 获取一级间接表地址</span></span><br><span class="line">	 ide_read(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>);	      <span class="comment">// 将一级间接块表读进来写入到第13个块的位置之后</span></span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 用到的块地址已经收集到all_blocks中,下面开始读数据 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> sec_idx, sec_lba, sec_off_bytes, sec_left_bytes, chunk_size;</span><br><span class="line">   <span class="keyword">uint32_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (bytes_read &lt; size) &#123;	      <span class="comment">// 直到读完为止</span></span><br><span class="line">      sec_idx = file-&gt;fd_pos / BLOCK_SIZE;</span><br><span class="line">      sec_lba = all_blocks[sec_idx];</span><br><span class="line">      sec_off_bytes = file-&gt;fd_pos % BLOCK_SIZE;</span><br><span class="line">      sec_left_bytes = BLOCK_SIZE - sec_off_bytes;</span><br><span class="line">      chunk_size = size_left &lt; sec_left_bytes ? size_left : sec_left_bytes;	     <span class="comment">// 待读入的数据大小</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, BLOCK_SIZE);</span><br><span class="line">      ide_read(cur_part-&gt;my_disk, sec_lba, io_buf, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">memcpy</span>(buf_dst, io_buf + sec_off_bytes, chunk_size);</span><br><span class="line"></span><br><span class="line">      buf_dst += chunk_size;</span><br><span class="line">      file-&gt;fd_pos += chunk_size;</span><br><span class="line">      bytes_read += chunk_size;</span><br><span class="line">      size_left -= chunk_size;</span><br><span class="line">   &#125;</span><br><span class="line">   sys_free(all_blocks);</span><br><span class="line">   sys_free(io_buf);</span><br><span class="line">   <span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是sys_read，其实就是对file_read的封装</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从文件描述符fd指向的文件中读取count个字节到buf,若成功则返回读出的字节数,到文件尾则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_read(<span class="keyword">int32_t</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      printk(<span class="string">"sys_read: fd error\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ASSERT(buf != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">uint32_t</span> _fd = fd_local2global(fd);</span><br><span class="line">   <span class="keyword">return</span> file_read(&amp;file_table[_fd], buf, count);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面直接测试，main中测试代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   process_execute(u_prog_a, <span class="string">"u_prog_a"</span>);</span><br><span class="line">   process_execute(u_prog_b, <span class="string">"u_prog_b"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_a"</span>, <span class="number">31</span>, k_thread_a, <span class="string">"I am thread_a"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_b"</span>, <span class="number">31</span>, k_thread_b, <span class="string">"I am thread_b"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> fd = sys_open(<span class="string">"/file1"</span>, O_RDWR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"open /file1, fd:%d\n"</span>, fd);</span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> read_bytes = sys_read(fd, buf, <span class="number">18</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"1_ read %d bytes:\n%s\n"</span>, read_bytes, buf);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">   read_bytes = sys_read(fd, buf, <span class="number">6</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"2_ read %d bytes:\n%s"</span>, read_bytes, buf);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">   read_bytes = sys_read(fd, buf, <span class="number">6</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"3_ read %d bytes:\n%s"</span>, read_bytes, buf);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"________  close file1 and reopen  ________\n"</span>);</span><br><span class="line">   sys_close(fd);</span><br><span class="line">   fd = sys_open(<span class="string">"/file1"</span>, O_RDWR);</span><br><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">   read_bytes = sys_read(fd, buf, <span class="number">24</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"4_ read %d bytes:\n%s"</span>, read_bytes, buf);</span><br><span class="line"></span><br><span class="line">   sys_close(fd);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下，和之前写入了三次helloworld数据相符</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/100.png" alt></p>
<h2 id="实现文件读写指针定位"><a href="#实现文件读写指针定位" class="headerlink" title="实现文件读写指针定位"></a>实现文件读写指针定位</h2><p>这个功能类似lseek函数，本质上就是设置文件读写时的起始偏移量，我们需要自由设置文件指针，文件的读写偏移量的设置有三个标志，文件头，文件当前位置，文件尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件读写位置偏移量</span></span><br><span class="line"><span class="keyword">enum</span> whence</span><br><span class="line">&#123;</span><br><span class="line">    SEEK_SET = <span class="number">1</span>,</span><br><span class="line">    SEEK_CUR,</span><br><span class="line">    SEEK_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是具体实现，其中分别处理了三种flag的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重置用于文件读写操作的偏移指针,成功时返回新的偏移量,出错时返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_lseek(<span class="keyword">int32_t</span> fd, <span class="keyword">int32_t</span> offset, <span class="keyword">uint8_t</span> whence)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ASSERT(whence &gt; <span class="number">0</span> &amp;&amp; whence &lt; <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> _fd = fd_local2global(fd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">pf</span> = &amp;<span class="title">file_table</span>[_<span class="title">fd</span>];</span></span><br><span class="line">	<span class="keyword">int32_t</span> new_pos = <span class="number">0</span>; <span class="comment">//新的偏移量必须位于文件大小之内</span></span><br><span class="line">	<span class="keyword">int32_t</span> file_size = (<span class="keyword">int32_t</span>)pf-&gt;fd_inode-&gt;i_size;</span><br><span class="line">	<span class="keyword">switch</span> (whence)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">/* SEEK_SET 新的读写位置是相对于文件开头再增加offset个位移量 */</span></span><br><span class="line">	<span class="keyword">case</span> SEEK_SET:</span><br><span class="line">		new_pos = offset;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SEEK_CUR 新的读写位置是相对于当前的位置增加offset个位移量 */</span></span><br><span class="line">	<span class="keyword">case</span> SEEK_CUR: <span class="comment">// offse可正可负</span></span><br><span class="line">		new_pos = (<span class="keyword">int32_t</span>)pf-&gt;fd_pos + offset;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SEEK_END 新的读写位置是相对于文件尺寸再增加offset个位移量 */</span></span><br><span class="line">	<span class="keyword">case</span> SEEK_END: <span class="comment">// 此情况下,offset应该为负值</span></span><br><span class="line">		new_pos = file_size + offset;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (new_pos &lt; <span class="number">0</span> || new_pos &gt; (file_size - <span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pf-&gt;fd_pos = new_pos;</span><br><span class="line">	<span class="keyword">return</span> pf-&gt;fd_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现文件删除"><a href="#实现文件删除" class="headerlink" title="实现文件删除"></a>实现文件删除</h2><p>lseek函数就不单独测试了，下面实现文件删除函数，过程起始就是创建文件的逆过程，我们需要回收inode和删除目录项。</p>
<p>inode相关资源如下</p>
<ul>
<li>inode位图</li>
<li>inode_table</li>
<li>inode中i_sectors[0~11]中的直接块和一级间接索引块表i_sector[12]中的间接块</li>
<li>一级间接索引块表本身的扇区地址</li>
</ul>
<p>目录项相关资源如下</p>
<ul>
<li>该文件对应的目录项数据需要清0</li>
<li>根目录必须存在且不能被清空，该文件删除之后，目录中不存在目录项，需要回收目录项对应的块</li>
<li>目录inode中的size需要减去该文件目录项大小</li>
<li>将目录inode同步到硬盘</li>
</ul>
<p>下面是删除inode部分，其中inode_delete是可有可无的，调试相关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将硬盘分区part上的inode清空 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inode_delete</span><span class="params">(struct partition* part, <span class="keyword">uint32_t</span> inode_no, <span class="keyword">void</span>* io_buf)</span> </span>&#123;</span><br><span class="line">   ASSERT(inode_no &lt; <span class="number">4096</span>);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode_position</span> <span class="title">inode_pos</span>;</span></span><br><span class="line">   inode_locate(part, inode_no, &amp;inode_pos);     <span class="comment">// inode位置信息会存入inode_pos</span></span><br><span class="line">   ASSERT(inode_pos.sec_lba &lt;= (part-&gt;start_lba + part-&gt;sec_cnt));</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">char</span>* inode_buf = (<span class="keyword">char</span>*)io_buf;</span><br><span class="line">   <span class="keyword">if</span> (inode_pos.two_sec) &#123;   <span class="comment">// inode跨扇区,读入2个扇区</span></span><br><span class="line">      <span class="comment">/* 将原硬盘上的内容先读出来 */</span></span><br><span class="line">      ide_read(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">2</span>);</span><br><span class="line">      <span class="comment">/* 将inode_buf清0 */</span></span><br><span class="line">      <span class="built_in">memset</span>((inode_buf + inode_pos.off_size), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct inode));</span><br><span class="line">      <span class="comment">/* 用清0的内存数据覆盖磁盘 */</span></span><br><span class="line">      ide_write(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">2</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 未跨扇区,只读入1个扇区就好</span></span><br><span class="line">      <span class="comment">/* 将原硬盘上的内容先读出来 */</span></span><br><span class="line">      ide_read(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">/* 将inode_buf清0 */</span></span><br><span class="line">      <span class="built_in">memset</span>((inode_buf + inode_pos.off_size), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct inode));</span><br><span class="line">      <span class="comment">/* 用清0的内存数据覆盖磁盘 */</span></span><br><span class="line">      ide_write(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回收inode的数据块和inode本身 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inode_release</span><span class="params">(struct partition* part, <span class="keyword">uint32_t</span> inode_no)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode_to_del</span> = <span class="title">inode_open</span>(<span class="title">part</span>, <span class="title">inode_no</span>);</span></span><br><span class="line">   ASSERT(inode_to_del-&gt;i_no == inode_no);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1 回收inode占用的所有块 */</span></span><br><span class="line">   <span class="keyword">uint8_t</span> block_idx = <span class="number">0</span>, block_cnt = <span class="number">12</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> block_bitmap_idx;</span><br><span class="line">   <span class="keyword">uint32_t</span> all_blocks[<span class="number">140</span>] = &#123;<span class="number">0</span>&#125;;	  <span class="comment">//12个直接块+128个间接块</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* a 先将前12个直接块存入all_blocks */</span></span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">12</span>) &#123;</span><br><span class="line">      all_blocks[block_idx] = inode_to_del-&gt;i_sectors[block_idx];</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* b 如果一级间接块表存在,将其128个间接块读到all_blocks[12~], 并释放一级间接块表所占的扇区 */</span></span><br><span class="line">   <span class="keyword">if</span> (inode_to_del-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">      ide_read(part-&gt;my_disk, inode_to_del-&gt;i_sectors[<span class="number">12</span>], all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">      block_cnt = <span class="number">140</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 回收一级间接块表占用的扇区 */</span></span><br><span class="line">      block_bitmap_idx = inode_to_del-&gt;i_sectors[<span class="number">12</span>] - part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">      ASSERT(block_bitmap_idx &gt; <span class="number">0</span>);</span><br><span class="line">      bitmap_set(&amp;part-&gt;block_bitmap, block_bitmap_idx, <span class="number">0</span>);</span><br><span class="line">      bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* c inode所有的块地址已经收集到all_blocks中,下面逐个回收 */</span></span><br><span class="line">   block_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; block_cnt) &#123;</span><br><span class="line">      <span class="keyword">if</span> (all_blocks[block_idx] != <span class="number">0</span>) &#123;</span><br><span class="line">	 block_bitmap_idx = <span class="number">0</span>;</span><br><span class="line">	 block_bitmap_idx = all_blocks[block_idx] - part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	 ASSERT(block_bitmap_idx &gt; <span class="number">0</span>);</span><br><span class="line">	 bitmap_set(&amp;part-&gt;block_bitmap, block_bitmap_idx, <span class="number">0</span>);</span><br><span class="line">	 bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line">      &#125;</span><br><span class="line">      block_idx++; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2 回收该inode所占用的inode */</span></span><br><span class="line">   bitmap_set(&amp;part-&gt;inode_bitmap, inode_no, <span class="number">0</span>);  </span><br><span class="line">   bitmap_sync(cur_part, inode_no, INODE_BITMAP);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/******     以下inode_delete是调试用的    ******</span></span><br><span class="line"><span class="comment">   * 此函数会在inode_table中将此inode清0,</span></span><br><span class="line"><span class="comment">   * 但实际上是不需要的,inode分配是由inode位图控制的,</span></span><br><span class="line"><span class="comment">   * 硬盘上的数据不需要清0,可以直接覆盖*/</span></span><br><span class="line">   <span class="keyword">void</span>* io_buf = sys_malloc(<span class="number">1024</span>);</span><br><span class="line">   inode_delete(part, inode_no, io_buf);</span><br><span class="line">   sys_free(io_buf);</span><br><span class="line">   <span class="comment">/***********************************************/</span></span><br><span class="line">    </span><br><span class="line">   inode_close(inode_to_del);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除目录项部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把分区part目录pdir中编号为inode_no的目录项删除 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_dir_entry</span><span class="params">(struct partition* part, struct dir* pdir, <span class="keyword">uint32_t</span> inode_no, <span class="keyword">void</span>* io_buf)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">dir_inode</span> = <span class="title">pdir</span>-&gt;<span class="title">inode</span>;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_idx = <span class="number">0</span>, all_blocks[<span class="number">140</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="comment">/* 收集目录全部块地址 */</span></span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">12</span>) &#123;</span><br><span class="line">      all_blocks[block_idx] = dir_inode-&gt;i_sectors[block_idx];</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (dir_inode-&gt;i_sectors[<span class="number">12</span>]) &#123;</span><br><span class="line">      ide_read(part-&gt;my_disk, dir_inode-&gt;i_sectors[<span class="number">12</span>], all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 目录项在存储时保证不会跨扇区 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entry_size = part-&gt;sb-&gt;dir_entry_size;</span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entrys_per_sec = (SECTOR_SIZE / dir_entry_size);       <span class="comment">// 每扇区最大的目录项数目</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">dir_e</span> = (<span class="title">struct</span> <span class="title">dir_entry</span>*)<span class="title">io_buf</span>;</span>   </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">dir_entry_found</span> = <span class="title">NULL</span>;</span></span><br><span class="line">   <span class="keyword">uint8_t</span> dir_entry_idx, dir_entry_cnt;</span><br><span class="line">   <span class="keyword">bool</span> is_dir_first_block = <span class="literal">false</span>;     <span class="comment">// 目录的第1个块 </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 遍历所有块,寻找目录项 */</span></span><br><span class="line">   block_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">140</span>) &#123;</span><br><span class="line">      is_dir_first_block = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (all_blocks[block_idx] == <span class="number">0</span>) &#123;</span><br><span class="line">	 block_idx++;</span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      dir_entry_idx = dir_entry_cnt = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, SECTOR_SIZE);</span><br><span class="line">      <span class="comment">/* 读取扇区,获得目录项 */</span></span><br><span class="line">      ide_read(part-&gt;my_disk, all_blocks[block_idx], io_buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 遍历所有的目录项,统计该扇区的目录项数量及是否有待删除的目录项 */</span></span><br><span class="line">      <span class="keyword">while</span> (dir_entry_idx &lt; dir_entrys_per_sec) &#123;</span><br><span class="line">	 <span class="keyword">if</span> ((dir_e + dir_entry_idx)-&gt;f_type != FT_UNKNOWN) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((dir_e + dir_entry_idx)-&gt;filename, <span class="string">"."</span>)) &#123; </span><br><span class="line">	       is_dir_first_block = <span class="literal">true</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>((dir_e + dir_entry_idx)-&gt;filename, <span class="string">"."</span>) &amp;&amp; </span><br><span class="line">	       <span class="built_in">strcmp</span>((dir_e + dir_entry_idx)-&gt;filename, <span class="string">".."</span>)) &#123;</span><br><span class="line">	       dir_entry_cnt++;     <span class="comment">// 统计此扇区内的目录项个数,用来判断删除目录项后是否回收该扇区</span></span><br><span class="line">	       <span class="keyword">if</span> ((dir_e + dir_entry_idx)-&gt;i_no == inode_no) &#123;	  <span class="comment">// 如果找到此i结点,就将其记录在dir_entry_found</span></span><br><span class="line">		  ASSERT(dir_entry_found == <span class="literal">NULL</span>);  <span class="comment">// 确保目录中只有一个编号为inode_no的inode,找到一次后dir_entry_found就不再是NULL</span></span><br><span class="line">		  dir_entry_found = dir_e + dir_entry_idx;</span><br><span class="line">		  <span class="comment">/* 找到后也继续遍历,统计总共的目录项数 */</span></span><br><span class="line">	       &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 dir_entry_idx++;</span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 若此扇区未找到该目录项,继续在下个扇区中找 */</span></span><br><span class="line">      <span class="keyword">if</span> (dir_entry_found == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	 block_idx++;</span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 在此扇区中找到目录项后,清除该目录项并判断是否回收扇区,随后退出循环直接返回 */</span></span><br><span class="line">      ASSERT(dir_entry_cnt &gt;= <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 除目录第1个扇区外,若该扇区上只有该目录项自己,则将整个扇区回收 */</span></span><br><span class="line">      <span class="keyword">if</span> (dir_entry_cnt == <span class="number">1</span> &amp;&amp; !is_dir_first_block) &#123;</span><br><span class="line">	 <span class="comment">/* a 在块位图中回收该块 */</span></span><br><span class="line">	 <span class="keyword">uint32_t</span> block_bitmap_idx = all_blocks[block_idx] - part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	 bitmap_set(&amp;part-&gt;block_bitmap, block_bitmap_idx, <span class="number">0</span>);</span><br><span class="line">	 bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* b 将块地址从数组i_sectors或索引表中去掉 */</span></span><br><span class="line">	 <span class="keyword">if</span> (block_idx &lt; <span class="number">12</span>) &#123;</span><br><span class="line">	    dir_inode-&gt;i_sectors[block_idx] = <span class="number">0</span>;</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 在一级间接索引表中擦除该间接块地址</span></span><br><span class="line">	    <span class="comment">/*先判断一级间接索引表中间接块的数量,如果仅有这1个间接块,连同间接索引表所在的块一同回收 */</span></span><br><span class="line">	    <span class="keyword">uint32_t</span> indirect_blocks = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">uint32_t</span> indirect_block_idx = <span class="number">12</span>;</span><br><span class="line">	    <span class="keyword">while</span> (indirect_block_idx &lt; <span class="number">140</span>) &#123;</span><br><span class="line">	       <span class="keyword">if</span> (all_blocks[indirect_block_idx] != <span class="number">0</span>) &#123;</span><br><span class="line">		  indirect_blocks++;</span><br><span class="line">	       &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    ASSERT(indirect_blocks &gt;= <span class="number">1</span>);  <span class="comment">// 包括当前间接块</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (indirect_blocks &gt; <span class="number">1</span>) &#123;	  <span class="comment">// 间接索引表中还包括其它间接块,仅在索引表中擦除当前这个间接块地址</span></span><br><span class="line">	       all_blocks[block_idx] = <span class="number">0</span>; </span><br><span class="line">	       ide_write(part-&gt;my_disk, dir_inode-&gt;i_sectors[<span class="number">12</span>], all_blocks + <span class="number">12</span>, <span class="number">1</span>); </span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 间接索引表中就当前这1个间接块,直接把间接索引表所在的块回收,然后擦除间接索引表块地址</span></span><br><span class="line">	       <span class="comment">/* 回收间接索引表所在的块 */</span></span><br><span class="line">	       block_bitmap_idx = dir_inode-&gt;i_sectors[<span class="number">12</span>] - part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	       bitmap_set(&amp;part-&gt;block_bitmap, block_bitmap_idx, <span class="number">0</span>);</span><br><span class="line">	       bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line">	       </span><br><span class="line">	       <span class="comment">/* 将间接索引表地址清0 */</span></span><br><span class="line">	       dir_inode-&gt;i_sectors[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 仅将该目录项清空</span></span><br><span class="line">	 <span class="built_in">memset</span>(dir_entry_found, <span class="number">0</span>, dir_entry_size);</span><br><span class="line">	 ide_write(part-&gt;my_disk, all_blocks[block_idx], io_buf, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 更新i结点信息并同步到硬盘 */</span></span><br><span class="line">      ASSERT(dir_inode-&gt;i_size &gt;= dir_entry_size);</span><br><span class="line">      dir_inode-&gt;i_size -= dir_entry_size;</span><br><span class="line">      <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, SECTOR_SIZE * <span class="number">2</span>);</span><br><span class="line">      inode_sync(part, dir_inode, io_buf);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 所有块中未找到则返回false,若出现这种情况应该是serarch_file出错了 */</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是sys_unlink的实现，Linux中删除文件是通过unlink系统调用，原型为<code>int unlink(const char *pathname)</code>，成功删除返回0，否则返回-1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除文件(非目录),成功返回0,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_unlink(<span class="keyword">const</span> <span class="keyword">char</span>* pathname) &#123;</span><br><span class="line">   ASSERT(<span class="built_in">strlen</span>(pathname) &lt; MAX_PATH_LEN);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 先检查待删除的文件是否存在 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">path_search_record</span> <span class="title">searched_record</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;searched_record, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct path_search_record));</span><br><span class="line">   <span class="keyword">int</span> inode_no = search_file(pathname, &amp;searched_record);</span><br><span class="line">   ASSERT(inode_no != <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (inode_no == <span class="number">-1</span>) &#123;</span><br><span class="line">      printk(<span class="string">"file %s not found!\n"</span>, pathname);</span><br><span class="line">      dir_close(searched_record.parent_dir);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (searched_record.file_type == FT_DIRECTORY) &#123;</span><br><span class="line">      printk(<span class="string">"can`t delete a direcotry with unlink(), use rmdir() to instead\n"</span>);</span><br><span class="line">      dir_close(searched_record.parent_dir);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 检查是否在已打开文件列表(文件表)中 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> file_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (file_idx &lt; MAX_FILE_OPEN) &#123;</span><br><span class="line">      <span class="keyword">if</span> (file_table[file_idx].fd_inode != <span class="literal">NULL</span> &amp;&amp; (<span class="keyword">uint32_t</span>)inode_no == file_table[file_idx].fd_inode-&gt;i_no) &#123;</span><br><span class="line">	 <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      file_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (file_idx &lt; MAX_FILE_OPEN) &#123;</span><br><span class="line">      dir_close(searched_record.parent_dir);</span><br><span class="line">      printk(<span class="string">"file %s is in use, not allow to delete!\n"</span>, pathname);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ASSERT(file_idx == MAX_FILE_OPEN);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 为delete_dir_entry申请缓冲区 */</span></span><br><span class="line">   <span class="keyword">void</span>* io_buf = sys_malloc(SECTOR_SIZE + SECTOR_SIZE);</span><br><span class="line">   <span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      dir_close(searched_record.parent_dir);</span><br><span class="line">      printk(<span class="string">"sys_unlink: malloc for io_buf failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">parent_dir</span> = <span class="title">searched_record</span>.<span class="title">parent_dir</span>;</span>  </span><br><span class="line">   delete_dir_entry(cur_part, parent_dir, inode_no, io_buf);</span><br><span class="line">   inode_release(cur_part, inode_no);</span><br><span class="line">   sys_free(io_buf);</span><br><span class="line">   dir_close(searched_record.parent_dir);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 成功删除文件 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在main中测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   process_execute(u_prog_a, <span class="string">"u_prog_a"</span>);</span><br><span class="line">   process_execute(u_prog_b, <span class="string">"u_prog_b"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_a"</span>, <span class="number">31</span>, k_thread_a, <span class="string">"I am thread_a"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_b"</span>, <span class="number">31</span>, k_thread_b, <span class="string">"I am thread_b"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"/file1 delete %s!\n"</span>, sys_unlink(<span class="string">"/file1"</span>) == <span class="number">0</span> ? <span class="string">"done"</span> : <span class="string">"fail"</span>);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/101.png" alt></p>
<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>下面实现sys_mkdir函数创建目录，其原型是<code>int mkdir(const char *pathname,mode_t mode)</code>，所涉及的步骤如下</p>
<ul>
<li>确认待创建的新目录在文件系统上不存在</li>
<li>为新目录创建inode</li>
<li>为新目录分配1个块储存该目录中的目录项</li>
<li>在新目录中创建两个目录项”.”和”..”，这是每个目录都必须存在的两个目录项</li>
<li>在新目录的父目录中添加新目录的目录项</li>
<li>将资源同步到硬盘</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建目录pathname,成功返回0,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_mkdir(<span class="keyword">const</span> <span class="keyword">char</span>* pathname) &#123;</span><br><span class="line">   <span class="keyword">uint8_t</span> rollback_step = <span class="number">0</span>;	       <span class="comment">// 用于操作失败时回滚各资源状态</span></span><br><span class="line">   <span class="keyword">void</span>* io_buf = sys_malloc(SECTOR_SIZE * <span class="number">2</span>);</span><br><span class="line">   <span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"sys_mkdir: sys_malloc for io_buf failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">path_search_record</span> <span class="title">searched_record</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;searched_record, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct path_search_record));</span><br><span class="line">   <span class="keyword">int</span> inode_no = <span class="number">-1</span>;</span><br><span class="line">   inode_no = search_file(pathname, &amp;searched_record);</span><br><span class="line">   <span class="keyword">if</span> (inode_no != <span class="number">-1</span>) &#123;      <span class="comment">// 如果找到了同名目录或文件,失败返回</span></span><br><span class="line">      printk(<span class="string">"sys_mkdir: file or directory %s exist!\n"</span>, pathname);</span><br><span class="line">      rollback_step = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> rollback;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;	     <span class="comment">// 若未找到,也要判断是在最终目录没找到还是某个中间目录不存在</span></span><br><span class="line">      <span class="keyword">uint32_t</span> pathname_depth = path_depth_cnt((<span class="keyword">char</span>*)pathname);</span><br><span class="line">      <span class="keyword">uint32_t</span> path_searched_depth = path_depth_cnt(searched_record.searched_path);</span><br><span class="line">      <span class="comment">/* 先判断是否把pathname的各层目录都访问到了,即是否在某个中间目录就失败了 */</span></span><br><span class="line">      <span class="keyword">if</span> (pathname_depth != path_searched_depth) &#123;   <span class="comment">// 说明并没有访问到全部的路径,某个中间目录是不存在的</span></span><br><span class="line">	 printk(<span class="string">"sys_mkdir: can`t access %s, subpath %s is`t exist\n"</span>, pathname, searched_record.searched_path);</span><br><span class="line">	 rollback_step = <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">goto</span> rollback;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">parent_dir</span> = <span class="title">searched_record</span>.<span class="title">parent_dir</span>;</span></span><br><span class="line">   <span class="comment">/* 目录名称后可能会有字符'/',所以最好直接用searched_record.searched_path,无'/' */</span></span><br><span class="line">   <span class="keyword">char</span>* dirname = <span class="built_in">strrchr</span>(searched_record.searched_path, <span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   inode_no = inode_bitmap_alloc(cur_part); </span><br><span class="line">   <span class="keyword">if</span> (inode_no == <span class="number">-1</span>) &#123;</span><br><span class="line">      printk(<span class="string">"sys_mkdir: allocate inode failed\n"</span>);</span><br><span class="line">      rollback_step = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> rollback;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">new_dir_inode</span>;</span></span><br><span class="line">   inode_init(inode_no, &amp;new_dir_inode);	    <span class="comment">// 初始化i结点</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> block_bitmap_idx = <span class="number">0</span>;     <span class="comment">// 用来记录block对应于block_bitmap中的索引</span></span><br><span class="line">   <span class="keyword">int32_t</span> block_lba = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/* 为目录分配一个块,用来写入目录.和.. */</span></span><br><span class="line">   block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">   <span class="keyword">if</span> (block_lba == <span class="number">-1</span>) &#123;</span><br><span class="line">      printk(<span class="string">"sys_mkdir: block_bitmap_alloc for create directory failed\n"</span>);</span><br><span class="line">      rollback_step = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">goto</span> rollback;</span><br><span class="line">   &#125;</span><br><span class="line">   new_dir_inode.i_sectors[<span class="number">0</span>] = block_lba;</span><br><span class="line">   <span class="comment">/* 每分配一个块就将位图同步到硬盘 */</span></span><br><span class="line">   block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">   ASSERT(block_bitmap_idx != <span class="number">0</span>);</span><br><span class="line">   bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 将当前目录的目录项'.'和'..'写入目录 */</span></span><br><span class="line">   <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, SECTOR_SIZE * <span class="number">2</span>);	 <span class="comment">// 清空io_buf</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">p_de</span> = (<span class="title">struct</span> <span class="title">dir_entry</span>*)<span class="title">io_buf</span>;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 初始化当前目录"." */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(p_de-&gt;filename, <span class="string">"."</span>, <span class="number">1</span>);</span><br><span class="line">   p_de-&gt;i_no = inode_no ;</span><br><span class="line">   p_de-&gt;f_type = FT_DIRECTORY;</span><br><span class="line"></span><br><span class="line">   p_de++;</span><br><span class="line">   <span class="comment">/* 初始化当前目录".." */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(p_de-&gt;filename, <span class="string">".."</span>, <span class="number">2</span>);</span><br><span class="line">   p_de-&gt;i_no = parent_dir-&gt;inode-&gt;i_no;</span><br><span class="line">   p_de-&gt;f_type = FT_DIRECTORY;</span><br><span class="line">   ide_write(cur_part-&gt;my_disk, new_dir_inode.i_sectors[<span class="number">0</span>], io_buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   new_dir_inode.i_size = <span class="number">2</span> * cur_part-&gt;sb-&gt;dir_entry_size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 在父目录中添加自己的目录项 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> <span class="title">new_dir_entry</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;new_dir_entry, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct dir_entry));</span><br><span class="line">   create_dir_entry(dirname, inode_no, FT_DIRECTORY, &amp;new_dir_entry);</span><br><span class="line">   <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, SECTOR_SIZE * <span class="number">2</span>);	 <span class="comment">// 清空io_buf</span></span><br><span class="line">   <span class="keyword">if</span> (!sync_dir_entry(parent_dir, &amp;new_dir_entry, io_buf)) &#123;	  <span class="comment">// sync_dir_entry中将block_bitmap通过bitmap_sync同步到硬盘</span></span><br><span class="line">      printk(<span class="string">"sys_mkdir: sync_dir_entry to disk failed!\n"</span>);</span><br><span class="line">      rollback_step = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">goto</span> rollback;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 父目录的inode同步到硬盘 */</span></span><br><span class="line">   <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, SECTOR_SIZE * <span class="number">2</span>);</span><br><span class="line">   inode_sync(cur_part, parent_dir-&gt;inode, io_buf);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 将新创建目录的inode同步到硬盘 */</span></span><br><span class="line">   <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, SECTOR_SIZE * <span class="number">2</span>);</span><br><span class="line">   inode_sync(cur_part, &amp;new_dir_inode, io_buf);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 将inode位图同步到硬盘 */</span></span><br><span class="line">   bitmap_sync(cur_part, inode_no, INODE_BITMAP);</span><br><span class="line"></span><br><span class="line">   sys_free(io_buf);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 关闭所创建目录的父目录 */</span></span><br><span class="line">   dir_close(searched_record.parent_dir);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建文件或目录需要创建相关的多个资源,若某步失败则会执行到下面的回滚步骤 */</span></span><br><span class="line">rollback:	     <span class="comment">// 因为某步骤操作失败而回滚</span></span><br><span class="line">   <span class="keyword">switch</span> (rollback_step) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	 bitmap_set(&amp;cur_part-&gt;inode_bitmap, inode_no, <span class="number">0</span>);	 <span class="comment">// 如果新文件的inode创建失败,之前位图中分配的inode_no也要恢复 </span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	 <span class="comment">/* 关闭所创建目录的父目录 */</span></span><br><span class="line">	 dir_close(searched_record.parent_dir);</span><br><span class="line">	 <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   sys_free(io_buf);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来进行测试，因为前面删除了file1文件，这里重新创建一个进行测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   process_execute(u_prog_a, <span class="string">"u_prog_a"</span>);</span><br><span class="line">   process_execute(u_prog_b, <span class="string">"u_prog_b"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_a"</span>, <span class="number">31</span>, k_thread_a, <span class="string">"I am thread_a"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_b"</span>, <span class="number">31</span>, k_thread_b, <span class="string">"I am thread_b"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1 create %s!\n"</span>, sys_mkdir(<span class="string">"/dir1/subdir1"</span>) == <span class="number">0</span> ? <span class="string">"done"</span> : <span class="string">"fail"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"/dir1 create %s!\n"</span>, sys_mkdir(<span class="string">"/dir1"</span>) == <span class="number">0</span> ? <span class="string">"done"</span> : <span class="string">"fail"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"now, /dir1/subdir1 create %s!\n"</span>, sys_mkdir(<span class="string">"/dir1/subdir1"</span>) == <span class="number">0</span> ? <span class="string">"done"</span> : <span class="string">"fail"</span>);</span><br><span class="line">   <span class="keyword">int</span> fd = sys_open(<span class="string">"/dir1/subdir1/file2"</span>, O_CREAT|O_RDWR);</span><br><span class="line">   <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1/file2 create done!\n"</span>);</span><br><span class="line">      sys_write(fd, <span class="string">"Catch me if you can!\n"</span>, <span class="number">21</span>);</span><br><span class="line">      sys_lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">      <span class="keyword">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      sys_read(fd, buf, <span class="number">21</span>); </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1/file2 says:\n%s"</span>, buf);</span><br><span class="line">      sys_close(fd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/102.png" alt></p>
<h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><p>遍历目录的原型是opendir和closedir，本质是读取目录中所有的目录项，先打开目录然后遍历，最后关闭目录。下面是sys_opendir和sys_closedir的实现部分，根目录只是简单处理”/.”和”/..”的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 目录打开成功后返回目录指针,失败返回NULL */</span></span><br><span class="line"><span class="function">struct dir* <span class="title">sys_opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">   ASSERT(<span class="built_in">strlen</span>(name) &lt; MAX_PATH_LEN);</span><br><span class="line">   <span class="comment">/* 如果是根目录'/',直接返回&amp;root_dir */</span></span><br><span class="line">   <span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="string">'/'</span> &amp;&amp; (name[<span class="number">1</span>] == <span class="number">0</span> || name[<span class="number">0</span>] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;root_dir;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 先检查待打开的目录是否存在 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">path_search_record</span> <span class="title">searched_record</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;searched_record, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct path_search_record));</span><br><span class="line">   <span class="keyword">int</span> inode_no = search_file(name, &amp;searched_record);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">ret</span> = <span class="title">NULL</span>;</span></span><br><span class="line">   <span class="keyword">if</span> (inode_no == <span class="number">-1</span>) &#123;	 <span class="comment">// 如果找不到目录,提示不存在的路径 </span></span><br><span class="line">      printk(<span class="string">"In %s, sub path %s not exist\n"</span>, name, searched_record.searched_path); </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (searched_record.file_type == FT_REGULAR) &#123;</span><br><span class="line">	 printk(<span class="string">"%s is regular file!\n"</span>, name);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searched_record.file_type == FT_DIRECTORY) &#123;</span><br><span class="line">	 ret = dir_open(cur_part, inode_no);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   dir_close(searched_record.parent_dir);</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功关闭目录dir返回0,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_closedir(struct dir* dir) &#123;</span><br><span class="line">   <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span> (dir != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      dir_close(dir);</span><br><span class="line">      ret = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面简单测试一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   process_execute(u_prog_a, <span class="string">"u_prog_a"</span>);</span><br><span class="line">   process_execute(u_prog_b, <span class="string">"u_prog_b"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_a"</span>, <span class="number">31</span>, k_thread_a, <span class="string">"I am thread_a"</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_b"</span>, <span class="number">31</span>, k_thread_b, <span class="string">"I am thread_b"</span>);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">p_dir</span> = <span class="title">sys_opendir</span>("/<span class="title">dir1</span>/<span class="title">subdir1</span>");</span></span><br><span class="line">   <span class="keyword">if</span> (p_dir) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1 open done!\n"</span>);</span><br><span class="line">      <span class="keyword">if</span> (sys_closedir(p_dir) == <span class="number">0</span>) &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1 close done!\n"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1 close fail!\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1 open fail!\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/103.png" alt></p>
<p>我们的目的是遍历目录，我们已经实现了第一步打开和关闭，接下来实现读取目录函数readdir，读取目录的本质是读取目录中的目录项，readdir每次返回目录的一个目录项地址，遍历目录需要循环调用readdir函数，下面是具体实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 读取目录,成功返回1个目录项,失败返回NULL */</span></span><br><span class="line"><span class="function">struct dir_entry* <span class="title">dir_read</span><span class="params">(struct dir* dir)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">dir_e</span> = (<span class="title">struct</span> <span class="title">dir_entry</span>*)<span class="title">dir</span>-&gt;<span class="title">dir_buf</span>;</span> <span class="comment">// 存储目录项</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">dir_inode</span> = <span class="title">dir</span>-&gt;<span class="title">inode</span>;</span> </span><br><span class="line">   <span class="keyword">uint32_t</span> all_blocks[<span class="number">140</span>] = &#123;<span class="number">0</span>&#125;, block_cnt = <span class="number">12</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> block_idx = <span class="number">0</span>, dir_entry_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">12</span>) &#123;</span><br><span class="line">      all_blocks[block_idx] = dir_inode-&gt;i_sectors[block_idx];</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (dir_inode-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>) &#123;	     <span class="comment">// 若含有一级间接块表</span></span><br><span class="line">      ide_read(cur_part-&gt;my_disk, dir_inode-&gt;i_sectors[<span class="number">12</span>], all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">      block_cnt = <span class="number">140</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   block_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> cur_dir_entry_pos = <span class="number">0</span>;	  <span class="comment">// 当前目录项的偏移,此项用来判断是否是之前已经返回过的目录项</span></span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entry_size = cur_part-&gt;sb-&gt;dir_entry_size;</span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entrys_per_sec = SECTOR_SIZE / dir_entry_size;	 <span class="comment">// 1扇区内可容纳的目录项个数</span></span><br><span class="line">   <span class="comment">/* 因为此目录内可能删除了某些文件或子目录,所以要遍历所有块 */</span></span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; block_cnt) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dir-&gt;dir_pos &gt;= dir_inode-&gt;i_size) &#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (all_blocks[block_idx] == <span class="number">0</span>) &#123;     <span class="comment">// 如果此块地址为0,即空块,继续读出下一块</span></span><br><span class="line">	 block_idx++;</span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memset</span>(dir_e, <span class="number">0</span>, SECTOR_SIZE);</span><br><span class="line">      ide_read(cur_part-&gt;my_disk, all_blocks[block_idx], dir_e, <span class="number">1</span>);</span><br><span class="line">      dir_entry_idx = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/* 遍历扇区内所有目录项 */</span></span><br><span class="line">      <span class="keyword">while</span> (dir_entry_idx &lt; dir_entrys_per_sec) &#123;</span><br><span class="line">	 <span class="keyword">if</span> ((dir_e + dir_entry_idx)-&gt;f_type) &#123;	 <span class="comment">// 如果f_type不等于0,即不等于FT_UNKNOWN</span></span><br><span class="line">	    <span class="comment">/* 判断是不是最新的目录项,避免返回曾经已经返回过的目录项 */</span></span><br><span class="line">	    <span class="keyword">if</span> (cur_dir_entry_pos &lt; dir-&gt;dir_pos) &#123;</span><br><span class="line">	       cur_dir_entry_pos += dir_entry_size;</span><br><span class="line">	       dir_entry_idx++;</span><br><span class="line">	       <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    ASSERT(cur_dir_entry_pos == dir-&gt;dir_pos);</span><br><span class="line">	    dir-&gt;dir_pos += dir_entry_size;	      <span class="comment">// 更新为新位置,即下一个返回的目录项地址</span></span><br><span class="line">	    <span class="keyword">return</span> dir_e + dir_entry_idx; </span><br><span class="line">	 &#125;</span><br><span class="line">	 dir_entry_idx++;</span><br><span class="line">      &#125;</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现sys-readdir及sys-rewinddir"><a href="#实现sys-readdir及sys-rewinddir" class="headerlink" title="实现sys_readdir及sys_rewinddir"></a>实现sys_readdir及sys_rewinddir</h2><p>readdir原型是<code>struct dirent *readdir(DIR *dirp)</code>，我们也是根据此接口进行实现。在遍历目录的时候我们需要用到目录回绕的功能，使目录的游标dir_pos回到0，他与lseek类似，这里我们用rewinddir实现，其原型是<code>void rewinddir(DIR *dirp)</code>，下面是系统调用的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 读取目录dir的1个目录项,成功后返回其目录项地址,到目录尾时或出错时返回NULL */</span></span><br><span class="line"><span class="function">struct dir_entry* <span class="title">sys_readdir</span><span class="params">(struct dir* dir)</span> </span>&#123;</span><br><span class="line">   ASSERT(dir != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> dir_read(dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把目录dir的指针dir_pos置0 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_rewinddir</span><span class="params">(struct dir* dir)</span> </span>&#123;</span><br><span class="line">   dir-&gt;dir_pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面测试一下，首先打开目录’/dir1/subdir1’，然后输出目录内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line"><span class="comment">/********  测试代码  ********/</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">p_dir</span> = <span class="title">sys_opendir</span>("/<span class="title">dir1</span>/<span class="title">subdir1</span>");</span></span><br><span class="line">   <span class="keyword">if</span> (p_dir) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1 open done!\ncontent:\n"</span>);</span><br><span class="line">      <span class="keyword">char</span>* type = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">dir_e</span> = <span class="title">NULL</span>;</span></span><br><span class="line">      <span class="keyword">while</span>((dir_e = sys_readdir(p_dir))) &#123; </span><br><span class="line">	 <span class="keyword">if</span> (dir_e-&gt;f_type == FT_REGULAR) &#123;</span><br><span class="line">	    type = <span class="string">"regular"</span>;</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    type = <span class="string">"directory"</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"      %s   %s\n"</span>, type, dir_e-&gt;filename);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sys_closedir(p_dir) == <span class="number">0</span>) &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1 close done!\n"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1 close fail!\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1 open fail!\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/********  测试代码  ********/</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下所示</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/104.png" alt></p>
<h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><p>在删除目录的时候目录非空的话应有提示，故我们需要在删除目录时先判断目录是否为空，不允许删除非空目录，我们继续改进dir文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 判断目录是否为空 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dir_is_empty</span><span class="params">(struct dir* dir)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">dir_inode</span> = <span class="title">dir</span>-&gt;<span class="title">inode</span>;</span></span><br><span class="line">   <span class="comment">/* 若目录下只有.和..这两个目录项则目录为空 */</span></span><br><span class="line">   <span class="keyword">return</span> (dir_inode-&gt;i_size == cur_part-&gt;sb-&gt;dir_entry_size * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在父目录parent_dir中删除child_dir */</span></span><br><span class="line"><span class="keyword">int32_t</span> dir_remove(struct dir* parent_dir, struct dir* child_dir) &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">child_dir_inode</span>  = <span class="title">child_dir</span>-&gt;<span class="title">inode</span>;</span></span><br><span class="line">   <span class="comment">/* 空目录只在inode-&gt;i_sectors[0]中有扇区,其它扇区都应该为空 */</span></span><br><span class="line">   <span class="keyword">int32_t</span> block_idx = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">13</span>) &#123;</span><br><span class="line">      ASSERT(child_dir_inode-&gt;i_sectors[block_idx] == <span class="number">0</span>);</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">void</span>* io_buf = sys_malloc(SECTOR_SIZE * <span class="number">2</span>);</span><br><span class="line">   <span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"dir_remove: malloc for io_buf failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 在父目录parent_dir中删除子目录child_dir对应的目录项 */</span></span><br><span class="line">   delete_dir_entry(cur_part, parent_dir, child_dir_inode-&gt;i_no, io_buf);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 回收inode中i_secotrs中所占用的扇区,并同步inode_bitmap和block_bitmap */</span></span><br><span class="line">   inode_release(cur_part, child_dir_inode-&gt;i_no);</span><br><span class="line">   sys_free(io_buf);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面实现sys_rmdir，其原型是<code>int rmdir(const char *pathname)</code>，首先判断待删除文件是否存在，然后在进行删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除空目录,成功时返回0,失败时返回-1*/</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_rmdir(<span class="keyword">const</span> <span class="keyword">char</span>* pathname) &#123;</span><br><span class="line">   <span class="comment">/* 先检查待删除的文件是否存在 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">path_search_record</span> <span class="title">searched_record</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;searched_record, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct path_search_record));</span><br><span class="line">   <span class="keyword">int</span> inode_no = search_file(pathname, &amp;searched_record);</span><br><span class="line">   ASSERT(inode_no != <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">int</span> retval = <span class="number">-1</span>;	<span class="comment">// 默认返回值</span></span><br><span class="line">   <span class="keyword">if</span> (inode_no == <span class="number">-1</span>) &#123;</span><br><span class="line">      printk(<span class="string">"In %s, sub path %s not exist\n"</span>, pathname, searched_record.searched_path); </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (searched_record.file_type == FT_REGULAR) &#123;</span><br><span class="line">	 printk(<span class="string">"%s is regular file!\n"</span>, pathname);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">	 struct dir* dir = dir_open(cur_part, inode_no);</span><br><span class="line">	 <span class="keyword">if</span> (!dir_is_empty(dir)) &#123;	 <span class="comment">// 非空目录不可删除</span></span><br><span class="line">	    printk(<span class="string">"dir %s is not empty, it is not allowed to delete a nonempty directory!\n"</span>, pathname);</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (!dir_remove(searched_record.parent_dir, dir)) &#123;</span><br><span class="line">	       retval = <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 dir_close(dir);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   dir_close(searched_record.parent_dir);</span><br><span class="line">   <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面继续测试，测试代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line"><span class="comment">/********  测试代码  ********/</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"/dir1 content before delete /dir1/subdir1:\n"</span>);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">dir</span> = <span class="title">sys_opendir</span>("/<span class="title">dir1</span>/");</span></span><br><span class="line">   <span class="keyword">char</span>* type = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">dir_e</span> = <span class="title">NULL</span>;</span></span><br><span class="line">   <span class="keyword">while</span>((dir_e = sys_readdir(dir))) &#123; </span><br><span class="line">      <span class="keyword">if</span> (dir_e-&gt;f_type == FT_REGULAR) &#123;</span><br><span class="line">	 type = <span class="string">"regular"</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 type = <span class="string">"directory"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"      %s   %s\n"</span>, type, dir_e-&gt;filename);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"try to delete nonempty directory /dir1/subdir1\n"</span>);</span><br><span class="line">   <span class="keyword">if</span> (sys_rmdir(<span class="string">"/dir1/subdir1"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"sys_rmdir: /dir1/subdir1 delete fail!\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"try to delete /dir1/subdir1/file2\n"</span>);</span><br><span class="line">   <span class="keyword">if</span> (sys_rmdir(<span class="string">"/dir1/subdir1/file2"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"sys_rmdir: /dir1/subdir1/file2 delete fail!\n"</span>);</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span> (sys_unlink(<span class="string">"/dir1/subdir1/file2"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"sys_unlink: /dir1/subdir1/file2 delete done\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"try to delete directory /dir1/subdir1 again\n"</span>);</span><br><span class="line">   <span class="keyword">if</span> (sys_rmdir(<span class="string">"/dir1/subdir1"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"/dir1/subdir1 delete done!\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"/dir1 content after delete /dir1/subdir1:\n"</span>);</span><br><span class="line">   sys_rewinddir(dir);</span><br><span class="line">   <span class="keyword">while</span>((dir_e = sys_readdir(dir))) &#123; </span><br><span class="line">      <span class="keyword">if</span> (dir_e-&gt;f_type == FT_REGULAR) &#123;</span><br><span class="line">	 type = <span class="string">"regular"</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 type = <span class="string">"directory"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"      %s   %s\n"</span>, type, dir_e-&gt;filename);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********  测试代码  ********/</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下，目前根目录存在file1文件和目录dir1，dir1存在subdir1，subbdir1中存在file2，先直接删除/dir1/subdir1目录，因为目录非空会失败，接下来通过sys_rmdir和sys_unlink分别删除/dir1/subdir1/file2，最后删除/dir1/subdir1，然后再次输出/dir1内容</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/105.png" alt></p>
<h2 id="任务工作目录"><a href="#任务工作目录" class="headerlink" title="任务工作目录"></a>任务工作目录</h2><p>接下来我们需要实现Linux中的pwd功能，显示当前工作目录和cd切换目录的功能。其中重点是”..”获取父目录，我们循环使用获取父目录的函数，直到获取到根目录为止就可以获取到绝对路径，下面逐步实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获得父目录的inode编号 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint32_t <span class="title">get_parent_dir_inode_nr</span><span class="params">(<span class="keyword">uint32_t</span> child_inode_nr, <span class="keyword">void</span>* io_buf)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">child_dir_inode</span> = <span class="title">inode_open</span>(<span class="title">cur_part</span>, <span class="title">child_inode_nr</span>);</span></span><br><span class="line">   <span class="comment">/* 目录中的目录项".."中包括父目录inode编号,".."位于目录的第0块 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_lba = child_dir_inode-&gt;i_sectors[<span class="number">0</span>];</span><br><span class="line">   ASSERT(block_lba &gt;= cur_part-&gt;sb-&gt;data_start_lba);</span><br><span class="line">   inode_close(child_dir_inode);</span><br><span class="line">   ide_read(cur_part-&gt;my_disk, block_lba, io_buf, <span class="number">1</span>);   </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">dir_e</span> = (<span class="title">struct</span> <span class="title">dir_entry</span>*)<span class="title">io_buf</span>;</span></span><br><span class="line">   <span class="comment">/* 第0个目录项是".",第1个目录项是".." */</span></span><br><span class="line">   ASSERT(dir_e[<span class="number">1</span>].i_no &lt; <span class="number">4096</span> &amp;&amp; dir_e[<span class="number">1</span>].f_type == FT_DIRECTORY);</span><br><span class="line">   <span class="keyword">return</span> dir_e[<span class="number">1</span>].i_no;      <span class="comment">// 返回..即父目录的inode编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在inode编号为p_inode_nr的目录中查找inode编号为c_inode_nr的子目录的名字,</span></span><br><span class="line"><span class="comment"> * 将名字存入缓冲区path.成功返回0,失败返-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_child_dir_name</span><span class="params">(<span class="keyword">uint32_t</span> p_inode_nr, <span class="keyword">uint32_t</span> c_inode_nr, <span class="keyword">char</span>* path, <span class="keyword">void</span>* io_buf)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">parent_dir_inode</span> = <span class="title">inode_open</span>(<span class="title">cur_part</span>, <span class="title">p_inode_nr</span>);</span></span><br><span class="line">   <span class="comment">/* 填充all_blocks,将该目录的所占扇区地址全部写入all_blocks */</span></span><br><span class="line">   <span class="keyword">uint8_t</span> block_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> all_blocks[<span class="number">140</span>] = &#123;<span class="number">0</span>&#125;, block_cnt = <span class="number">12</span>;</span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">12</span>) &#123;</span><br><span class="line">      all_blocks[block_idx] = parent_dir_inode-&gt;i_sectors[block_idx];</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (parent_dir_inode-&gt;i_sectors[<span class="number">12</span>]) &#123;	<span class="comment">// 若包含了一级间接块表,将共读入all_blocks.</span></span><br><span class="line">      ide_read(cur_part-&gt;my_disk, parent_dir_inode-&gt;i_sectors[<span class="number">12</span>], all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">      block_cnt = <span class="number">140</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   inode_close(parent_dir_inode);</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">dir_e</span> = (<span class="title">struct</span> <span class="title">dir_entry</span>*)<span class="title">io_buf</span>;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entry_size = cur_part-&gt;sb-&gt;dir_entry_size;</span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entrys_per_sec = (<span class="number">512</span> / dir_entry_size);</span><br><span class="line">   block_idx = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* 遍历所有块 */</span></span><br><span class="line">   <span class="keyword">while</span>(block_idx &lt; block_cnt) &#123;</span><br><span class="line">      <span class="keyword">if</span>(all_blocks[block_idx]) &#123;      <span class="comment">// 如果相应块不为空则读入相应块</span></span><br><span class="line">	 ide_read(cur_part-&gt;my_disk, all_blocks[block_idx], io_buf, <span class="number">1</span>);</span><br><span class="line">	 <span class="keyword">uint8_t</span> dir_e_idx = <span class="number">0</span>;</span><br><span class="line">	 <span class="comment">/* 遍历每个目录项 */</span></span><br><span class="line">	 <span class="keyword">while</span>(dir_e_idx &lt; dir_entrys_per_sec) &#123;</span><br><span class="line">	    <span class="keyword">if</span> ((dir_e + dir_e_idx)-&gt;i_no == c_inode_nr) &#123;</span><br><span class="line">	       <span class="built_in">strcat</span>(path, <span class="string">"/"</span>);</span><br><span class="line">	       <span class="built_in">strcat</span>(path, (dir_e + dir_e_idx)-&gt;filename);</span><br><span class="line">	       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    dir_e_idx++;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是sys_getcwd的实现，其原型是<code>char *getcwd(char *buf, size_t size)</code>，buf若用户不提供就传入NULL，系统用malloc自动分配缓冲区，具体实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把当前工作目录绝对路径写入buf, size是buf的大小. </span></span><br><span class="line"><span class="comment"> 当buf为NULL时,由操作系统分配存储工作路径的空间并返回地址</span></span><br><span class="line"><span class="comment"> 失败则返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">sys_getcwd</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 确保buf不为空,若用户进程提供的buf为NULL,</span></span><br><span class="line"><span class="comment">   系统调用getcwd中要为用户进程通过malloc分配内存 */</span></span><br><span class="line">   ASSERT(buf != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">void</span>* io_buf = sys_malloc(SECTOR_SIZE);</span><br><span class="line">   <span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur_thread</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">   <span class="keyword">int32_t</span> parent_inode_nr = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int32_t</span> child_inode_nr = cur_thread-&gt;cwd_inode_nr;</span><br><span class="line">   ASSERT(child_inode_nr &gt;= <span class="number">0</span> &amp;&amp; child_inode_nr &lt; <span class="number">4096</span>);      <span class="comment">// 最大支持4096个inode</span></span><br><span class="line">   <span class="comment">/* 若当前目录是根目录,直接返回'/' */</span></span><br><span class="line">   <span class="keyword">if</span> (child_inode_nr == <span class="number">0</span>) &#123;</span><br><span class="line">      buf[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">      buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> buf;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0</span>, size);</span><br><span class="line">   <span class="keyword">char</span> full_path_reverse[MAX_PATH_LEN] = &#123;<span class="number">0</span>&#125;;	  <span class="comment">// 用来做全路径缓冲区</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 从下往上逐层找父目录,直到找到根目录为止.</span></span><br><span class="line"><span class="comment">    * 当child_inode_nr为根目录的inode编号(0)时停止,</span></span><br><span class="line"><span class="comment">    * 即已经查看完根目录中的目录项 */</span></span><br><span class="line">   <span class="keyword">while</span> ((child_inode_nr)) &#123;</span><br><span class="line">      parent_inode_nr = get_parent_dir_inode_nr(child_inode_nr, io_buf);</span><br><span class="line">      <span class="keyword">if</span> (get_child_dir_name(parent_inode_nr, child_inode_nr, full_path_reverse, io_buf) == <span class="number">-1</span>) &#123;	  <span class="comment">// 或未找到名字,失败退出</span></span><br><span class="line">	 sys_free(io_buf);</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      child_inode_nr = parent_inode_nr;</span><br><span class="line">   &#125;</span><br><span class="line">   ASSERT(<span class="built_in">strlen</span>(full_path_reverse) &lt;= size);</span><br><span class="line"><span class="comment">/* 至此full_path_reverse中的路径是反着的,</span></span><br><span class="line"><span class="comment"> * 即子目录在前(左),父目录在后(右) ,</span></span><br><span class="line"><span class="comment"> * 现将full_path_reverse中的路径反置 */</span></span><br><span class="line">   <span class="keyword">char</span>* last_slash;	<span class="comment">// 用于记录字符串中最后一个斜杠地址</span></span><br><span class="line">   <span class="keyword">while</span> ((last_slash = <span class="built_in">strrchr</span>(full_path_reverse, <span class="string">'/'</span>))) &#123;</span><br><span class="line">      <span class="keyword">uint16_t</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">      <span class="built_in">strcpy</span>(buf + len, last_slash);</span><br><span class="line">      <span class="comment">/* 在full_path_reverse中添加结束字符,做为下一次执行strcpy中last_slash的边界 */</span></span><br><span class="line">      *last_slash = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   sys_free(io_buf);</span><br><span class="line">   <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Linux中采用chdir改变当前工作目录，原型是<code>int chdir(const char *path)</code>，我们先实现接口sys_chdir</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 更改当前工作目录为绝对路径path,成功则返回0,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_chdir(<span class="keyword">const</span> <span class="keyword">char</span>* path) &#123;</span><br><span class="line">   <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">path_search_record</span> <span class="title">searched_record</span>;</span>  </span><br><span class="line">   <span class="built_in">memset</span>(&amp;searched_record, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct path_search_record));</span><br><span class="line">   <span class="keyword">int</span> inode_no = search_file(path, &amp;searched_record);</span><br><span class="line">   <span class="keyword">if</span> (inode_no != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (searched_record.file_type == FT_DIRECTORY) &#123;</span><br><span class="line">	 running_thread()-&gt;cwd_inode_nr = inode_no;</span><br><span class="line">	 ret = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 printk(<span class="string">"sys_chdir: %s is regular file or other!\n"</span>, path);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   dir_close(searched_record.parent_dir); </span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务工作目录记录在PCB中的cwd_incode_nr中，修改工作目录的核心即修改cwd_incode_nr，接下来在main中进行测试，首先获取当前工作目录并输出，然后将目录改为/dir1，最后再次获得目录并输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line"><span class="comment">/********  测试代码  ********/</span></span><br><span class="line">   <span class="keyword">char</span> cwd_buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   sys_getcwd(cwd_buf, <span class="number">32</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"cwd:%s\n"</span>, cwd_buf);</span><br><span class="line">   sys_chdir(<span class="string">"/dir1"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"change cwd now\n"</span>);</span><br><span class="line">   sys_getcwd(cwd_buf, <span class="number">32</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"cwd:%s\n"</span>, cwd_buf);</span><br><span class="line"><span class="comment">/********  测试代码  ********/</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/106.png" alt></p>
<h2 id="获得文件属性"><a href="#获得文件属性" class="headerlink" title="获得文件属性"></a>获得文件属性</h2><p>在Linux中输入ls -l命令查看目录的时候不仅显示目录中文件，还显示了属性信息，其底层实现是反复使用系统调用write和stat64，其中stat64负责获得文件的属性信息，是64位版本的stat函数，write负责打印信息到屏幕，首先我们需要实现sys_stat，结构体添加如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件属性结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> st_ino;		 <span class="comment">// inode编号</span></span><br><span class="line">   <span class="keyword">uint32_t</span> st_size;		 <span class="comment">// 尺寸c</span></span><br><span class="line">   <span class="keyword">enum</span> file_types st_filetype;	 <span class="comment">// 文件类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是具体实现，首先path判断是否为根目录，如果是就直接在buf中写入根目录信息，若不是则进一步获取信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在buf中填充文件结构相关信息,成功时返回0,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_stat(<span class="keyword">const</span> <span class="keyword">char</span>* path, struct stat* buf) &#123;</span><br><span class="line">   <span class="comment">/* 若直接查看根目录'/' */</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(path, <span class="string">"/"</span>) || !<span class="built_in">strcmp</span>(path, <span class="string">"/."</span>) || !<span class="built_in">strcmp</span>(path, <span class="string">"/.."</span>)) &#123;</span><br><span class="line">      buf-&gt;st_filetype = FT_DIRECTORY;</span><br><span class="line">      buf-&gt;st_ino = <span class="number">0</span>;</span><br><span class="line">      buf-&gt;st_size = root_dir.inode-&gt;i_size;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;	<span class="comment">// 默认返回值</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">path_search_record</span> <span class="title">searched_record</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;searched_record, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct path_search_record));   <span class="comment">// 记得初始化或清0,否则栈中信息不知道是什么</span></span><br><span class="line">   <span class="keyword">int</span> inode_no = search_file(path, &amp;searched_record);</span><br><span class="line">   <span class="keyword">if</span> (inode_no != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">obj_inode</span> = <span class="title">inode_open</span>(<span class="title">cur_part</span>, <span class="title">inode_no</span>);</span>   <span class="comment">// 只为获得文件大小</span></span><br><span class="line">      buf-&gt;st_size = obj_inode-&gt;i_size;</span><br><span class="line">      inode_close(obj_inode);</span><br><span class="line">      buf-&gt;st_filetype = searched_record.file_type;</span><br><span class="line">      buf-&gt;st_ino = inode_no;</span><br><span class="line">      ret = <span class="number">0</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      printk(<span class="string">"sys_stat: %s not found\n"</span>, path);</span><br><span class="line">   &#125;</span><br><span class="line">   dir_close(searched_record.parent_dir);</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在main中测试，分别获取根目录和/dir目录的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line"><span class="comment">/********  测试代码  ********/</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">obj_stat</span>;</span></span><br><span class="line">   sys_stat(<span class="string">"/"</span>, &amp;obj_stat);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"/`s info\n   i_no:%d\n   size:%d\n   filetype:%s\n"</span>, \</span><br><span class="line">	 obj_stat.st_ino, obj_stat.st_size, \</span><br><span class="line">	 obj_stat.st_filetype == <span class="number">2</span> ? <span class="string">"directory"</span> : <span class="string">"regular"</span>);</span><br><span class="line">   sys_stat(<span class="string">"/dir1"</span>, &amp;obj_stat);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"/dir1`s info\n   i_no:%d\n   size:%d\n   filetype:%s\n"</span>, \</span><br><span class="line">	 obj_stat.st_ino, obj_stat.st_size, \</span><br><span class="line">	 obj_stat.st_filetype == <span class="number">2</span> ? <span class="string">"directory"</span> : <span class="string">"regular"</span>);</span><br><span class="line"><span class="comment">/********  测试代码  ********/</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/107.png" alt></p>
<h1 id="系统交互"><a href="#系统交互" class="headerlink" title="系统交互"></a>系统交互</h1><h2 id="fork的原理"><a href="#fork的原理" class="headerlink" title="fork的原理"></a>fork的原理</h2><p>fork原型是<code>pid_t fork(void)</code>，我们首先测试一段代码，观察其性质</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am father, my pid is %d\n"</span>, getpid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am child, my pid is %d\n"</span>, getpid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是与运行结果，你会发现if和else分支都执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am father, my pid is 103461</span><br><span class="line">I am child, my pid is 103462</span><br></pre></td></tr></table></figure>
<p>fork的作用是克隆进程，它有三个返回值</p>
<ul>
<li>该进程为父进程时，返回子进程的pid</li>
<li>该进程为子进程时，返回0</li>
<li>fork执行失败，返回-1</li>
</ul>
<p>进程是运行的程序，比如程序a运行变成了进程a，同时又加载了一次程序a到内存，就有两个一模一样的程序体，但用户输入不同，就会有不同的执行分支。总结来说fork就是克隆进程，克隆的进程称为子进程，和父进程的区别就是子进程是在fork返回之后开始执行的，上例fork之后子进程和父进程的下一个执行语句都为<code>if (pid == -1)</code></p>
<h2 id="fork的实现"><a href="#fork的实现" class="headerlink" title="fork的实现"></a>fork的实现</h2><p>fork就是把某个进程的全部资源复制了一份，然后让处理器的cs:eip寄存器指向新进程的指令部分，故fork需要先复制资源，然后跳过去执行，复制的资源包括</p>
<ul>
<li>进程的PCB</li>
<li>程序体</li>
<li>用户栈</li>
<li>内核栈</li>
<li>虚拟地址池</li>
<li>页表</li>
</ul>
<p>克隆进程的执行只需要将其放入就绪队列即可，下面是一些拷贝操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将父进程的pcb、虚拟地址位图拷贝给子进程 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">copy_pcb_vaddrbitmap_stack0</span><span class="params">(struct task_struct* child_thread, struct task_struct* parent_thread)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* a 复制pcb所在的整个页,里面包含进程pcb信息及特级0极的栈,里面包含了返回地址, 然后再单独修改个别部分 */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(child_thread, parent_thread, PG_SIZE);</span><br><span class="line">   child_thread-&gt;pid = fork_pid();</span><br><span class="line">   child_thread-&gt;elapsed_ticks = <span class="number">0</span>;</span><br><span class="line">   child_thread-&gt;status = TASK_READY;</span><br><span class="line">   child_thread-&gt;ticks = child_thread-&gt;priority;   <span class="comment">// 为新进程把时间片充满</span></span><br><span class="line">   child_thread-&gt;parent_pid = parent_thread-&gt;pid;</span><br><span class="line">   child_thread-&gt;general_tag.prev = child_thread-&gt;general_tag.next = <span class="literal">NULL</span>;</span><br><span class="line">   child_thread-&gt;all_list_tag.prev = child_thread-&gt;all_list_tag.next = <span class="literal">NULL</span>;</span><br><span class="line">   block_desc_init(child_thread-&gt;u_block_desc);</span><br><span class="line"><span class="comment">/* b 复制父进程的虚拟地址池的位图 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> bitmap_pg_cnt = DIV_ROUND_UP((<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span> , PG_SIZE);</span><br><span class="line">   <span class="keyword">void</span>* vaddr_btmp = get_kernel_pages(bitmap_pg_cnt);</span><br><span class="line">   <span class="keyword">if</span> (vaddr_btmp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="comment">/* 此时child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits还是指向父进程虚拟地址的位图地址</span></span><br><span class="line"><span class="comment">    * 下面将child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits指向自己的位图vaddr_btmp */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(vaddr_btmp, child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits, bitmap_pg_cnt * PG_SIZE);</span><br><span class="line">   child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits = vaddr_btmp;</span><br><span class="line">   <span class="comment">/* 调试用 */</span></span><br><span class="line">   ASSERT(<span class="built_in">strlen</span>(child_thread-&gt;name) &lt; <span class="number">11</span>);	<span class="comment">// pcb.name的长度是16,为避免下面strcat越界</span></span><br><span class="line">   <span class="built_in">strcat</span>(child_thread-&gt;name,<span class="string">"_fork"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复制子进程的进程体(代码和数据)及用户栈 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_body_stack3</span><span class="params">(struct task_struct* child_thread, struct task_struct* parent_thread, <span class="keyword">void</span>* buf_page)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint8_t</span>* vaddr_btmp = parent_thread-&gt;userprog_vaddr.vaddr_bitmap.bits;</span><br><span class="line">   <span class="keyword">uint32_t</span> btmp_bytes_len = parent_thread-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len;</span><br><span class="line">   <span class="keyword">uint32_t</span> vaddr_start = parent_thread-&gt;userprog_vaddr.vaddr_start;</span><br><span class="line">   <span class="keyword">uint32_t</span> idx_byte = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> prog_vaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 在父进程的用户空间中查找已有数据的页 */</span></span><br><span class="line">   <span class="keyword">while</span> (idx_byte &lt; btmp_bytes_len) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vaddr_btmp[idx_byte]) &#123;</span><br><span class="line">	 idx_bit = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">while</span> (idx_bit &lt; <span class="number">8</span>) &#123;</span><br><span class="line">	    <span class="keyword">if</span> ((BITMAP_MASK &lt;&lt; idx_bit) &amp; vaddr_btmp[idx_byte]) &#123;</span><br><span class="line">	       prog_vaddr = (idx_byte * <span class="number">8</span> + idx_bit) * PG_SIZE + vaddr_start;</span><br><span class="line">	 <span class="comment">/* 下面的操作是将父进程用户空间中的数据通过内核空间做中转,最终复制到子进程的用户空间 */</span></span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* a 将父进程在用户空间中的数据复制到内核缓冲区buf_page,</span></span><br><span class="line"><span class="comment">	       目的是下面切换到子进程的页表后,还能访问到父进程的数据*/</span></span><br><span class="line">	       <span class="built_in">memcpy</span>(buf_page, (<span class="keyword">void</span>*)prog_vaddr, PG_SIZE);</span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* b 将页表切换到子进程,目的是避免下面申请内存的函数将pte及pde安装在父进程的页表中 */</span></span><br><span class="line">	       page_dir_activate(child_thread);</span><br><span class="line">	       <span class="comment">/* c 申请虚拟地址prog_vaddr */</span></span><br><span class="line">	       get_a_page_without_opvaddrbitmap(PF_USER, prog_vaddr);</span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* d 从内核缓冲区中将父进程数据复制到子进程的用户空间 */</span></span><br><span class="line">	       <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)prog_vaddr, buf_page, PG_SIZE);</span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* e 恢复父进程页表 */</span></span><br><span class="line">	       page_dir_activate(parent_thread);</span><br><span class="line">	    &#125;</span><br><span class="line">	    idx_bit++;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      idx_byte++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父进程调用fork时会进入内核态进行系统调用，中断入口程序会保存父进程的上下文和cs:ip，因此才会正常返回执行后面的代码，子进程要从fork后开始执行，就需要和父进程一样从中断退出，经过intr_exit，下面是具体实现部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 为子进程构建thread_stack和修改返回值 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">build_child_stack</span><span class="params">(struct task_struct* child_thread)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* a 使子进程pid返回值为0 */</span></span><br><span class="line">   <span class="comment">/* 获取子进程0级栈栈顶 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span>* <span class="title">intr_0_stack</span> = (<span class="title">struct</span> <span class="title">intr_stack</span>*)((<span class="title">uint32_t</span>)<span class="title">child_thread</span> + <span class="title">PG_SIZE</span> - <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">intr_stack</span>));</span></span><br><span class="line">   <span class="comment">/* 修改子进程的返回值为0 */</span></span><br><span class="line">   intr_0_stack-&gt;eax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b 为switch_to 构建 struct thread_stack,将其构建在紧临intr_stack之下的空间*/</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* ret_addr_in_thread_stack  = (<span class="keyword">uint32_t</span>*)intr_0_stack - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/***   这三行不是必要的,只是为了梳理thread_stack中的关系 ***/</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* esi_ptr_in_thread_stack = (<span class="keyword">uint32_t</span>*)intr_0_stack - <span class="number">2</span>; </span><br><span class="line">   <span class="keyword">uint32_t</span>* edi_ptr_in_thread_stack = (<span class="keyword">uint32_t</span>*)intr_0_stack - <span class="number">3</span>; </span><br><span class="line">   <span class="keyword">uint32_t</span>* ebx_ptr_in_thread_stack = (<span class="keyword">uint32_t</span>*)intr_0_stack - <span class="number">4</span>; </span><br><span class="line">   <span class="comment">/**********************************************************/</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* ebp在thread_stack中的地址便是当时的esp(0级栈的栈顶),</span></span><br><span class="line"><span class="comment">   即esp为"(uint32_t*)intr_0_stack - 5" */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* ebp_ptr_in_thread_stack = (<span class="keyword">uint32_t</span>*)intr_0_stack - <span class="number">5</span>; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* switch_to的返回地址更新为intr_exit,直接从中断返回 */</span></span><br><span class="line">   *ret_addr_in_thread_stack = (<span class="keyword">uint32_t</span>)intr_exit;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 下面这两行赋值只是为了使构建的thread_stack更加清晰,其实也不需要,</span></span><br><span class="line"><span class="comment">    * 因为在进入intr_exit后一系列的pop会把寄存器中的数据覆盖 */</span></span><br><span class="line">   *ebp_ptr_in_thread_stack = *ebx_ptr_in_thread_stack =\</span><br><span class="line">   *edi_ptr_in_thread_stack = *esi_ptr_in_thread_stack = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">/*********************************************************/</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 把构建的thread_stack的栈顶做为switch_to恢复数据时的栈顶 */</span></span><br><span class="line">   child_thread-&gt;self_kstack = ebp_ptr_in_thread_stack;	    </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新inode打开数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_inode_open_cnts</span><span class="params">(struct task_struct* thread)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int32_t</span> local_fd = <span class="number">3</span>, global_fd = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (local_fd &lt; MAX_FILES_OPEN_PER_PROC) &#123;</span><br><span class="line">      global_fd = thread-&gt;fd_table[local_fd];</span><br><span class="line">      ASSERT(global_fd &lt; MAX_FILE_OPEN);</span><br><span class="line">      <span class="keyword">if</span> (global_fd != <span class="number">-1</span>) &#123;</span><br><span class="line">	 file_table[global_fd].fd_inode-&gt;i_open_cnts++;</span><br><span class="line">      &#125;</span><br><span class="line">      local_fd++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拷贝父进程本身所占资源给子进程 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">copy_process</span><span class="params">(struct task_struct* child_thread, struct task_struct* parent_thread)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 内核缓冲区,作为父进程用户空间的数据复制到子进程用户空间的中转 */</span></span><br><span class="line">   <span class="keyword">void</span>* buf_page = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (buf_page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* a 复制父进程的pcb、虚拟地址位图、内核栈到子进程 */</span></span><br><span class="line">   <span class="keyword">if</span> (copy_pcb_vaddrbitmap_stack0(child_thread, parent_thread) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* b 为子进程创建页表,此页表仅包括内核空间 */</span></span><br><span class="line">   child_thread-&gt;pgdir = create_page_dir();</span><br><span class="line">   <span class="keyword">if</span>(child_thread-&gt;pgdir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* c 复制父进程进程体及用户栈给子进程 */</span></span><br><span class="line">   copy_body_stack3(child_thread, parent_thread, buf_page);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* d 构建子进程thread_stack和修改返回值pid */</span></span><br><span class="line">   build_child_stack(child_thread);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* e 更新文件inode的打开数 */</span></span><br><span class="line">   update_inode_open_cnts(child_thread);</span><br><span class="line"></span><br><span class="line">   mfree_page(PF_KERNEL, buf_page, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们添加fork系统调用和init进程初始化，init是用户级进程，是第一个启用的程序，其pid为1，也就是所有进程的父进程。fork系统调用的实现步骤如下</p>
<ul>
<li>在syscall.h中添加系统调用号SYS_FORK</li>
<li>在syscall.c中添加fork()，原型是<code>pid_t fork(void)</code></li>
<li>在syscall-init.c中的函数syscall_init中添加初始化</li>
</ul>
<p>下面是main.c中添加init进程代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init进程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> ret_pid = fork();</span><br><span class="line">   <span class="keyword">if</span>(ret_pid) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"i am father, my pid is %d, child pid is %d\n"</span>, getpid(), ret_pid);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"i am child, my pid is %d, ret pid is %d\n"</span>, getpid(), ret_pid);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了争夺pid为1的进程，我们需要修改thread.c中的代码，在创建主线程之前就创建init进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化线程环境 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"thread_init start\n"</span>);</span><br><span class="line"></span><br><span class="line">   list_init(&amp;thread_ready_list);</span><br><span class="line">   list_init(&amp;thread_all_list);</span><br><span class="line">   lock_init(&amp;pid_lock);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 先创建第一个用户进程:init */</span></span><br><span class="line">   process_execute(init, <span class="string">"init"</span>);         <span class="comment">// 放在第一个初始化,这是第一个进程,init进程的pid为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将当前main函数创建为线程 */</span></span><br><span class="line">   make_main_thread();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建idle线程 */</span></span><br><span class="line">   idle_thread = thread_start(<span class="string">"idle"</span>, <span class="number">10</span>, idle, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   put_str(<span class="string">"thread_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译测试效果如下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/108.png" alt></p>
<h2 id="添加read、putchar、clear系统调用"><a href="#添加read、putchar、clear系统调用" class="headerlink" title="添加read、putchar、clear系统调用"></a>添加read、putchar、clear系统调用</h2><p>下面添加一些其他系统调用，因为在后面shell交互的时候我们需要知道用户的输入，所以我们首先添加read系统调用，我们先修改sys_read让其支持键盘，后面几步就是添加read原型<code>ssize_t read(int fd, void *buf, size_t count)</code>，添加系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从文件描述符fd指向的文件中读取count个字节到buf,若成功则返回读出的字节数,到文件尾则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_read(<span class="keyword">int32_t</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   ASSERT(buf != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span> (fd &lt; <span class="number">0</span> || fd == stdout_no || fd == stderr_no) &#123;</span><br><span class="line">      printk(<span class="string">"sys_read: fd error\n"</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd == stdin_no) &#123; <span class="comment">// 标准输入stdin_no的处理</span></span><br><span class="line">      <span class="keyword">char</span>* buffer = buf;</span><br><span class="line">      <span class="keyword">uint32_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (bytes_read &lt; count) &#123;</span><br><span class="line">	 *buffer = ioq_getchar(&amp;kbd_buf); <span class="comment">// 每次从键盘缓冲区kdb_buf中获取1个字符，直到count个字符为止</span></span><br><span class="line">	 bytes_read++;</span><br><span class="line">	 buffer++;</span><br><span class="line">      &#125;</span><br><span class="line">      ret = (bytes_read == <span class="number">0</span> ? <span class="number">-1</span> : (<span class="keyword">int32_t</span>)bytes_read);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> _fd = fd_local2global(fd);</span><br><span class="line">      ret = file_read(&amp;file_table[_fd], buf, count);   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是putchar和clear的函数，其中putchar原型是<code>int putchar(int c)</code>，我们可以直接用现有的console_put_char函数。对于clear操作，涉及到清屏，就需要用汇编实现，具体内容在print.S中，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">global cls_screen</span><br><span class="line">cls_screen:</span><br><span class="line">   pushad</span><br><span class="line">   ;;;;;;;;;;;;;;;</span><br><span class="line">	; 由于用户程序的cpl为3,显存段的dpl为0,故用于显存段的选择子gs在低于自己特权的环境中为0,</span><br><span class="line">	; 导致用户程序再次进入中断后,gs为0,故直接在put_str中每次都为gs赋值. </span><br><span class="line">   mov ax, SELECTOR_VIDEO	       ; 不能直接把立即数送入gs,须由ax中转</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">   mov ebx, 0</span><br><span class="line">   mov ecx, 80*25</span><br><span class="line"> .cls:</span><br><span class="line">   mov word [gs:ebx], 0x0720		  ;0x0720是黑底白字的空格键</span><br><span class="line">   add ebx, 2</span><br><span class="line">   loop .cls </span><br><span class="line">   mov ebx, 0</span><br><span class="line"></span><br><span class="line"> .set_cursor:				  ;直接把set_cursor搬过来用,省事</span><br><span class="line">;;;;;;; 1 先设置高8位 ;;;;;;;;</span><br><span class="line">   mov dx, 0x03d4			  ;索引寄存器</span><br><span class="line">   mov al, 0x0e				  ;用于提供光标位置的高8位</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5			  ;通过读写数据端口0x3d5来获得或设置光标位置 </span><br><span class="line">   mov al, bh</span><br><span class="line">   out dx, al</span><br><span class="line"></span><br><span class="line">;;;;;;; 2 再设置低8位 ;;;;;;;;;</span><br><span class="line">   mov dx, 0x03d4</span><br><span class="line">   mov al, 0x0f</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5 </span><br><span class="line">   mov al, bl</span><br><span class="line">   out dx, al</span><br><span class="line">   popad</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>
<p>下面是系统调用的添加，后面的一些操作和上面类似，就不具体列出了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出一个字符 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putchar</span><span class="params">(<span class="keyword">char</span> char_asci)</span> </span>&#123;</span><br><span class="line">   _syscall1(SYS_PUTCHAR, char_asci);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清空屏幕 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   _syscall0(SYS_CLEAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shell的实现"><a href="#shell的实现" class="headerlink" title="shell的实现"></a>shell的实现</h2><p>接下来我们需要实现shell，支持一些简单的命令，和之前的代码联系起来，我们的shell实现新建一个shell目录，用shell.c和.h进行具体实现，其中比较关键的函数是readline，主要通过循环一个字符一个字符读取到pos中，然后进行判断处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmd_len 128	   <span class="comment">// 最大支持键入128个字符的命令行输入</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ARG_NR 16	   <span class="comment">// 加上命令名外,最多支持15个参数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储输入的命令 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> cmd_line[cmd_len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用来记录当前目录,是当前目录的缓存,每次执行cd命令时会更新此内容 */</span></span><br><span class="line"><span class="keyword">char</span> cwd_cache[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出提示符 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_prompt</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[rabbit@localhost %s]$ "</span>, cwd_cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从键盘缓冲区中最多读入count个字节到buf。*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">int32_t</span> count)</span> </span>&#123;</span><br><span class="line">   assert(buf != <span class="literal">NULL</span> &amp;&amp; count &gt; <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">char</span>* pos = buf;</span><br><span class="line">   <span class="keyword">while</span> (read(stdin_no, pos, <span class="number">1</span>) != <span class="number">-1</span> &amp;&amp; (pos - buf) &lt; count) &#123; <span class="comment">// 在不出错情况下,直到找到回车符才返回</span></span><br><span class="line">      <span class="keyword">switch</span> (*pos) &#123;</span><br><span class="line">       <span class="comment">/* 找到回车或换行符后认为键入的命令结束,直接返回 */</span></span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">	    *pos = <span class="number">0</span>;	   <span class="comment">// 添加cmd_line的终止字符0</span></span><br><span class="line">	    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'\b'</span>:</span><br><span class="line">	    <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'\b'</span>) &#123;		<span class="comment">// 阻止删除非本次输入的信息</span></span><br><span class="line">	       --pos;	   <span class="comment">// 退回到缓冲区cmd_line中上一个字符</span></span><br><span class="line">	       <span class="built_in">putchar</span>(<span class="string">'\b'</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 非控制键则输出字符 */</span></span><br><span class="line">	 <span class="keyword">default</span>:</span><br><span class="line">	    <span class="built_in">putchar</span>(*pos);</span><br><span class="line">	    pos++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"readline: can`t find enter_key in the cmd_line, max num of char is 128\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 简单的shell */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   cwd_cache[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      print_prompt(); </span><br><span class="line">      <span class="built_in">memset</span>(cmd_line, <span class="number">0</span>, cmd_len);</span><br><span class="line">      readline(cmd_line, cmd_len);</span><br><span class="line">      <span class="keyword">if</span> (cmd_line[<span class="number">0</span>] == <span class="number">0</span>) &#123;	 <span class="comment">// 若只键入了一个回车</span></span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   panic(<span class="string">"my_shell: should not be here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面在main中测试一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   cls_screen();</span><br><span class="line">   console_put_str(<span class="string">"[rabbit@localhost /]$ "</span>);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下，实现了一个简单的终端，还没有实现交互</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/109.png" alt></p>
<h3 id="添加ctrl-u和ctrl-l"><a href="#添加ctrl-u和ctrl-l" class="headerlink" title="添加ctrl+u和ctrl+l"></a>添加ctrl+u和ctrl+l</h3><p>Linux中ctrl+u作用是清除本次输入，相当于连续退格。ctrl+l相当于clear命令清屏，不过不会清除当前终端正在输入的内容。我们在shell中继续添加代码，其中ctrl+l分四步完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从键盘缓冲区中最多读入count个字节到buf。*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">int32_t</span> count)</span> </span>&#123;</span><br><span class="line">[...]</span><br><span class="line">     <span class="comment">/* ctrl+l 清屏 */</span></span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'l'</span> - <span class="string">'a'</span>: </span><br><span class="line">	    <span class="comment">/* 1 先将当前的字符'l'-'a'置为0 */</span></span><br><span class="line">	    *pos = <span class="number">0</span>;</span><br><span class="line">	    <span class="comment">/* 2 再将屏幕清空 */</span></span><br><span class="line">	    clear();</span><br><span class="line">	    <span class="comment">/* 3 打印提示符 */</span></span><br><span class="line">	    print_prompt();</span><br><span class="line">	    <span class="comment">/* 4 将之前键入的内容再次打印 */</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* ctrl+u 清掉输入 */</span></span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'u'</span> - <span class="string">'a'</span>:</span><br><span class="line">	    <span class="keyword">while</span> (buf != pos) &#123; <span class="comment">// 循环连续输入退格符</span></span><br><span class="line">	       <span class="built_in">putchar</span>(<span class="string">'\b'</span>);</span><br><span class="line">	       *(pos--) = <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 非控制键则输出字符 */</span></span><br><span class="line">	 <span class="keyword">default</span>:</span><br><span class="line">	    <span class="built_in">putchar</span>(*pos);</span><br><span class="line">	    pos++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"readline: can`t find enter_key in the cmd_line, max num of char is 128\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解析键入字符"><a href="#解析键入字符" class="headerlink" title="解析键入字符"></a>解析键入字符</h3><p>接下来我们需要读入shell中输入的字符，实现交互cmd_parse将解析出来的命令指针存如argv数组，然后通过循环进行下一步处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分析字符串cmd_str中以token为分隔符的单词,将各单词的指针存入argv数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">cmd_parse</span><span class="params">(<span class="keyword">char</span>* cmd_str, <span class="keyword">char</span>** argv, <span class="keyword">char</span> token)</span> </span>&#123;</span><br><span class="line">   assert(cmd_str != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">int32_t</span> arg_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(arg_idx &lt; MAX_ARG_NR) &#123;</span><br><span class="line">      argv[arg_idx] = <span class="literal">NULL</span>;</span><br><span class="line">      arg_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">char</span>* next = cmd_str;</span><br><span class="line">   <span class="keyword">int32_t</span> argc = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">/* 外层循环处理整个命令行 */</span></span><br><span class="line">   <span class="keyword">while</span>(*next) &#123;</span><br><span class="line">      <span class="comment">/* 去除命令字或参数之间的空格 */</span></span><br><span class="line">      <span class="keyword">while</span>(*next == token) &#123;</span><br><span class="line">	 next++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 处理最后一个参数后接空格的情况,如"ls dir2 " */</span></span><br><span class="line">      <span class="keyword">if</span> (*next == <span class="number">0</span>) &#123;</span><br><span class="line">	 <span class="keyword">break</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      argv[argc] = next;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 内层循环处理命令行中的每个命令字及参数 */</span></span><br><span class="line">      <span class="keyword">while</span> (*next &amp;&amp; *next != token) &#123;	  <span class="comment">// 在字符串结束前找单词分隔符</span></span><br><span class="line">	 next++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果未结束(是token字符),使tocken变成0 */</span></span><br><span class="line">      <span class="keyword">if</span> (*next) &#123;</span><br><span class="line">	 *next++ = <span class="number">0</span>;	<span class="comment">// 将token字符替换为字符串结束符0,做为一个单词的结束,并将字符指针next指向下一个字符</span></span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="comment">/* 避免argv数组访问越界,参数过多则返回0 */</span></span><br><span class="line">      <span class="keyword">if</span> (argc &gt; MAX_ARG_NR) &#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      argc++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> argc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* argv[MAX_ARG_NR];    <span class="comment">// argv必须为全局变量，为了以后exec的程序可访问参数</span></span><br><span class="line"><span class="keyword">int32_t</span> argc = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/* 简单的shell */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   cwd_cache[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// 循环处理命令</span></span><br><span class="line">      print_prompt(); </span><br><span class="line">      <span class="built_in">memset</span>(final_path, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">      <span class="built_in">memset</span>(cmd_line, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">      readline(cmd_line, MAX_PATH_LEN);</span><br><span class="line">      <span class="keyword">if</span> (cmd_line[<span class="number">0</span>] == <span class="number">0</span>) &#123;	 <span class="comment">// 若只键入了一个回车</span></span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      argc = <span class="number">-1</span>;</span><br><span class="line">      argc = cmd_parse(cmd_line, argv, <span class="string">' '</span>);</span><br><span class="line">      <span class="keyword">if</span> (argc == <span class="number">-1</span>) &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"num of arguments exceed %d\n"</span>, MAX_ARG_NR);</span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int32_t</span> arg_idx = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(arg_idx &lt; argc) &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"%s "</span>, argv[arg_idx]); </span><br><span class="line">	 arg_idx++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   panic(<span class="string">"my_shell: should not be here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面测试一下，可以正常处理字符串</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/110.png" alt></p>
<h2 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h2><p>下面添加一大堆系统调用，实现shell交互，首先添加系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LIB_USER_SYSCALL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIB_USER_SYSCALL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fs.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> SYSCALL_NR &#123;</span><br><span class="line">   SYS_GETPID,</span><br><span class="line">   SYS_WRITE,</span><br><span class="line">   SYS_MALLOC,</span><br><span class="line">   SYS_FREE,</span><br><span class="line">   SYS_FORK,</span><br><span class="line">   SYS_READ,</span><br><span class="line">   SYS_PUTCHAR,</span><br><span class="line">   SYS_CLEAR,</span><br><span class="line">   SYS_GETCWD,</span><br><span class="line">   SYS_OPEN,</span><br><span class="line">   SYS_CLOSE,</span><br><span class="line">   SYS_LSEEK,</span><br><span class="line">   SYS_UNLINK,</span><br><span class="line">   SYS_MKDIR,</span><br><span class="line">   SYS_OPENDIR,</span><br><span class="line">   SYS_CLOSEDIR,</span><br><span class="line">   SYS_CHDIR,</span><br><span class="line">   SYS_RMDIR,</span><br><span class="line">   SYS_READDIR,</span><br><span class="line">   SYS_REWINDDIR,</span><br><span class="line">   SYS_STAT,</span><br><span class="line">   SYS_PS</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">uint32_t</span> getpid(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">uint32_t</span> write(<span class="keyword">int32_t</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count);</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">uint32_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br><span class="line"><span class="keyword">int16_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">int32_t</span> read(<span class="keyword">int32_t</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putchar</span><span class="params">(<span class="keyword">char</span> char_asci)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">uint32_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">int32_t</span> open(<span class="keyword">char</span>* pathname, <span class="keyword">uint8_t</span> flag);</span><br><span class="line"><span class="keyword">int32_t</span> close(<span class="keyword">int32_t</span> fd);</span><br><span class="line"><span class="keyword">int32_t</span> lseek(<span class="keyword">int32_t</span> fd, <span class="keyword">int32_t</span> offset, <span class="keyword">uint8_t</span> whence);</span><br><span class="line"><span class="keyword">int32_t</span> unlink(<span class="keyword">const</span> <span class="keyword">char</span>* pathname);</span><br><span class="line"><span class="keyword">int32_t</span> mkdir(<span class="keyword">const</span> <span class="keyword">char</span>* pathname);</span><br><span class="line"><span class="function">struct dir* <span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="keyword">int32_t</span> closedir(struct dir* dir);</span><br><span class="line"><span class="keyword">int32_t</span> rmdir(<span class="keyword">const</span> <span class="keyword">char</span>* pathname);</span><br><span class="line"><span class="function">struct dir_entry* <span class="title">readdir</span><span class="params">(struct dir* dir)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(struct dir* dir)</span></span>;</span><br><span class="line"><span class="keyword">int32_t</span> stat(<span class="keyword">const</span> <span class="keyword">char</span>* path, struct stat* buf);</span><br><span class="line"><span class="keyword">int32_t</span> chdir(<span class="keyword">const</span> <span class="keyword">char</span>* path);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ps</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>然后增加系统调用实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取当前工作目录 */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">char</span>*)_syscall2(SYS_GETCWD, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以flag方式打开文件pathname */</span></span><br><span class="line"><span class="keyword">int32_t</span> open(<span class="keyword">char</span>* pathname, <span class="keyword">uint8_t</span> flag) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall2(SYS_OPEN, pathname, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭文件fd */</span></span><br><span class="line"><span class="keyword">int32_t</span> close(<span class="keyword">int32_t</span> fd) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_CLOSE, fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置文件偏移量 */</span></span><br><span class="line"><span class="keyword">int32_t</span> lseek(<span class="keyword">int32_t</span> fd, <span class="keyword">int32_t</span> offset, <span class="keyword">uint8_t</span> whence) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall3(SYS_LSEEK, fd, offset, whence);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除文件pathname */</span></span><br><span class="line"><span class="keyword">int32_t</span> unlink(<span class="keyword">const</span> <span class="keyword">char</span>* pathname) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_UNLINK, pathname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建目录pathname */</span></span><br><span class="line"><span class="keyword">int32_t</span> mkdir(<span class="keyword">const</span> <span class="keyword">char</span>* pathname) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_MKDIR, pathname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开目录name */</span></span><br><span class="line"><span class="function">struct dir* <span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (struct dir*)_syscall1(SYS_OPENDIR, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭目录dir */</span></span><br><span class="line"><span class="keyword">int32_t</span> closedir(struct dir* dir) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_CLOSEDIR, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除目录pathname */</span></span><br><span class="line"><span class="keyword">int32_t</span> rmdir(<span class="keyword">const</span> <span class="keyword">char</span>* pathname) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_RMDIR, pathname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取目录dir */</span></span><br><span class="line"><span class="function">struct dir_entry* <span class="title">readdir</span><span class="params">(struct dir* dir)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (struct dir_entry*)_syscall1(SYS_READDIR, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回归目录指针 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(struct dir* dir)</span> </span>&#123;</span><br><span class="line">   _syscall1(SYS_REWINDDIR, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取path属性到buf中 */</span></span><br><span class="line"><span class="keyword">int32_t</span> stat(<span class="keyword">const</span> <span class="keyword">char</span>* path, struct stat* buf) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall2(SYS_STAT, path, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 改变工作目录为path */</span></span><br><span class="line"><span class="keyword">int32_t</span> chdir(<span class="keyword">const</span> <span class="keyword">char</span>* path) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_CHDIR, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示任务列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ps</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   _syscall0(SYS_PS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在syscall_table中注册</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化系统调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"syscall_init start\n"</span>);</span><br><span class="line">   syscall_table[SYS_GETPID]     = sys_getpid;</span><br><span class="line">   syscall_table[SYS_WRITE]      = sys_write;</span><br><span class="line">   syscall_table[SYS_MALLOC]     = sys_malloc;</span><br><span class="line">   syscall_table[SYS_FREE]       = sys_free;</span><br><span class="line">   syscall_table[SYS_FORK]       = sys_fork;</span><br><span class="line">   syscall_table[SYS_READ]       = sys_read;</span><br><span class="line">   syscall_table[SYS_PUTCHAR]    = sys_putchar;</span><br><span class="line">   syscall_table[SYS_CLEAR]      = cls_screen;</span><br><span class="line">   syscall_table[SYS_GETCWD]     = sys_getcwd;</span><br><span class="line">   syscall_table[SYS_OPEN]       = sys_open;</span><br><span class="line">   syscall_table[SYS_CLOSE]      = sys_close;</span><br><span class="line">   syscall_table[SYS_LSEEK]	 = sys_lseek;</span><br><span class="line">   syscall_table[SYS_UNLINK]	 = sys_unlink;</span><br><span class="line">   syscall_table[SYS_MKDIR]	 = sys_mkdir;</span><br><span class="line">   syscall_table[SYS_OPENDIR]	 = sys_opendir;</span><br><span class="line">   syscall_table[SYS_CLOSEDIR]   = sys_closedir;</span><br><span class="line">   syscall_table[SYS_CHDIR]	 = sys_chdir;</span><br><span class="line">   syscall_table[SYS_RMDIR]	 = sys_rmdir;</span><br><span class="line">   syscall_table[SYS_READDIR]	 = sys_readdir;</span><br><span class="line">   syscall_table[SYS_REWINDDIR]	 = sys_rewinddir;</span><br><span class="line">   syscall_table[SYS_STAT]	 = sys_stat;</span><br><span class="line">   syscall_table[SYS_PS]	 = sys_ps;</span><br><span class="line">   put_str(<span class="string">"syscall_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中命令ps在thread中的实现核心sys_ps如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打印任务列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_ps</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span>* ps_title = <span class="string">"PID            PPID           STAT           TICKS          COMMAND\n"</span>;</span><br><span class="line">   sys_write(stdout_no, ps_title, <span class="built_in">strlen</span>(ps_title));</span><br><span class="line">   list_traversal(&amp;thread_all_list, elem2thread_info, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径解析"><a href="#路径解析" class="headerlink" title="路径解析"></a>路径解析</h2><p>绝对路径是当前文件的全路径，相对路径是以当前工作路径为基础进行操作。要判断这两个路径最好的方法就是判断输入路径，若输入路径以根目录的”/“开头则认为是相对路径，路径解析主要把路径中的”..”和”.”替换成实际的目录，将用户键入的路径，无论是绝对路径还是相对路径，一律转换成不含”.”和”..”的绝对路径进行2操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将路径old_abs_path中的..和.转换为实际路径后存入new_abs_path */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wash_path</span><span class="params">(<span class="keyword">char</span>* old_abs_path, <span class="keyword">char</span>* new_abs_path)</span> </span>&#123;</span><br><span class="line">   assert(old_abs_path[<span class="number">0</span>] == <span class="string">'/'</span>);</span><br><span class="line">   <span class="keyword">char</span> name[MAX_FILE_NAME_LEN] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line">   <span class="keyword">char</span>* sub_path = old_abs_path;</span><br><span class="line">   sub_path = path_parse(sub_path, name);</span><br><span class="line">   <span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="comment">// 若只键入了"/",直接将"/"存入new_abs_path后返回 </span></span><br><span class="line">      new_abs_path[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">      new_abs_path[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   new_abs_path[<span class="number">0</span>] = <span class="number">0</span>;	   <span class="comment">// 避免传给new_abs_path的缓冲区不干净</span></span><br><span class="line">   <span class="built_in">strcat</span>(new_abs_path, <span class="string">"/"</span>);</span><br><span class="line">   <span class="keyword">while</span> (name[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="comment">/* 如果是上一级目录“..” */</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">".."</span>, name)) &#123;</span><br><span class="line">	 <span class="keyword">char</span>* slash_ptr =  <span class="built_in">strrchr</span>(new_abs_path, <span class="string">'/'</span>);</span><br><span class="line">       <span class="comment">/*如果未到new_abs_path中的顶层目录,就将最右边的'/'替换为0,</span></span><br><span class="line"><span class="comment">	 这样便去除了new_abs_path中最后一层路径,相当于到了上一级目录 */</span></span><br><span class="line">	 <span class="keyword">if</span> (slash_ptr != new_abs_path) &#123;	<span class="comment">// 如new_abs_path为“/a/b”,".."之后则变为“/a”</span></span><br><span class="line">	    *slash_ptr = <span class="number">0</span>;</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;	      <span class="comment">// 如new_abs_path为"/a",".."之后则变为"/"</span></span><br><span class="line">      <span class="comment">/* 若new_abs_path中只有1个'/',即表示已经到了顶层目录,</span></span><br><span class="line"><span class="comment">	 就将下一个字符置为结束符0. */</span></span><br><span class="line">	    *(slash_ptr + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"."</span>, name)) &#123;	  <span class="comment">// 如果路径不是‘.’,就将name拼接到new_abs_path</span></span><br><span class="line">	 <span class="keyword">if</span> (<span class="built_in">strcmp</span>(new_abs_path, <span class="string">"/"</span>)) &#123;	  <span class="comment">// 如果new_abs_path不是"/",就拼接一个"/",此处的判断是为了避免路径开头变成这样"//"</span></span><br><span class="line">	    <span class="built_in">strcat</span>(new_abs_path, <span class="string">"/"</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="built_in">strcat</span>(new_abs_path, name);</span><br><span class="line">      &#125;  <span class="comment">// 若name为当前目录".",无须处理new_abs_path</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 继续遍历下一层路径 */</span></span><br><span class="line">      <span class="built_in">memset</span>(name, <span class="number">0</span>, MAX_FILE_NAME_LEN);</span><br><span class="line">      <span class="keyword">if</span> (sub_path) &#123;</span><br><span class="line">	 sub_path = path_parse(sub_path, name);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将path处理成不含..和.的绝对路径,存储在final_path */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_clear_abs_path</span><span class="params">(<span class="keyword">char</span>* path, <span class="keyword">char</span>* final_path)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> abs_path[MAX_PATH_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="comment">/* 先判断是否输入的是绝对路径 */</span></span><br><span class="line">   <span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">'/'</span>) &#123;      <span class="comment">// 若输入的不是绝对路径,就拼接成绝对路径</span></span><br><span class="line">      <span class="built_in">memset</span>(abs_path, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">      <span class="keyword">if</span> (getcwd(abs_path, MAX_PATH_LEN) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (!((abs_path[<span class="number">0</span>] == <span class="string">'/'</span>) &amp;&amp; (abs_path[<span class="number">1</span>] == <span class="number">0</span>))) &#123;	     <span class="comment">// 若abs_path表示的当前目录不是根目录/</span></span><br><span class="line">	    <span class="built_in">strcat</span>(abs_path, <span class="string">"/"</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">strcat</span>(abs_path, path);</span><br><span class="line">   wash_path(abs_path, final_path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码我们就先不测试了，待会一起进行测试，接下来我们继续完善ls，cd，mkdir，ps，rm等命令，我们采用内部函数的方法对其进行实现，遵循以下几点</p>
<ul>
<li>内部命令都以<code>buildin_ + 命令名</code>组合</li>
<li>形参均为argc和argv，argc是参数数组argv中参数的个数</li>
<li>函数实现是调用同功能的系统调用实现的</li>
<li>系统调用前调用make_clear_abs_path将路径转换为绝对路径</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pwd命令的内建函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildin_pwd</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span>** argv UNUSED)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"pwd: no argument support!\n"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">NULL</span> != getcwd(final_path, MAX_PATH_LEN)) &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, final_path); </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"pwd: get current work directory failed.\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* cd命令的内建函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">buildin_cd</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"cd: only support 1 argument!\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 若是只键入cd而无参数,直接返回到根目录. */</span></span><br><span class="line">   <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">      final_path[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">      final_path[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      make_clear_abs_path(argv[<span class="number">1</span>], final_path);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (chdir(final_path) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"cd: no such directory %s\n"</span>, final_path);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> final_path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ls命令的内建函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildin_ls</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span>* pathname = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;file_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">   <span class="keyword">bool</span> long_info = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> arg_path_nr = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> arg_idx = <span class="number">1</span>;   <span class="comment">// 跨过argv[0],argv[0]是字符串“ls”</span></span><br><span class="line">   <span class="keyword">while</span> (arg_idx &lt; argc) &#123;</span><br><span class="line">      <span class="keyword">if</span> (argv[arg_idx][<span class="number">0</span>] == <span class="string">'-'</span>) &#123;	  <span class="comment">// 如果是选项,单词的首字符是-</span></span><br><span class="line">	 <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"-l"</span>, argv[arg_idx])) &#123;         <span class="comment">// 如果是参数-l</span></span><br><span class="line">	    long_info = <span class="literal">true</span>;</span><br><span class="line">	 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"-h"</span>, argv[arg_idx])) &#123;   <span class="comment">// 参数-h</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"usage: -l list all infomation about the file.\n-h for help\nlist all files in the current dirctory if no option\n"</span>); </span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 只支持-h -l两个选项</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"ls: invalid option %s\nTry `ls -h' for more information.\n"</span>, argv[arg_idx]);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;	     <span class="comment">// ls的路径参数</span></span><br><span class="line">	 <span class="keyword">if</span> (arg_path_nr == <span class="number">0</span>) &#123;</span><br><span class="line">	    pathname = argv[arg_idx];</span><br><span class="line">	    arg_path_nr = <span class="number">1</span>;</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"ls: only support one path\n"</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arg_idx++;</span><br><span class="line">   &#125; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (pathname == <span class="literal">NULL</span>) &#123;	 <span class="comment">// 若只输入了ls 或 ls -l,没有输入操作路径,默认以当前路径的绝对路径为参数.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">NULL</span> != getcwd(final_path, MAX_PATH_LEN)) &#123;</span><br><span class="line">	 pathname = final_path;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"ls: getcwd for default path failed\n"</span>);</span><br><span class="line">	 <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      make_clear_abs_path(pathname, final_path);</span><br><span class="line">      pathname = final_path;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (stat(pathname, &amp;file_stat) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"ls: cannot access %s: No such file or directory\n"</span>, pathname);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (file_stat.st_filetype == FT_DIRECTORY) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">dir</span> = <span class="title">opendir</span>(<span class="title">pathname</span>);</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">dir_e</span> = <span class="title">NULL</span>;</span></span><br><span class="line">      <span class="keyword">char</span> sub_pathname[MAX_PATH_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="keyword">uint32_t</span> pathname_len = <span class="built_in">strlen</span>(pathname);</span><br><span class="line">      <span class="keyword">uint32_t</span> last_char_idx = pathname_len - <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">memcpy</span>(sub_pathname, pathname, pathname_len);</span><br><span class="line">      <span class="keyword">if</span> (sub_pathname[last_char_idx] != <span class="string">'/'</span>) &#123;</span><br><span class="line">	 sub_pathname[pathname_len] = <span class="string">'/'</span>;</span><br><span class="line">	 pathname_len++;</span><br><span class="line">      &#125;</span><br><span class="line">      rewinddir(dir);</span><br><span class="line">      <span class="keyword">if</span> (long_info) &#123;</span><br><span class="line">	 <span class="keyword">char</span> ftype;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"total: %d\n"</span>, file_stat.st_size);</span><br><span class="line">	 <span class="keyword">while</span>((dir_e = readdir(dir))) &#123;</span><br><span class="line">	    ftype = <span class="string">'d'</span>;</span><br><span class="line">	    <span class="keyword">if</span> (dir_e-&gt;f_type == FT_REGULAR) &#123;</span><br><span class="line">	       ftype = <span class="string">'-'</span>;</span><br><span class="line">	    &#125; </span><br><span class="line">	    sub_pathname[pathname_len] = <span class="number">0</span>;</span><br><span class="line">	    <span class="built_in">strcat</span>(sub_pathname, dir_e-&gt;filename);</span><br><span class="line">	    <span class="built_in">memset</span>(&amp;file_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">	    <span class="keyword">if</span> (stat(sub_pathname, &amp;file_stat) == <span class="number">-1</span>) &#123;</span><br><span class="line">	       <span class="built_in">printf</span>(<span class="string">"ls: cannot access %s: No such file or directory\n"</span>, dir_e-&gt;filename);</span><br><span class="line">	       <span class="keyword">return</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%c  %d  %d  %s\n"</span>, ftype, dir_e-&gt;i_no, file_stat.st_size, dir_e-&gt;filename);</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 <span class="keyword">while</span>((dir_e = readdir(dir))) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%s "</span>, dir_e-&gt;filename);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      closedir(dir);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (long_info) &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"-  %d  %d  %s\n"</span>, file_stat.st_ino, file_stat.st_size, pathname);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, pathname);  </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ps命令内建函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildin_ps</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span>** argv UNUSED)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"ps: no argument support!\n"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ps();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clear命令内建函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildin_clear</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span>** argv UNUSED)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"clear: no argument support!\n"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mkdir命令内建函数 */</span></span><br><span class="line"><span class="keyword">int32_t</span> buildin_mkdir(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span>** argv) &#123;</span><br><span class="line">   <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"mkdir: only support 1 argument!\n"</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      make_clear_abs_path(argv[<span class="number">1</span>], final_path);</span><br><span class="line">      <span class="comment">/* 若创建的不是根目录 */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"/"</span>, final_path)) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (mkdir(final_path) == <span class="number">0</span>) &#123;</span><br><span class="line">	    ret = <span class="number">0</span>;</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"mkdir: create directory %s failed.\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rmdir命令内建函数 */</span></span><br><span class="line"><span class="keyword">int32_t</span> buildin_rmdir(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span>** argv) &#123;</span><br><span class="line">   <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"rmdir: only support 1 argument!\n"</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      make_clear_abs_path(argv[<span class="number">1</span>], final_path);</span><br><span class="line">   <span class="comment">/* 若删除的不是根目录 */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"/"</span>, final_path)) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (rmdir(final_path) == <span class="number">0</span>) &#123;</span><br><span class="line">	    ret = <span class="number">0</span>;</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"rmdir: remove %s failed.\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rm命令内建函数 */</span></span><br><span class="line"><span class="keyword">int32_t</span> buildin_rm(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span>** argv) &#123;</span><br><span class="line">   <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"rm: only support 1 argument!\n"</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      make_clear_abs_path(argv[<span class="number">1</span>], final_path);</span><br><span class="line">   <span class="comment">/* 若删除的不是根目录 */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"/"</span>, final_path)) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (unlink(final_path) == <span class="number">0</span>) &#123;</span><br><span class="line">	    ret = <span class="number">0</span>;</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"rm: delete %s failed.\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	 &#125;</span><br><span class="line">	    </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用这些命令就需要修改shell文件，因为这个文件能够获取用户的输入，下面的argv[0]也就是用户输入的命令，通过memset进行比较</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* argv[MAX_ARG_NR];    <span class="comment">// argv为全局变量，为了以后exec的程序可访问参数</span></span><br><span class="line"><span class="keyword">int32_t</span> argc = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/* 简单的shell */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   cwd_cache[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      print_prompt(); </span><br><span class="line">      <span class="built_in">memset</span>(final_path, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">      <span class="built_in">memset</span>(cmd_line, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">      readline(cmd_line, MAX_PATH_LEN);</span><br><span class="line">      <span class="keyword">if</span> (cmd_line[<span class="number">0</span>] == <span class="number">0</span>) &#123;	 <span class="comment">// 若只键入了一个回车</span></span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      argc = <span class="number">-1</span>;</span><br><span class="line">      argc = cmd_parse(cmd_line, argv, <span class="string">' '</span>);</span><br><span class="line">      <span class="keyword">if</span> (argc == <span class="number">-1</span>) &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"num of arguments exceed %d\n"</span>, MAX_ARG_NR);</span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"ls"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">	 buildin_ls(argc, argv);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"cd"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (buildin_cd(argc, argv) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="built_in">memset</span>(cwd_cache, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">	    <span class="built_in">strcpy</span>(cwd_cache, final_path);</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"pwd"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">	 buildin_pwd(argc, argv);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"ps"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">	 buildin_ps(argc, argv);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"clear"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">	 buildin_clear(argc, argv);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"mkdir"</span>, argv[<span class="number">0</span>]))&#123;</span><br><span class="line">	 buildin_mkdir(argc, argv);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"rmdir"</span>, argv[<span class="number">0</span>]))&#123;</span><br><span class="line">	 buildin_rmdir(argc, argv);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"rm"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">	 buildin_rm(argc, argv);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"external command\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   panic(<span class="string">"my_shell: should not be here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面测试一下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/111.png" alt></p>
<h2 id="加载用户进程"><a href="#加载用户进程" class="headerlink" title="加载用户进程"></a>加载用户进程</h2><p>接下来我们需要从硬盘上加载程序，实现exec，exec会把一个可执行文件的绝对路径作为参数，把当前正在运行的用户进程的进程体(代码段、数据段、堆、栈)用该可执行文件的进程体替换，从而实现了新进程的执行，新进程只会替换老进程，因此pid仍然是老进程的pid，之前的shell是通过if-else结构对用户输入进行处理，要添加系统调用就会很麻烦，但有了exec之后就可以完成任意外部命令(用户进程)的运行。下面是具体实现，首先添加elf相关结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">intr_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Word, Elf32_Addr, Elf32_Off;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf32_Half;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 32位elf头 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Ehdr</span> &#123;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[<span class="number">16</span>];</span><br><span class="line">   Elf32_Half    e_type;</span><br><span class="line">   Elf32_Half    e_machine;</span><br><span class="line">   Elf32_Word    e_version;</span><br><span class="line">   Elf32_Addr    e_entry;</span><br><span class="line">   Elf32_Off     e_phoff;</span><br><span class="line">   Elf32_Off     e_shoff;</span><br><span class="line">   Elf32_Word    e_flags;</span><br><span class="line">   Elf32_Half    e_ehsize;</span><br><span class="line">   Elf32_Half    e_phentsize;</span><br><span class="line">   Elf32_Half    e_phnum;</span><br><span class="line">   Elf32_Half    e_shentsize;</span><br><span class="line">   Elf32_Half    e_shnum;</span><br><span class="line">   Elf32_Half    e_shstrndx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 程序头表Program header.就是段描述头 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Phdr</span> &#123;</span></span><br><span class="line">   Elf32_Word p_type;		 <span class="comment">// 见下面的enum segment_type</span></span><br><span class="line">   Elf32_Off  p_offset;</span><br><span class="line">   Elf32_Addr p_vaddr;</span><br><span class="line">   Elf32_Addr p_paddr;</span><br><span class="line">   Elf32_Word p_filesz;</span><br><span class="line">   Elf32_Word p_memsz;</span><br><span class="line">   Elf32_Word p_flags;</span><br><span class="line">   Elf32_Word p_align;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 段类型 */</span></span><br><span class="line"><span class="keyword">enum</span> segment_type &#123;</span><br><span class="line">   PT_NULL,            <span class="comment">// 忽略</span></span><br><span class="line">   PT_LOAD,            <span class="comment">// 可加载程序段</span></span><br><span class="line">   PT_DYNAMIC,         <span class="comment">// 动态加载信息 </span></span><br><span class="line">   PT_INTERP,          <span class="comment">// 动态加载器名称</span></span><br><span class="line">   PT_NOTE,            <span class="comment">// 一些辅助信息</span></span><br><span class="line">   PT_SHLIB,           <span class="comment">// 保留</span></span><br><span class="line">   PT_PHDR             <span class="comment">// 程序头表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先实现段加载到内存的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将文件描述符fd指向的文件中,偏移为offset,大小为filesz的段加载到虚拟地址为vaddr的内存 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">segment_load</span><span class="params">(<span class="keyword">int32_t</span> fd, <span class="keyword">uint32_t</span> offset, <span class="keyword">uint32_t</span> filesz, <span class="keyword">uint32_t</span> vaddr)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> vaddr_first_page = vaddr &amp; <span class="number">0xfffff000</span>;    <span class="comment">// vaddr地址所在的页框</span></span><br><span class="line">   <span class="keyword">uint32_t</span> size_in_first_page = PG_SIZE - (vaddr &amp; <span class="number">0x00000fff</span>);     <span class="comment">// 加载到内存后,文件在第一个页框中占用的字节大小</span></span><br><span class="line">   <span class="keyword">uint32_t</span> occupy_pages = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">/* 若一个页框容不下该段 */</span></span><br><span class="line">   <span class="keyword">if</span> (filesz &gt; size_in_first_page) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> left_size = filesz - size_in_first_page;</span><br><span class="line">      occupy_pages = DIV_ROUND_UP(left_size, PG_SIZE) + <span class="number">1</span>;	     <span class="comment">// 1是指vaddr_first_page</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      occupy_pages = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 为进程分配内存 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> page_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> vaddr_page = vaddr_first_page;</span><br><span class="line">   <span class="keyword">while</span> (page_idx &lt; occupy_pages) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span>* pde = pde_ptr(vaddr_page);</span><br><span class="line">      <span class="keyword">uint32_t</span>* pte = pte_ptr(vaddr_page);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果pde不存在,或者pte不存在就分配内存.</span></span><br><span class="line"><span class="comment">       * pde的判断要在pte之前,否则pde若不存在会导致</span></span><br><span class="line"><span class="comment">       * 判断pte时缺页异常 */</span></span><br><span class="line">      <span class="keyword">if</span> (!(*pde &amp; <span class="number">0x00000001</span>) || !(*pte &amp; <span class="number">0x00000001</span>)) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (get_a_page(PF_USER, vaddr_page) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="comment">// 如果原进程的页表已经分配了,利用现有的物理页,直接覆盖进程体</span></span><br><span class="line">      vaddr_page += PG_SIZE;</span><br><span class="line">      page_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   sys_lseek(fd, offset, SEEK_SET);</span><br><span class="line">   sys_read(fd, (<span class="keyword">void</span>*)vaddr, filesz);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把段内存分配完之后就是加载进程到内存中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从文件系统上加载用户程序pathname,成功则返回程序的起始地址,否则返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Ehdr</span> <span class="title">elf_header</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Phdr</span> <span class="title">prog_header</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;elf_header, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Elf32_Ehdr));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int32_t</span> fd = sys_open(pathname, O_RDONLY);</span><br><span class="line">   <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (sys_read(fd, &amp;elf_header, <span class="keyword">sizeof</span>(struct Elf32_Ehdr)) != <span class="keyword">sizeof</span>(struct Elf32_Ehdr)) &#123;</span><br><span class="line">      ret = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 校验elf头 */</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">memcmp</span>(elf_header.e_ident, <span class="string">"\177ELF\1\1\1"</span>, <span class="number">7</span>) \</span><br><span class="line">      || elf_header.e_type != <span class="number">2</span> \</span><br><span class="line">      || elf_header.e_machine != <span class="number">3</span> \</span><br><span class="line">      || elf_header.e_version != <span class="number">1</span> \</span><br><span class="line">      || elf_header.e_phnum &gt; <span class="number">1024</span> \</span><br><span class="line">      || elf_header.e_phentsize != <span class="keyword">sizeof</span>(struct Elf32_Phdr)) &#123;</span><br><span class="line">      ret = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Elf32_Off prog_header_offset = elf_header.e_phoff; </span><br><span class="line">   Elf32_Half prog_header_size = elf_header.e_phentsize;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 遍历所有程序头 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> prog_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (prog_idx &lt; elf_header.e_phnum) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;prog_header, <span class="number">0</span>, prog_header_size);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 将文件的指针定位到程序头 */</span></span><br><span class="line">      sys_lseek(fd, prog_header_offset, SEEK_SET);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 只获取程序头 */</span></span><br><span class="line">      <span class="keyword">if</span> (sys_read(fd, &amp;prog_header, prog_header_size) != prog_header_size) &#123;</span><br><span class="line">	 ret = <span class="number">-1</span>;</span><br><span class="line">	 <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果是可加载段就调用segment_load加载到内存 */</span></span><br><span class="line">      <span class="keyword">if</span> (PT_LOAD == prog_header.p_type) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (!segment_load(fd, prog_header.p_offset, prog_header.p_filesz, prog_header.p_vaddr)) &#123;</span><br><span class="line">	    ret = <span class="number">-1</span>;</span><br><span class="line">	    <span class="keyword">goto</span> done;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 更新下一个程序头的偏移 */</span></span><br><span class="line">      prog_header_offset += elf_header.e_phentsize;</span><br><span class="line">      prog_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   ret = elf_header.e_entry;</span><br><span class="line">done:</span><br><span class="line">   sys_close(fd);</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是sys_execv函数，用path指向的程序替换当前进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用path指向的程序替换当前进程 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_execv(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* argv[]) &#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> argc = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (argv[argc]) &#123; <span class="comment">// 循环统计参数个数并放到argc中</span></span><br><span class="line">      argc++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int32_t</span> entry_point = load(path);     </span><br><span class="line">   <span class="keyword">if</span> (entry_point == <span class="number">-1</span>) &#123;	 <span class="comment">// 若加载失败则返回-1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">   <span class="comment">/* 修改进程名 */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(cur-&gt;name, path, TASK_NAME_LEN);</span><br><span class="line">   cur-&gt;name[TASK_NAME_LEN<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span>* <span class="title">intr_0_stack</span> = (<span class="title">struct</span> <span class="title">intr_stack</span>*)((<span class="title">uint32_t</span>)<span class="title">cur</span> + <span class="title">PG_SIZE</span> - <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">intr_stack</span>));</span></span><br><span class="line">   <span class="comment">/* 参数传递给用户进程 */</span></span><br><span class="line">   intr_0_stack-&gt;ebx = (<span class="keyword">int32_t</span>)argv;</span><br><span class="line">   intr_0_stack-&gt;ecx = argc;</span><br><span class="line">   intr_0_stack-&gt;eip = (<span class="keyword">void</span>*)entry_point;</span><br><span class="line">   <span class="comment">/* 使新用户进程的栈地址为最高用户空间地址 */</span></span><br><span class="line">   intr_0_stack-&gt;esp = (<span class="keyword">void</span>*)<span class="number">0xc0000000</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* exec不同于fork,为使新进程更快被执行,直接从中断返回 */</span></span><br><span class="line">   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"movl %0, %%esp; jmp intr_exit"</span> : : <span class="string">"g"</span> (intr_0_stack) : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="让shell支持外部命令"><a href="#让shell支持外部命令" class="headerlink" title="让shell支持外部命令"></a>让shell支持外部命令</h2><p>由于有系统调用exec，我们shell中就可以添加外部调用命令，Linux中执行命令是bash(或其他shell)先fork一个子进程，然后调用exec去执行命令。我们也效仿这种方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">      [...]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;      <span class="comment">// 如果是外部命令,需要从磁盘上加载</span></span><br><span class="line">	 <span class="keyword">int32_t</span> pid = fork();</span><br><span class="line">	 <span class="keyword">if</span> (pid) &#123;	   <span class="comment">// 父进程</span></span><br><span class="line">	    <span class="comment">/* 下面这个while必须要加上,否则父进程一般情况下会比子进程先执行,</span></span><br><span class="line"><span class="comment">	    因此会进行下一轮循环将findl_path清空,这样子进程将无法从final_path中获得参数*/</span></span><br><span class="line">	    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;	   <span class="comment">// 子进程</span></span><br><span class="line">	    make_clear_abs_path(argv[<span class="number">0</span>], final_path);</span><br><span class="line">	    argv[<span class="number">0</span>] = final_path;</span><br><span class="line">	    <span class="comment">/* 先判断下文件是否存在 */</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">	    <span class="built_in">memset</span>(&amp;file_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">	    <span class="keyword">if</span> (stat(argv[<span class="number">0</span>], &amp;file_stat) == <span class="number">-1</span>) &#123;</span><br><span class="line">	       <span class="built_in">printf</span>(<span class="string">"my_shell: cannot access %s: No such file or directory\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	       execv(argv[<span class="number">0</span>], argv);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int32_t</span> arg_idx = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(arg_idx &lt; MAX_ARG_NR) &#123;</span><br><span class="line">	 argv[arg_idx] = <span class="literal">NULL</span>;</span><br><span class="line">	 arg_idx++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   panic(<span class="string">"my_shell: should not be here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加载硬盘上的用户程序执行"><a href="#加载硬盘上的用户程序执行" class="headerlink" title="加载硬盘上的用户程序执行"></a>加载硬盘上的用户程序执行</h2><p>接下来我们需要实现让用户程序跑起来，有下面几步</p>
<ul>
<li>编写第一个真正的用户程序</li>
<li>将用户程序写入文件系统</li>
<li>在shell中执行用户程序，即外部命令</li>
</ul>
<p>首先实现用户程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"prog_no_arg from disk\n"</span>); </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后编写编译脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####  此脚本应该在command目录下执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d <span class="string">"../lib"</span> || ! -d <span class="string">"../build"</span> ]];<span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"dependent dir don\`t exist!"</span></span><br><span class="line">   cwd=$(<span class="built_in">pwd</span>)</span><br><span class="line">   cwd=<span class="variable">$&#123;cwd##*/&#125;</span></span><br><span class="line">   cwd=<span class="variable">$&#123;cwd%/&#125;</span></span><br><span class="line">   <span class="keyword">if</span> [[ <span class="variable">$cwd</span> != <span class="string">"command"</span> ]];<span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> -e <span class="string">"you\`d better in command dir\n"</span></span><br><span class="line">   <span class="keyword">fi</span> </span><br><span class="line">   <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">BIN=<span class="string">"prog_no_arg"</span></span><br><span class="line">CFLAGS=<span class="string">"-m32 -fno-stack-protector -Wall -c -fno-builtin -W -Wstrict-prototypes \</span></span><br><span class="line"><span class="string">      -Wmissing-prototypes -Wsystem-headers"</span></span><br><span class="line">LIB=<span class="string">"../lib/"</span></span><br><span class="line">OBJS=<span class="string">"../build/string.o ../build/syscall.o \</span></span><br><span class="line"><span class="string">      ../build/stdio.o ../build/assert.o"</span></span><br><span class="line">DD_IN=<span class="variable">$BIN</span></span><br><span class="line">DD_OUT=<span class="string">"/home/guang/soft/bochs-2.6.2/bin/hd60M.img"</span> </span><br><span class="line"></span><br><span class="line">gcc <span class="variable">$CFLAGS</span> -I <span class="variable">$LIB</span> -o <span class="variable">$BIN</span><span class="string">".o"</span> <span class="variable">$BIN</span><span class="string">".c"</span></span><br><span class="line">ld -m elf_i386 -e main <span class="variable">$BIN</span><span class="string">".o"</span> <span class="variable">$OBJS</span> -o <span class="variable">$BIN</span></span><br><span class="line">SEC_CNT=$(ls -l <span class="variable">$BIN</span>|awk <span class="string">'&#123;printf("%d", ($5+511)/512)&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -f <span class="variable">$BIN</span> ]];<span class="keyword">then</span></span><br><span class="line">   dd <span class="keyword">if</span>=./<span class="variable">$DD_IN</span> of=<span class="variable">$DD_OUT</span> bs=512 \</span><br><span class="line">   count=<span class="variable">$SEC_CNT</span> seek=300 conv=notrunc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########   以上核心就是下面这三条命令   ##########</span></span><br><span class="line"><span class="comment">#gcc -m32 -fno-stack-protector -Wall -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypes \</span></span><br><span class="line"><span class="comment">#   -Wsystem-headers -I ../lib -o prog_no_arg.o prog_no_arg.c</span></span><br><span class="line"><span class="comment">#ld -m elf_i386 -e main prog_no_arg.o ../build/string.o ../build/syscall.o\</span></span><br><span class="line"><span class="comment">#   ../build/stdio.o ../build/assert.o -o prog_no_arg</span></span><br><span class="line"><span class="comment">#dd if=prog_no_arg of=/home/guang/soft/bochs-2.6.2/bin/hd60M.img \</span></span><br><span class="line"><span class="comment">#   bs=512 count=10 seek=300 conv=notrunc</span></span><br></pre></td></tr></table></figure>
<p>最后在main中测试，加载用户程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************    写入应用程序    *************/</span></span><br><span class="line">   <span class="keyword">uint32_t</span> file_size = <span class="number">4777</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> sec_cnt = DIV_ROUND_UP(file_size, <span class="number">512</span>);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">disk</span>* <span class="title">sda</span> = &amp;<span class="title">channels</span>[0].<span class="title">devices</span>[0];</span></span><br><span class="line">   <span class="keyword">void</span>* prog_buf = sys_malloc(file_size);</span><br><span class="line">   ide_read(sda, <span class="number">300</span>, prog_buf, sec_cnt);</span><br><span class="line">   <span class="keyword">int32_t</span> fd = sys_open(<span class="string">"/prog_no_arg"</span>, O_CREAT|O_RDWR);</span><br><span class="line">   <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(sys_write(fd, prog_buf, file_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">	 printk(<span class="string">"file write error!\n"</span>);</span><br><span class="line">	 <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*************    写入应用程序结束   *************/</span></span><br><span class="line">   cls_screen();</span><br><span class="line">   console_put_str(<span class="string">"[rabbit@localhost /]$ "</span>);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先编译kernel，在编译compile.sh，成功加载用户程序</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/112.png" alt></p>
<h2 id="支持参数的用户程序"><a href="#支持参数的用户程序" class="headerlink" title="支持参数的用户程序"></a>支持参数的用户程序</h2><p>下面我们需要增加参数，也就是多一个传参的过程，但是我们这里传的参数是来自用户程序的，这就要涉及到CRT相关知识点了，在main函数执行前有很多初始化工作，比如start之类的函数，其中很流行的一个框架就是C运行时库也就是CRT，由它来调用main函数并传递参数，如下图所示</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/113.png" alt></p>
<p>我们要传递来自用户的参数，就需要自己实现一个简单的”CRT”，下面是一个很简单的例子，就是单纯传递main的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">extern main</span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">    ;这两个要和exec中指定的寄存器一致</span><br><span class="line">    push ebx    ;压入argv</span><br><span class="line">    push ecx    ;压入argc</span><br><span class="line">    call main</span><br></pre></td></tr></table></figure>
<p>然后我们测试程序prog_arg.c如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"syscall.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> arg_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(arg_idx &lt; argc) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"argv[%d] is %s\n"</span>, arg_idx, argv[arg_idx]);</span><br><span class="line">      arg_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> pid = fork();</span><br><span class="line">   <span class="keyword">if</span> (pid) &#123;</span><br><span class="line">      <span class="keyword">int</span> delay = <span class="number">900000</span>;</span><br><span class="line">      <span class="keyword">while</span>(delay--);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n      I`m father prog, my pid:%d, I will show process list\n"</span>, getpid()); </span><br><span class="line">      ps();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">char</span> abs_path[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n      I`m child prog, my pid:%d, I will exec %s right now\n"</span>, getpid(), argv[<span class="number">1</span>]); </span><br><span class="line">      <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] != <span class="string">'/'</span>) &#123;</span><br><span class="line">	 getcwd(abs_path, <span class="number">512</span>);</span><br><span class="line">	 <span class="built_in">strcat</span>(abs_path, <span class="string">"/"</span>);</span><br><span class="line">	 <span class="built_in">strcat</span>(abs_path, argv[<span class="number">1</span>]);</span><br><span class="line">	 execv(abs_path, argv);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 execv(argv[<span class="number">1</span>], argv);	 </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####  此脚本应该在command目录下执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d <span class="string">"../lib"</span> || ! -d <span class="string">"../build"</span> ]];<span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"dependent dir don\`t exist!"</span></span><br><span class="line">   cwd=$(<span class="built_in">pwd</span>)</span><br><span class="line">   cwd=<span class="variable">$&#123;cwd##*/&#125;</span></span><br><span class="line">   cwd=<span class="variable">$&#123;cwd%/&#125;</span></span><br><span class="line">   <span class="keyword">if</span> [[ <span class="variable">$cwd</span> != <span class="string">"command"</span> ]];<span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> -e <span class="string">"you\`d better in command dir\n"</span></span><br><span class="line">   <span class="keyword">fi</span> </span><br><span class="line">   <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">BIN=<span class="string">"prog_arg"</span></span><br><span class="line">CFLAGS=<span class="string">"-m32 -fno-stack-protector -Wall -c -fno-builtin -W -Wstrict-prototypes \</span></span><br><span class="line"><span class="string">      -Wmissing-prototypes -Wsystem-headers"</span></span><br><span class="line">LIBS=<span class="string">"-I ../lib -I ../lib/user -I ../fs"</span></span><br><span class="line">OBJS=<span class="string">"../build/string.o ../build/syscall.o \</span></span><br><span class="line"><span class="string">      ../build/stdio.o ../build/assert.o start.o"</span></span><br><span class="line">DD_IN=<span class="variable">$BIN</span></span><br><span class="line">DD_OUT=<span class="string">"/home/guang/soft/bochs-2.6.2/bin/hd60M.img"</span> </span><br><span class="line"></span><br><span class="line">nasm -f elf ./start.S -o ./start.o</span><br><span class="line">ar rcs simple_crt.a <span class="variable">$OBJS</span> start.o</span><br><span class="line">gcc <span class="variable">$CFLAGS</span> <span class="variable">$LIBS</span> -o <span class="variable">$BIN</span><span class="string">".o"</span> <span class="variable">$BIN</span><span class="string">".c"</span></span><br><span class="line">ld -m elf_i386 <span class="variable">$BIN</span><span class="string">".o"</span> simple_crt.a -o <span class="variable">$BIN</span></span><br><span class="line">SEC_CNT=$(ls -l <span class="variable">$BIN</span>|awk <span class="string">'&#123;printf("%d", ($5+511)/512)&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -f <span class="variable">$BIN</span> ]];<span class="keyword">then</span></span><br><span class="line">   dd <span class="keyword">if</span>=./<span class="variable">$DD_IN</span> of=<span class="variable">$DD_OUT</span> bs=512 \</span><br><span class="line">   count=<span class="variable">$SEC_CNT</span> seek=300 conv=notrunc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########   以上核心就是下面这五条命令   ##########</span></span><br><span class="line"><span class="comment">#nasm -f elf ./start.S -o ./start.o</span></span><br><span class="line"><span class="comment">#ar rcs simple_crt.a ../build/string.o ../build/syscall.o \</span></span><br><span class="line"><span class="comment">#   ../build/stdio.o ../build/assert.o ./start.o</span></span><br><span class="line"><span class="comment">#gcc -m32 -fno-stack-protector -Wall -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypes \</span></span><br><span class="line"><span class="comment">#   -Wsystem-headers -I ../lib -o prog_no_arg.o prog_no_arg.c</span></span><br><span class="line"><span class="comment">#ld -m elf_i386 -e main prog_no_arg.o ../build/string.o ../build/syscall.o\</span></span><br><span class="line"><span class="comment">#   ../build/stdio.o ../build/assert.o -o prog_no_arg</span></span><br><span class="line"><span class="comment">#dd if=prog_arg of=/home/guang/soft/bochs-2.6.2/bin/hd60M.img \</span></span><br><span class="line"><span class="comment">#   bs=512 count=11 seek=300 conv=notrunc</span></span><br></pre></td></tr></table></figure>
<p>最后测试一下效果</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/114.png" alt></p>
<h2 id="实现wait和exit"><a href="#实现wait和exit" class="headerlink" title="实现wait和exit"></a>实现wait和exit</h2><p>exit作用就是结束进程，wait作用是阻塞父进程自己，直到子进程结束运行，若没有子进程则返回-1，若有则遍历找到其子进程然后等待子进程退出后唤醒父进程。exit是由子进程调用，表面上功能是使子进程结束运行并传递返回值给内核，本质上内核在幕后会将进程除pcb以外的所有资源回收。wait是父进程调用的，表面上功能是使父进程阻塞自己，直到进程调用exit结束运行，然后获得子进程返回值，本质上是内核在幕后将子进程的返回值传递给父进程并唤醒父进程，然后将子进程的pcb回收。下面是实现部分，首先是释放用户进程资源的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 释放用户进程资源: </span></span><br><span class="line"><span class="comment"> * 1 页表中对应的物理页</span></span><br><span class="line"><span class="comment"> * 2 虚拟内存池占物理页框</span></span><br><span class="line"><span class="comment"> * 3 关闭打开的文件 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release_prog_resource</span><span class="params">(struct task_struct* release_thread)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span>* pgdir_vaddr = release_thread-&gt;pgdir;</span><br><span class="line">   <span class="keyword">uint16_t</span> user_pde_nr = <span class="number">768</span>, pde_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> pde = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span>* v_pde_ptr = <span class="literal">NULL</span>;	    <span class="comment">// v表示var,和函数pde_ptr区分</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint16_t</span> user_pte_nr = <span class="number">1024</span>, pte_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> pte = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span>* v_pte_ptr = <span class="literal">NULL</span>;	    <span class="comment">// 加个v表示var,和函数pte_ptr区分</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span>* first_pte_vaddr_in_pde = <span class="literal">NULL</span>;	<span class="comment">// 用来记录pde中第0个pte的地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> pg_phy_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 回收页表中用户空间的页框 */</span></span><br><span class="line">   <span class="keyword">while</span> (pde_idx &lt; user_pde_nr) &#123;</span><br><span class="line">      v_pde_ptr = pgdir_vaddr + pde_idx;</span><br><span class="line">      pde = *v_pde_ptr;</span><br><span class="line">      <span class="keyword">if</span> (pde &amp; <span class="number">0x00000001</span>) &#123;   <span class="comment">// 如果页目录项p位为1,表示该页目录项下可能有页表项</span></span><br><span class="line">	 first_pte_vaddr_in_pde = pte_ptr(pde_idx * <span class="number">0x400000</span>);	  <span class="comment">// 一个页表表示的内存容量是4M,即0x400000</span></span><br><span class="line">	 pte_idx = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">while</span> (pte_idx &lt; user_pte_nr) &#123;</span><br><span class="line">	    v_pte_ptr = first_pte_vaddr_in_pde + pte_idx;</span><br><span class="line">	    pte = *v_pte_ptr;</span><br><span class="line">	    <span class="keyword">if</span> (pte &amp; <span class="number">0x00000001</span>) &#123;</span><br><span class="line">	       <span class="comment">/* 将pte中记录的物理页框直接在相应内存池的位图中清0 */</span></span><br><span class="line">	       pg_phy_addr = pte &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">	       free_a_phy_page(pg_phy_addr);</span><br><span class="line">	    &#125;</span><br><span class="line">	    pte_idx++;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">/* 将pde中记录的物理页框直接在相应内存池的位图中清0 */</span></span><br><span class="line">	 pg_phy_addr = pde &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">	 free_a_phy_page(pg_phy_addr);</span><br><span class="line">      &#125;</span><br><span class="line">      pde_idx++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 回收用户虚拟地址池所占的物理内存*/</span></span><br><span class="line">   <span class="keyword">uint32_t</span> bitmap_pg_cnt = (release_thread-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len) / PG_SIZE;</span><br><span class="line">   <span class="keyword">uint8_t</span>* user_vaddr_pool_bitmap = release_thread-&gt;userprog_vaddr.vaddr_bitmap.bits;</span><br><span class="line">   mfree_page(PF_KERNEL, user_vaddr_pool_bitmap, bitmap_pg_cnt);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 关闭进程打开的文件 */</span></span><br><span class="line">   <span class="keyword">uint8_t</span> fd_idx = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">while</span>(fd_idx &lt; MAX_FILES_OPEN_PER_PROC) &#123;</span><br><span class="line">      <span class="keyword">if</span> (release_thread-&gt;fd_table[fd_idx] != <span class="number">-1</span>) &#123;</span><br><span class="line">	 sys_close(fd_idx);</span><br><span class="line">      &#125;</span><br><span class="line">      fd_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是list_traversal回调三个函数，find_child功能是查找pelem的parent_pid是否是ppid，具体实现就是找父进程pid为ppid的子进程。find_hanging_child负责查找状态为TASK_HANGING的任务。init_adopt_a_child负责将一个子进程过继给init，使init作为该进程的父进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* list_traversal的回调函数,</span></span><br><span class="line"><span class="comment"> * 查找pelem的parent_pid是否是ppid,成功返回true,失败则返回false */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">find_child</span><span class="params">(struct list_elem* pelem, <span class="keyword">int32_t</span> ppid)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* elem2entry中间的参数all_list_tag取决于pelem对应的变量名 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">pthread</span> = <span class="title">elem2entry</span>(<span class="title">struct</span> <span class="title">task_struct</span>, <span class="title">all_list_tag</span>, <span class="title">pelem</span>);</span></span><br><span class="line">   <span class="keyword">if</span> (pthread-&gt;parent_pid == ppid) &#123;     <span class="comment">// 若该任务的parent_pid为ppid,返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">// list_traversal只有在回调函数返回true时才会停止继续遍历,所以在此返回true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">// 让list_traversal继续传递下一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* list_traversal的回调函数,</span></span><br><span class="line"><span class="comment"> * 查找状态为TASK_HANGING的任务 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">find_hanging_child</span><span class="params">(struct list_elem* pelem, <span class="keyword">int32_t</span> ppid)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">pthread</span> = <span class="title">elem2entry</span>(<span class="title">struct</span> <span class="title">task_struct</span>, <span class="title">all_list_tag</span>, <span class="title">pelem</span>);</span></span><br><span class="line">   <span class="keyword">if</span> (pthread-&gt;parent_pid == ppid &amp;&amp; pthread-&gt;status == TASK_HANGING) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* list_traversal的回调函数,</span></span><br><span class="line"><span class="comment"> * 将一个子进程过继给init */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">init_adopt_a_child</span><span class="params">(struct list_elem* pelem, <span class="keyword">int32_t</span> pid)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">pthread</span> = <span class="title">elem2entry</span>(<span class="title">struct</span> <span class="title">task_struct</span>, <span class="title">all_list_tag</span>, <span class="title">pelem</span>);</span></span><br><span class="line">   <span class="keyword">if</span> (pthread-&gt;parent_pid == pid) &#123;     <span class="comment">// 若该进程的parent_pid为pid,返回</span></span><br><span class="line">      pthread-&gt;parent_pid = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">// 让list_traversal继续传递下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是sys_wait和sys_exit的具体实现，注释比较详尽</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 等待子进程调用exit,将子进程的退出状态保存到status指向的变量.</span></span><br><span class="line"><span class="comment"> * 成功则返回子进程的pid,失败则返回-1 */</span></span><br><span class="line"><span class="keyword">pid_t</span> sys_wait(<span class="keyword">int32_t</span>* status) &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">parent_thread</span> = <span class="title">running_thread</span>();</span> <span class="comment">// 获得当前任务，也就是父进程parent_thread</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">/* 优先处理已经是挂起状态的任务 */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">child_elem</span> = <span class="title">list_traversal</span>(&amp;<span class="title">thread_all_list</span>, <span class="title">find_hanging_child</span>, <span class="title">parent_thread</span>-&gt;<span class="title">pid</span>);</span></span><br><span class="line">      <span class="comment">/* 若有挂起的子进程 */</span></span><br><span class="line">      <span class="keyword">if</span> (child_elem != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">child_thread</span> = <span class="title">elem2entry</span>(<span class="title">struct</span> <span class="title">task_struct</span>, <span class="title">all_list_tag</span>, <span class="title">child_elem</span>);</span></span><br><span class="line">	 *status = child_thread-&gt;exit_status; </span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* thread_exit之后,pcb会被回收,因此提前获取pid */</span></span><br><span class="line">	 <span class="keyword">uint16_t</span> child_pid = child_thread-&gt;pid;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 2 从就绪队列和全部队列中删除进程表项*/</span></span><br><span class="line">	 thread_exit(child_thread, <span class="literal">false</span>); <span class="comment">// 传入false,使thread_exit调用后回到此处</span></span><br><span class="line">	 <span class="comment">/* 进程表项是进程或线程的最后保留的资源, 至此该进程彻底消失了 */</span></span><br><span class="line"></span><br><span class="line">	 <span class="keyword">return</span> child_pid;</span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 判断是否有子进程 */</span></span><br><span class="line">      child_elem = list_traversal(&amp;thread_all_list, find_child, parent_thread-&gt;pid);</span><br><span class="line">      <span class="keyword">if</span> (child_elem == <span class="literal">NULL</span>) &#123;	 <span class="comment">// 若没有子进程则出错返回</span></span><br><span class="line">	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* 若子进程还未运行完,即还未调用exit,则将自己挂起,直到子进程在执行exit时将自己唤醒 */</span></span><br><span class="line">	 thread_block(TASK_WAITING); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子进程用来结束自己时调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_exit</span><span class="params">(<span class="keyword">int32_t</span> status)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">child_thread</span> = <span class="title">running_thread</span>();</span> <span class="comment">// 获得自己的pcb，也就是child_thread</span></span><br><span class="line">   child_thread-&gt;exit_status = status; <span class="comment">// 将status存入自己pcb的exit_status</span></span><br><span class="line">   <span class="keyword">if</span> (child_thread-&gt;parent_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">      PANIC(<span class="string">"sys_exit: child_thread-&gt;parent_pid is -1\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 将进程child_thread的所有子进程都过继给init */</span></span><br><span class="line">   list_traversal(&amp;thread_all_list, init_adopt_a_child, child_thread-&gt;pid);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 回收进程child_thread的资源 */</span></span><br><span class="line">   release_prog_resource(child_thread); </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 如果父进程正在等待子进程退出,将父进程唤醒 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">parent_thread</span> = <span class="title">pid2thread</span>(<span class="title">child_thread</span>-&gt;<span class="title">parent_pid</span>);</span></span><br><span class="line">   <span class="keyword">if</span> (parent_thread-&gt;status == TASK_WAITING) &#123;</span><br><span class="line">      thread_unblock(parent_thread);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 将自己挂起,等待父进程获取其status,并回收其pcb */</span></span><br><span class="line">   thread_block(TASK_HANGING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现cat"><a href="#实现cat" class="headerlink" title="实现cat"></a>实现cat</h2><p>cat负责查看文件内容，我们这里实现一个简单的cat，只支持一个参数，下面是实现，首先判断参数是否为一个，然后用malloc申请1024字节的内存用作缓冲区buf，512字节的abs_path用于存储参数的绝对路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"syscall.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (argc &gt; <span class="number">2</span> || argc == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"cat: only support 1 argument.\neg: cat filename\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> buf_size = <span class="number">1024</span>;</span><br><span class="line">   <span class="keyword">char</span> abs_path[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">void</span>* buf = <span class="built_in">malloc</span>(buf_size);</span><br><span class="line">   <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) &#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"cat: malloc memory failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] != <span class="string">'/'</span>) &#123;</span><br><span class="line">      getcwd(abs_path, <span class="number">512</span>);</span><br><span class="line">      <span class="built_in">strcat</span>(abs_path, <span class="string">"/"</span>);</span><br><span class="line">      <span class="built_in">strcat</span>(abs_path, argv[<span class="number">1</span>]);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(abs_path, argv[<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> fd = open(abs_path, O_RDONLY);</span><br><span class="line">   <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"cat: open: open %s failed\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> read_bytes= <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      read_bytes = read(fd, buf, buf_size);</span><br><span class="line">      <span class="keyword">if</span> (read_bytes == <span class="number">-1</span>) &#123; <span class="comment">// 返回-1也就读到了文件尾</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      write(<span class="number">1</span>, buf, read_bytes);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">free</span>(buf);</span><br><span class="line">   close(fd);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">66</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面修改shell.c的文件，把之前的while(1)替换掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;      <span class="comment">// 如果是外部命令,需要从磁盘上加载</span></span><br><span class="line"><span class="keyword">int32_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid) &#123;	   <span class="comment">// 父进程</span></span><br><span class="line">   <span class="keyword">int32_t</span> status;</span><br><span class="line">   <span class="keyword">int32_t</span> child_pid = wait(&amp;status);          <span class="comment">// 此时子进程若没有执行exit,my_shell会被阻塞,不再响应键入的命令</span></span><br><span class="line">   <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;     <span class="comment">// 按理说程序正确的话不会执行到这句,fork出的进程便是shell子进程</span></span><br><span class="line">      panic(<span class="string">"my_shell: no child\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"child_pid %d, it's status: %d\n"</span>, child_pid, status);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;	   <span class="comment">// 子进程</span></span><br><span class="line">   make_clear_abs_path(argv[<span class="number">0</span>], final_path);</span><br><span class="line">   argv[<span class="number">0</span>] = final_path;</span><br><span class="line">   <span class="comment">/* 先判断下文件是否存在 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;file_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">   <span class="keyword">if</span> (stat(argv[<span class="number">0</span>], &amp;file_stat) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"my_shell: cannot access %s: No such file or directory\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      execv(argv[<span class="number">0</span>], argv);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>下面是main中测试代码，把cat写入分区sda的根目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************    写入应用程序    *************/</span></span><br><span class="line">   <span class="keyword">uint32_t</span> file_size = <span class="number">5476</span>; </span><br><span class="line">   <span class="keyword">uint32_t</span> sec_cnt = DIV_ROUND_UP(file_size, <span class="number">512</span>);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">disk</span>* <span class="title">sda</span> = &amp;<span class="title">channels</span>[0].<span class="title">devices</span>[0];</span></span><br><span class="line">   <span class="keyword">void</span>* prog_buf = sys_malloc(file_size);</span><br><span class="line">   ide_read(sda, <span class="number">300</span>, prog_buf, sec_cnt);</span><br><span class="line">   <span class="keyword">int32_t</span> fd = sys_open(<span class="string">"/cat"</span>, O_CREAT|O_RDWR);</span><br><span class="line">   <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(sys_write(fd, prog_buf, file_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">         printk(<span class="string">"file write error!\n"</span>);</span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*************    写入应用程序结束   *************/</span></span><br><span class="line">   cls_screen();</span><br><span class="line">   console_put_str(<span class="string">"[rabbit@localhost /]$ "</span>);</span><br><span class="line">   thread_exit(running_thread(), <span class="literal">true</span>); <span class="comment">// 退出主线程</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init进程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> ret_pid = fork();</span><br><span class="line">   <span class="keyword">if</span>(ret_pid) &#123;  <span class="comment">// 父进程</span></span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      <span class="keyword">int</span> child_pid;</span><br><span class="line">       <span class="comment">/* init在此处不停的回收僵尸进程 */</span></span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	  child_pid = wait(&amp;status);</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">"I`m init, My pid is 1, I recieve a child, It`s pid is %d, status is %d\n"</span>, child_pid, status);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;	  <span class="comment">// 子进程</span></span><br><span class="line">      my_shell();</span><br><span class="line">   &#125;</span><br><span class="line">   panic(<span class="string">"init: should not be here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/115.png" alt></p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="管道原理"><a href="#管道原理" class="headerlink" title="管道原理"></a>管道原理</h3><p>进程虽然是独立的，但有很多相互通信的例子，比如进程A传消息给进程B等，实现这种相互通信的机制有很多方法，如消息队列、共享内存、socket网络通信等，还有一种就是我们要实现的管道。Linux中一切皆文件，故管道也是文件，只是其存在于内存中，仍然可以用open、close等函数操作。管道通常被多个进程共享，其原理是所有进程在地址空间中都可以访问它，也就是内核中的内存缓冲区。</p>
<p>管道是数据的一个中转站，当某个进程往管道中写入数据后，该数据就会被另一个进程读取，之后用新的数据覆盖旧数据，既然是一块数据缓存区，就应该有一个大小。但是由于写入的数据大小是不确定的，这块缓存区的大小很难确定下来，一般来说会使用环形缓存区来存储数据，通过生产者消费者模型对这块环形缓冲区的数据进行读写。这个环形缓冲区用两个指针来维护，一个专门负责读，一个专门负责写，当缓冲区数据满时，生产者睡眠并唤醒消费者。缓冲区空时，消费者睡眠，唤醒生产者。</p>
<p>管道有两端，一端用来读，一端用来写。这个两端的概念实质上是内核为一个管道分配了两个文件描述符，一个负责写，一个负责读。它的模型如下图</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/116.png" alt></p>
<p>管道不可能字节读写自己，所以一般操作是创建管道之后，fork子进程，这个子进程和父进程资源一样，所以两者可以相互实现通信，如下图所示</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/117.png" alt></p>
<p>管道分为匿名管道和命名管道，其区别就是名称，没有名称也就只能用内核返回的文件描述符访问，仅仅局限于父子进程通信。有名称就可以实现对所有进程通信。</p>
<p>Linux为了向文件系统的上层提供统一接口，加了一层中间层VFS(virtual file system)，Linux处理管道时是利用现有的文件结构和VFS中inode共同完成的，并没有为管道提供另外的数据结构。如下图所示，文件结构中的f_indoe指向VFS的inode，该inode指向一个页框大小的内存区域，该区域用于存储管道的数据，也就是说Linux的管道大小是4096字节</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/118.png" alt></p>
<p>我们的管道设计图如下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/119.png" alt></p>
<h3 id="管道实现"><a href="#管道实现" class="headerlink" title="管道实现"></a>管道实现</h3><p>Linux创建管道方法是系统调用pipe，原型是<code>int pipe(int pipefd[2])</code>，成功返回0，失败返回-1，其中pipefd[2]是长度为2的整型数组，用于存储系统返回的文件描述符，fd[0]用于读取管道，fd[1]用于写入管道。下面是创建管道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 判断文件描述符local_fd是否是管道 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_pipe</span><span class="params">(<span class="keyword">uint32_t</span> local_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> global_fd = fd_local2global(local_fd);</span><br><span class="line">    <span class="keyword">return</span> file_table[global_fd].fd_flag == PIPE_FLAG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建管道,成功返回0,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_pipe(<span class="keyword">int32_t</span> pipefd[<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> global_fd = get_free_slot_in_global();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 申请一页内核内存做环形缓冲区 */</span></span><br><span class="line">    file_table[global_fd].fd_inode = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化环形缓冲区 */</span></span><br><span class="line">    ioqueue_init((struct ioqueue *)file_table[global_fd].fd_inode);</span><br><span class="line">    <span class="keyword">if</span> (file_table[global_fd].fd_inode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将fd_flag复用为管道标志 */</span></span><br><span class="line">    file_table[global_fd].fd_flag = PIPE_FLAG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将fd_pos复用为管道打开数 */</span></span><br><span class="line">    file_table[global_fd].fd_pos = <span class="number">2</span>;</span><br><span class="line">    pipefd[<span class="number">0</span>] = pcb_fd_install(global_fd);</span><br><span class="line">    pipefd[<span class="number">1</span>] = pcb_fd_install(global_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取管道中数据，从文件描述符fd中读取count字节到buf</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从管道中读数据 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> pipe_read(<span class="keyword">int32_t</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   <span class="keyword">char</span>* buffer = buf;</span><br><span class="line">   <span class="keyword">uint32_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> global_fd = fd_local2global(fd);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 获取管道的环形缓冲区 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ioqueue</span>* <span class="title">ioq</span> = (<span class="title">struct</span> <span class="title">ioqueue</span>*)<span class="title">file_table</span>[<span class="title">global_fd</span>].<span class="title">fd_inode</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 选择较小的数据读取量,避免阻塞 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> ioq_len = ioq_length(ioq);</span><br><span class="line">   <span class="keyword">uint32_t</span> size = ioq_len &gt; count ? count : ioq_len;</span><br><span class="line">   <span class="keyword">while</span> (bytes_read &lt; size) &#123;</span><br><span class="line">      *buffer = ioq_getchar(ioq);</span><br><span class="line">      bytes_read++;</span><br><span class="line">      buffer++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向管道中写入数据，把缓冲区buf中的count个字节写入管道对应的文件描述符fd</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 往管道中写数据 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> pipe_write(<span class="keyword">int32_t</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> bytes_write = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> global_fd = fd_local2global(fd);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ioqueue</span>* <span class="title">ioq</span> = (<span class="title">struct</span> <span class="title">ioqueue</span>*)<span class="title">file_table</span>[<span class="title">global_fd</span>].<span class="title">fd_inode</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 选择较小的数据写入量,避免阻塞 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> ioq_left = bufsize - ioq_length(ioq);</span><br><span class="line">   <span class="keyword">uint32_t</span> size = ioq_left &gt; count ? count : ioq_left;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span>* buffer = buf;</span><br><span class="line">   <span class="keyword">while</span> (bytes_write &lt; size) &#123;</span><br><span class="line">      ioq_putchar(ioq, *buffer);</span><br><span class="line">      bytes_write++;</span><br><span class="line">      buffer++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bytes_write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是利用管道实现进程间通信的代码，下面就不测试了，直接最后一起测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"syscall.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int32_t</span> fd[<span class="number">2</span>] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line">   pipe(fd);</span><br><span class="line">   <span class="keyword">int32_t</span> pid = fork();</span><br><span class="line">   <span class="keyword">if</span>(pid) &#123;	  <span class="comment">// 父进程</span></span><br><span class="line">      close(fd[<span class="number">0</span>]);  <span class="comment">// 关闭输入</span></span><br><span class="line">      write(fd[<span class="number">1</span>], <span class="string">"Hi, my son, I love you!"</span>, <span class="number">24</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\nI`m father, my pid is %d\n"</span>, getpid());</span><br><span class="line">      <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      close(fd[<span class="number">1</span>]);  <span class="comment">// 关闭输出</span></span><br><span class="line">      <span class="keyword">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      read(fd[<span class="number">0</span>], buf, <span class="number">24</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\nI`m child, my pid is %d\n"</span>, getpid());</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"I`m child, my father said to me: \"%s\"\n"</span>, buf);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们需要在shell中支持管道命令，管道命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep xxx</span><br></pre></td></tr></table></figure>
<p>管道之所以可以这样使用，是进行了输入输出重定向。通常情况下键盘是输入，屏幕是输入。这就是标准输入与标准输出。而输入输出重定向就是改变输入输出的位置，比如从文件中读取输入称为输入重定向，将结果输出到文件中称为输出重定向。管道的作用就是利用了输入输出重定向的与原理，将一个命令的输出作为另一个命令的输入来使用。管道符左边命令的输出数据会作为右边命令的输入数据使用。实现的时候就需要把旧的文件描述符替换为新的文件描述符，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将文件描述符old_local_fd重定向为new_local_fd */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_fd_redirect</span><span class="params">(<span class="keyword">uint32_t</span> old_local_fd, <span class="keyword">uint32_t</span> new_local_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    task_struct *cur = running_thread();</span><br><span class="line">    <span class="comment">/* 恢复标准描述符 */</span></span><br><span class="line">    <span class="keyword">if</span> (new_local_fd &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;fd_table[old_local_fd] = new_local_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> new_global_fd = cur-&gt;fd_table[new_local_fd];</span><br><span class="line">        cur-&gt;fd_table[old_local_fd] = new_global_fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是shell中增加的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 执行命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_execute</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"ls"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">      buildin_ls(argc, argv);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"cd"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">      <span class="keyword">if</span> (buildin_cd(argc, argv) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	 <span class="built_in">memset</span>(cwd_cache, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">	 <span class="built_in">strcpy</span>(cwd_cache, final_path);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"pwd"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">[...]</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span>* argv[MAX_ARG_NR] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">int32_t</span> argc = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/* 简单的shell */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   cwd_cache[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      print_prompt(); </span><br><span class="line">      <span class="built_in">memset</span>(final_path, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">      <span class="built_in">memset</span>(cmd_line, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">      readline(cmd_line, MAX_PATH_LEN);</span><br><span class="line">      <span class="keyword">if</span> (cmd_line[<span class="number">0</span>] == <span class="number">0</span>) &#123;	 <span class="comment">// 若只键入了一个回车</span></span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 针对管道的处理 */</span></span><br><span class="line">      <span class="keyword">char</span>* pipe_symbol = <span class="built_in">strchr</span>(cmd_line, <span class="string">'|'</span>);</span><br><span class="line">      <span class="keyword">if</span> (pipe_symbol) &#123;</span><br><span class="line">   <span class="comment">/* 支持多重管道操作,如cmd1|cmd2|..|cmdn,</span></span><br><span class="line"><span class="comment">    * cmd1的标准输出和cmdn的标准输入需要单独处理 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*1 生成管道*/</span></span><br><span class="line">	 <span class="keyword">int32_t</span> fd[<span class="number">2</span>] = &#123;<span class="number">-1</span>&#125;;	    <span class="comment">// fd[0]用于输入,fd[1]用于输出</span></span><br><span class="line">	 pipe(fd);</span><br><span class="line">	 <span class="comment">/* 将标准输出重定向到fd[1],使后面的输出信息重定向到内核环形缓冲区 */</span></span><br><span class="line">	 fd_redirect(<span class="number">1</span>,fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*2 第一个命令 */</span></span><br><span class="line">	 <span class="keyword">char</span>* each_cmd = cmd_line;</span><br><span class="line">	 pipe_symbol = <span class="built_in">strchr</span>(each_cmd, <span class="string">'|'</span>);</span><br><span class="line">	 *pipe_symbol = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 执行第一个命令,命令的输出会写入环形缓冲区 */</span></span><br><span class="line">	 argc = <span class="number">-1</span>;</span><br><span class="line">	 argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">	 cmd_execute(argc, argv);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 跨过'|',处理下一个命令 */</span></span><br><span class="line">	 each_cmd = pipe_symbol + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 将标准输入重定向到fd[0],使之指向内核环形缓冲区*/</span></span><br><span class="line">	 fd_redirect(<span class="number">0</span>,fd[<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">/*3 中间的命令,命令的输入和输出都是指向环形缓冲区 */</span></span><br><span class="line">	 <span class="keyword">while</span> ((pipe_symbol = <span class="built_in">strchr</span>(each_cmd, <span class="string">'|'</span>))) &#123; </span><br><span class="line">	    *pipe_symbol = <span class="number">0</span>;</span><br><span class="line">	    argc = <span class="number">-1</span>;</span><br><span class="line">	    argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">	    cmd_execute(argc, argv);</span><br><span class="line">	    each_cmd = pipe_symbol + <span class="number">1</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*4 处理管道中最后一个命令 */</span></span><br><span class="line">	 <span class="comment">/* 将标准输出恢复屏幕 */</span></span><br><span class="line">         fd_redirect(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 执行最后一个命令 */</span></span><br><span class="line">	 argc = <span class="number">-1</span>;</span><br><span class="line">	 argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">	 cmd_execute(argc, argv);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*5  将标准输入恢复为键盘 */</span></span><br><span class="line">         fd_redirect(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*6 关闭管道 */</span></span><br><span class="line">	 close(fd[<span class="number">0</span>]);</span><br><span class="line">	 close(fd[<span class="number">1</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;		<span class="comment">// 一般无管道操作的命令</span></span><br><span class="line">	 argc = <span class="number">-1</span>;</span><br><span class="line">	 argc = cmd_parse(cmd_line, argv, <span class="string">' '</span>);</span><br><span class="line">	 <span class="keyword">if</span> (argc == <span class="number">-1</span>) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"num of arguments exceed %d\n"</span>, MAX_ARG_NR);</span><br><span class="line">	    <span class="keyword">continue</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 cmd_execute(argc, argv);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   panic(<span class="string">"my_shell: should not be here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后增加一个help功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 显示系统支持的内部命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_help</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   printk(<span class="string">"\</span></span><br><span class="line"><span class="string"> buildin commands:\n\</span></span><br><span class="line"><span class="string">       ls: show directory or file information\n\</span></span><br><span class="line"><span class="string">       cd: change current work directory\n\</span></span><br><span class="line"><span class="string">       mkdir: create a directory\n\</span></span><br><span class="line"><span class="string">       rmdir: remove a empty directory\n\</span></span><br><span class="line"><span class="string">       rm: remove a regular file\n\</span></span><br><span class="line"><span class="string">       pwd: show current work directory\n\</span></span><br><span class="line"><span class="string">       ps: show process information\n\</span></span><br><span class="line"><span class="string">       clear: clear screen\n\</span></span><br><span class="line"><span class="string"> shortcut key:\n\</span></span><br><span class="line"><span class="string">       ctrl+l: clear screen\n\</span></span><br><span class="line"><span class="string">       ctrl+u: clear input\n\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们测试一下</p>
<p><img src="/2020/06/11/简单内核实现笔记-part-4/120.png" alt="image-20200618104505278"></p>
<p>所有代码我打包在了 -&gt; <a href="https://github.com/ThunderJie/kernel" target="_blank" rel="noopener">这里</a></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OS-Learning/" rel="tag"><i class="fa fa-tag"></i> OS Learning</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/15/简单内核实现笔记-part-3/" rel="next" title="简单内核实现笔记-part-3">
                <i class="fa fa-chevron-left"></i> 简单内核实现笔记-part-3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2099/01/01/My-Articles/" rel="prev" title="My Articles">
                My Articles <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Thunder_J</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/ThunderJie" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/thunder-j/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-compass"></i>知乎</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://blog.csdn.net/CharlesGodX/" target="_blank" title="csdn"><i class="fa fa-fw fa-copyright"></i>csdn</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/ThunderJ17" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#编写硬盘驱动程序"><span class="nav-number">1.</span> <span class="nav-text">编写硬盘驱动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建新磁盘文件"><span class="nav-number">1.1.</span> <span class="nav-text">创建新磁盘文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建磁盘分区表"><span class="nav-number">1.2.</span> <span class="nav-text">创建磁盘分区表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写硬盘驱动"><span class="nav-number">1.3.</span> <span class="nav-text">编写硬盘驱动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完善基础构件"><span class="nav-number">1.4.</span> <span class="nav-text">完善基础构件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取硬盘信息和扫描分区表"><span class="nav-number">1.5.</span> <span class="nav-text">获取硬盘信息和扫描分区表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件系统"><span class="nav-number">2.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-number">2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建文件系统"><span class="nav-number">2.2.</span> <span class="nav-text">创建文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#挂载分区"><span class="nav-number">2.3.</span> <span class="nav-text">挂载分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件描述符"><span class="nav-number">2.4.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inode相关函数"><span class="nav-number">2.5.</span> <span class="nav-text">inode相关函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件相关函数"><span class="nav-number">2.6.</span> <span class="nav-text">文件相关函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目录相关函数"><span class="nav-number">2.7.</span> <span class="nav-text">目录相关函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路径解析相关函数"><span class="nav-number">2.8.</span> <span class="nav-text">路径解析相关函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现文件检索功能"><span class="nav-number">2.9.</span> <span class="nav-text">实现文件检索功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建文件"><span class="nav-number">2.10.</span> <span class="nav-text">创建文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现sys-open"><span class="nav-number">2.11.</span> <span class="nav-text">实现sys_open</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现sys-close"><span class="nav-number">2.12.</span> <span class="nav-text">实现sys_close</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现文件写入"><span class="nav-number">2.13.</span> <span class="nav-text">实现文件写入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读取文件"><span class="nav-number">2.14.</span> <span class="nav-text">读取文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现文件读写指针定位"><span class="nav-number">2.15.</span> <span class="nav-text">实现文件读写指针定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现文件删除"><span class="nav-number">2.16.</span> <span class="nav-text">实现文件删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建目录"><span class="nav-number">2.17.</span> <span class="nav-text">创建目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历目录"><span class="nav-number">2.18.</span> <span class="nav-text">遍历目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现sys-readdir及sys-rewinddir"><span class="nav-number">2.19.</span> <span class="nav-text">实现sys_readdir及sys_rewinddir</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除目录"><span class="nav-number">2.20.</span> <span class="nav-text">删除目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务工作目录"><span class="nav-number">2.21.</span> <span class="nav-text">任务工作目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获得文件属性"><span class="nav-number">2.22.</span> <span class="nav-text">获得文件属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#系统交互"><span class="nav-number">3.</span> <span class="nav-text">系统交互</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fork的原理"><span class="nav-number">3.1.</span> <span class="nav-text">fork的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fork的实现"><span class="nav-number">3.2.</span> <span class="nav-text">fork的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加read、putchar、clear系统调用"><span class="nav-number">3.3.</span> <span class="nav-text">添加read、putchar、clear系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell的实现"><span class="nav-number">3.4.</span> <span class="nav-text">shell的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加ctrl-u和ctrl-l"><span class="nav-number">3.4.1.</span> <span class="nav-text">添加ctrl+u和ctrl+l</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析键入字符"><span class="nav-number">3.4.2.</span> <span class="nav-text">解析键入字符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加系统调用"><span class="nav-number">3.5.</span> <span class="nav-text">添加系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路径解析"><span class="nav-number">3.6.</span> <span class="nav-text">路径解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载用户进程"><span class="nav-number">3.7.</span> <span class="nav-text">加载用户进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让shell支持外部命令"><span class="nav-number">3.8.</span> <span class="nav-text">让shell支持外部命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载硬盘上的用户程序执行"><span class="nav-number">3.9.</span> <span class="nav-text">加载硬盘上的用户程序执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#支持参数的用户程序"><span class="nav-number">3.10.</span> <span class="nav-text">支持参数的用户程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现wait和exit"><span class="nav-number">3.11.</span> <span class="nav-text">实现wait和exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现cat"><span class="nav-number">3.12.</span> <span class="nav-text">实现cat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道"><span class="nav-number">3.13.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#管道原理"><span class="nav-number">3.13.1.</span> <span class="nav-text">管道原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道实现"><span class="nav-number">3.13.2.</span> <span class="nav-text">管道实现</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thunder_J</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">637k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">9:39</span>
  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.2</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:
  <span id="busuanzi_value_site_uv"></span>
  人
</span>
</div>

<span id="busuanzi_container_site_pv">
    总访问量
    <span id="busuanzi_value_site_pv"></span>
    次
</span>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>