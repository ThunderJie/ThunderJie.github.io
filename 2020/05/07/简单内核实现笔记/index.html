<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="这一系列文章主要记录阅读《操作系统真相还原》一书的笔记，主要是记录实现部分，如果您觉得看着很唐突的话很正常，因为我主要是记录代码和实现的过程，如果您能直接看懂的话，那功力是比较深厚的了，不过如果您没看过这本书的话，我还是非常建议您看着这本书和我一起做实验。 本文主要记录阅读《操作系统真相还原》一书的笔记，主要是记录实现代码部分，如果您觉得看着很唐突的话很正常，因为我主要是记录代码和实现的过程，如果">
<meta name="keywords" content="OS Learning">
<meta property="og:type" content="article">
<meta property="og:title" content="简单内核实现笔记">
<meta property="og:url" content="http://yoursite.com/2020/05/07/简单内核实现笔记/index.html">
<meta property="og:site_name" content="Thunder_J">
<meta property="og:description" content="这一系列文章主要记录阅读《操作系统真相还原》一书的笔记，主要是记录实现部分，如果您觉得看着很唐突的话很正常，因为我主要是记录代码和实现的过程，如果您能直接看懂的话，那功力是比较深厚的了，不过如果您没看过这本书的话，我还是非常建议您看着这本书和我一起做实验。 本文主要记录阅读《操作系统真相还原》一书的笔记，主要是记录实现代码部分，如果您觉得看着很唐突的话很正常，因为我主要是记录代码和实现的过程，如果">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/1.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/2.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/3.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/4.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/5.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/6.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/7.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/8.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/9.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/10.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/11.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/12.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/13.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/14.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/15.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/16.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/17.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/18.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/19.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/20.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/21.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/22.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/23.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/24.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/25.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/26.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/27.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/28.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/29.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/30.png">
<meta property="og:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/31.png">
<meta property="og:updated_time" content="2020-05-08T06:58:12.220Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="简单内核实现笔记">
<meta name="twitter:description" content="这一系列文章主要记录阅读《操作系统真相还原》一书的笔记，主要是记录实现部分，如果您觉得看着很唐突的话很正常，因为我主要是记录代码和实现的过程，如果您能直接看懂的话，那功力是比较深厚的了，不过如果您没看过这本书的话，我还是非常建议您看着这本书和我一起做实验。 本文主要记录阅读《操作系统真相还原》一书的笔记，主要是记录实现代码部分，如果您觉得看着很唐突的话很正常，因为我主要是记录代码和实现的过程，如果">
<meta name="twitter:image" content="http://yoursite.com/2020/05/07/简单内核实现笔记/1.png">



  <link rel="alternate" href="/atom.xml" title="Thunder_J" type="application/atom+xml">




  <link rel="canonical" href="http://yoursite.com/2020/05/07/简单内核实现笔记/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>简单内核实现笔记 | Thunder_J</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Thunder_J</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Just for fun</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/简单内核实现笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Thunder_J">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thunder_J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">简单内核实现笔记
              
            
          </h1>
        

        <div class="post-meta">
		
		

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-07 11:12:03" itemprop="dateCreated datePublished" datetime="2020-05-07T11:12:03+08:00">2020-05-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-05-08 14:58:12" itemprop="dateModified" datetime="2020-05-08T14:58:12+08:00">2020-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">28k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">25 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这一系列文章主要记录阅读《操作系统真相还原》一书的笔记，主要是记录实现部分，如果您觉得看着很唐突的话很正常，因为我主要是记录代码和实现的过程，如果您能直接看懂的话，那功力是比较深厚的了，不过如果您没看过这本书的话，我还是非常建议您看着这本书和我一起做实验。</p>
<p>本文主要记录阅读《操作系统真相还原》一书的笔记，主要是记录实现代码部分，如果您觉得看着很唐突的话很正常，因为我主要是记录代码和实现的过程，如果您能直接看懂的话，那功力是比较深厚的了，不过如果您没看过这本书的话，我还是非常建议您看着这本书和我一起做实验。</p>
<p>很久之前就想要实现一个内核，就算是抄也想要抄一遍。我认为这是任何一个想深入理解内核的人都需要走的一步，Windows和Linux在很多方面是类似的，深入了解其底层原理，你会发现不过也就是一个软件罢了。至于为何要写一篇文章来记录这繁琐枯燥的过程，一方面是因为自己喜欢记录一些学习过程，之后不说100%，至少80%可能是会参考到的。另一方面自己很久之前也答应了一些人要写个内核，却迟迟没有开始，说到这我都不好意思了。</p>
<p>关于操作系统实现的书籍我自己的阅读顺序如下，我自己认为先从Linux平台下手再到Windows比较好，当然也有很多其他很好的书籍，像《一个64位操作系统的设计与实现》、《30天自制操作系统》等，我认为选个一两本就足够了，带着目的去读书最重要。Anyway 希望这系列文章能够帮到你 :)</p>
<blockquote>
<ol>
<li><p>《操作系统真相还原》</p>
</li>
<li><p>《x86汇编语言从实模式到保护模式》</p>
</li>
</ol>
</blockquote>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>实验环境如下</p>
<table>
<thead>
<tr>
<th>主机</th>
<th>虚拟机(Vmware 15.5.0 build)</th>
<th>实验机(Ubantu中安装)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows 10 1903 x64</td>
<td>Ubantu 16.04 x64</td>
<td>Bochs 2.6.2</td>
</tr>
</tbody>
</table>
<p>首先安装一系列依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line"></span><br><span class="line">sudo apt-get install xorg-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install bison</span><br><span class="line"></span><br><span class="line">sudo apt-get install libgtk2.0-dev</span><br></pre></td></tr></table></figure>
<p>放入网上下载好的bochs 2.6.2版本，解压安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf bochs-2.6.2.tar.gz</span><br><span class="line"></span><br><span class="line">cd bochs-2.6.2</span><br></pre></td></tr></table></figure>
<p>设置环境属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/home/guang/soft/bochs-2.6.2 \</span><br><span class="line">--enable-debugger \</span><br><span class="line">--enable-disasm \</span><br><span class="line">--enable-iodebug \</span><br><span class="line">--enable-x86-debugger \</span><br><span class="line">--with-x \</span><br><span class="line">--with-x11</span><br></pre></td></tr></table></figure>
<p>直接<code>sudo make</code>编译正常情况会出现以下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">Makefile:179: recipe for target &apos;bochs&apos; failed</span><br><span class="line">make: *** [bochs] Error 1</span><br></pre></td></tr></table></figure>
<p>找到Makefile文件<code>LIBS =</code>这句最后面添加上<code>-lpthread</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIBS =  -lm -lgtk-x11-2.0 -lgdk-x11-2.0 -lpangocairo-1.0 -latk-1.0 -lcairo -lgdk_pixbuf-2.0 -lgio-2.0 -lpangoft2-1.0 -lpango-1.0 -lgobject-2.0 -lglib-2.0 -lfontconfig -lfreetype -lpthread</span><br></pre></td></tr></table></figure>
<p>重新<code>sudo make</code>编译，然后<code>sudo make install</code>安装，在bochs目录下创建一个<code>bochsrc.disk</code>配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Configuration file for Bochs</span><br><span class="line"># 设置Bochs在运行过程中能够使用的内存: 32 MB</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line"># 设置真实机器的BIOS和VGA BIOS</span><br><span class="line"># 修改成你们对应的地址</span><br><span class="line"></span><br><span class="line">romimage: file=/home/guang/soft/bochs-2.6.2/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=/home/guang/soft/bochs-2.6.2/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"># 设置Bochs所使用的磁盘</span><br><span class="line"># 设置启动盘符</span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line"># 设置日志文件的输出</span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line"># 开启或关闭某些功能，修改成你们对应的地址</span><br><span class="line">mouse: enabled=0</span><br><span class="line">keyboard:keymap=/home/guang/soft/bochs-2.6.2/share/bochs/keymaps/x11-pc-us.map</span><br><span class="line"></span><br><span class="line"># 硬盘设置</span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line"></span><br><span class="line"># 增加gdb支持，这里添加会报错，暂时不需要</span><br><span class="line"># gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0</span><br></pre></td></tr></table></figure>
<p>运行即可，路径为<code>/home/guang/soft/bochs-2.6.2/bin</code>，之后的命令能加<code>sudo</code>的都加上，避免不必要的错误</p>
<p><img src="/2020/05/07/简单内核实现笔记/1.png" alt="image-20200429125517920"></p>
<p>第一次输入直接回车，第二次输入我们的bochsrc.disk即可设置我们初始化文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">You can also start bochs with the -q option to skip these menus.</span><br><span class="line"></span><br><span class="line">1. Restore factory default configuration</span><br><span class="line">2. Read options from...</span><br><span class="line">3. Edit options</span><br><span class="line">4. Save options to...</span><br><span class="line">5. Restore the Bochs state from...</span><br><span class="line">6. Begin simulation</span><br><span class="line">7. Quit now</span><br><span class="line"></span><br><span class="line">Please choose one: [2] // 直接回车</span><br><span class="line"></span><br><span class="line">What is the configuration file name?</span><br><span class="line">To cancel, type &apos;none&apos;. [none] bochsrc.disk // 输入我们刚才配置的文件即可</span><br><span class="line">00000000000i[     ] reading configuration from bochsrc.disk</span><br></pre></td></tr></table></figure>
<p>运行之后会中断提示<code>Mouse capture off</code>，这个时候输入c继续运行即可，运行成功如下图，这里会提示没有设置设备信息</p>
<p><img src="/2020/05/07/简单内核实现笔记/2.png" alt="image-20200429151727064"></p>
<p>设置设备需要运行<code>bximage</code>进行模拟，使用方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Usage: bximage [options] [filename]</span><br><span class="line"></span><br><span class="line">Supported options:</span><br><span class="line">  -fd              create floppy image                           // 创建软盘</span><br><span class="line">  -hd              create hard disk image                        // 创建硬盘</span><br><span class="line">  -mode=...        image mode (hard disks only)                  // 创建硬盘类型</span><br><span class="line">  -size=...        image size in megabytes                       // 创建大小</span><br><span class="line">  -q               quiet mode (don&apos;t prompt for user input)      // 以静默模式创建,不和用户交互</span><br><span class="line">  --help           display this help and exit</span><br></pre></td></tr></table></figure>
<p>如下方式创建名为<code>hd60M.img</code>的虚拟镜像</p>
<p><img src="/2020/05/07/简单内核实现笔记/3.png" alt="image-20200429153853374"></p>
<p>在之前的<code>bochsrc.disk</code>配置文件中添加一行<code>ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63</code>，重新指定配置文件运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./bochs -f bochsrc.disk</span><br></pre></td></tr></table></figure>
<p>再次报错，这次提示的错误和之前的不太一样，意思是这不是一个启动盘，后面我们需要编写具体的启动盘，故完成到这里环境搭建完毕</p>
<p><img src="/2020/05/07/简单内核实现笔记/4.png" alt="image-20200429191208677"></p>
<h1 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h1><h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>BIOS即输入输出系统，是按下主机键之后第一个运行的软件，其主要工作有</p>
<ul>
<li>调用检测、初始化硬件功能</li>
<li>建立中断向量表(IVT)</li>
<li>校验启动盘中位于0盘0道1扇区的内容</li>
</ul>
<p>实模式下的1MB内存布局如下，其中0～0x9FFFF处是DRAM，即动态随机访问内存，我们所装的物理内存就是DRAM，如DDR、DDR2等。顶部的0xF0000～0xFFFFF，这64KB的内存是ROM。</p>
<table>
<thead>
<tr>
<th><strong>起始</strong></th>
<th><strong>结束</strong></th>
<th><strong>大小</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>FFFF0</td>
<td>FFFFF</td>
<td>16B</td>
<td>BIOS入口地址，此地址也属于BIOS代码，同样属于顶部的640KB字节。只是为了强调其入口地址才单独贴出来。此处16字节的内容是跳转指令jmp f000：e05b</td>
</tr>
<tr>
<td>F0000</td>
<td>FFFEF</td>
<td>64KB-16B</td>
<td>系统BIOS范围是F0000～FFFFF共640KB，为说明入口地址，将最上面的16字节从此处去掉了，所以此处终止地址是0XFFFEF</td>
</tr>
<tr>
<td>C8000</td>
<td>EFFFF</td>
<td>160KB</td>
<td>映射硬件适配器的ROM或内存映射式I/O</td>
</tr>
<tr>
<td>C0000</td>
<td>C7FFF</td>
<td>32KB</td>
<td>显示适配器BIOS</td>
</tr>
<tr>
<td>B8000</td>
<td>BFFFF</td>
<td>32KB</td>
<td>用于文本模式显示适配器</td>
</tr>
<tr>
<td>B0000</td>
<td>B7FFF</td>
<td>32KB</td>
<td>用于黑白显示适配器</td>
</tr>
<tr>
<td>A0000</td>
<td>AFFFF</td>
<td>64KB</td>
<td>用于彩色显示适配器</td>
</tr>
<tr>
<td>9FC00</td>
<td>9FFFF</td>
<td>1KB</td>
<td>EBDA（Extended BIOS Data Area）扩展BIOS数据区</td>
</tr>
<tr>
<td>7E00</td>
<td>9FBFF</td>
<td>622080B约608KB</td>
<td>可用区域</td>
</tr>
<tr>
<td>7C00</td>
<td>7DFF</td>
<td>512B</td>
<td>MBR被BIOS加载到此处，共512字节</td>
</tr>
<tr>
<td>500</td>
<td>7BFF</td>
<td>30464B约30KB</td>
<td>可用区域</td>
</tr>
<tr>
<td>400</td>
<td>4FF</td>
<td>256B</td>
<td>BIOS Data Area（BIOS数据区）</td>
</tr>
<tr>
<td>000</td>
<td>3FF</td>
<td>1KB</td>
<td>Interrupt Vector Table（中断向量表）</td>
</tr>
</tbody>
</table>
<p>BIOS因为是第一个运行的软件，故需要用硬件对其加载到ROM(0xF0000~0xFFFFF)中，其入口点是0xFFFF0(CPU通过段地址+偏移地址即可访问)，因为自己还没有加载起来，想要直接定位到0xFFFF0靠自己肯定是不行的，故也需要硬件来操作，使开机的时候强制将<code>CS:IP</code>置为<code>0xF000:0xFFF0</code>，实模式段基址需要乘16(左移四位)，故起始地址为0xFFFF0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0xF000 &lt;&lt; 4) + 0xFFF0 = 0xFFFF0</span><br></pre></td></tr></table></figure>
<p>这个起始地址距离1MB内存只有16字节大小，所以这里肯定不是真正实现BIOS的地方，这里肯定只是一个类似于函数索引表的跳板，跳转到真正执行BIOS的地方。</p>
<p>BIOS最后的工作就是校验启动盘中位于0盘0道1扇区的内容，这里面其实主要校验的是MBR，如果此扇区末尾两个字节为0x55和0xaa，BIOS即认定这里为MBR，便将其加载到0x7c00处，然后跳转到这个地方继续执行。至于为什么这里是0x7c00书中也有提到，主要是考虑到不能覆盖中断向量表、预留栈空间等，BIOS大致流程也差不多总结到这里。下一步就是做实验。</p>
<h2 id="第一个MBR"><a href="#第一个MBR" class="headerlink" title="第一个MBR"></a>第一个MBR</h2><p>这里用NASM实现一个简单的MBR，功能是在屏幕上打印字符串”1 MBR”，背景色黑色，前景色绿色，因为有中文格式问题，复制的时候建议去除所有中文以及注释，当然最好是自己敲一遍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">; mbr.S</span><br><span class="line">; 主引导程序</span><br><span class="line">; ----------------------------------------------------------</span><br><span class="line">SECTION MBR vstart=0x7c00 ; 起始地址为0x7c00</span><br><span class="line">　 mov ax,cs              ; cs寄存器初始化其他寄存器</span><br><span class="line">　 mov ds,ax</span><br><span class="line">　 mov es,ax</span><br><span class="line">　 mov ss,ax</span><br><span class="line">　 mov fs,ax</span><br><span class="line">　 mov sp,0x7c00           ; 初始化栈指针</span><br><span class="line"></span><br><span class="line">; 下面功能为清屏,清理其他输出信息,保证我们输出的内容可见+</span><br><span class="line"></span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">; INT 0x10　 功能号:0x06　　功能描述:上卷窗口</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">; AH 功能号= 0x06</span><br><span class="line">; AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">; BH = 上卷行属性</span><br><span class="line">; (CL,CH) = 窗口左上角的(X,Y)位置</span><br><span class="line">; (DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">; 无返回值</span><br><span class="line">　 mov　　 ax, 0x600</span><br><span class="line">　 mov　　 bx, 0x700</span><br><span class="line">　 mov　　 cx, 0               ; 左上角: (0, 0)</span><br><span class="line">　 mov　　 dx, 0x184f          ; 右下角: (80,25),</span><br><span class="line">                              ; VGA文本模式中,一行只能容纳80个字符,共25行｡</span><br><span class="line">　　　　　　　　　　　　　　　　 ; 下标从0开始,所以0x18=24,0x4f=79</span><br><span class="line">　 int　　 0x10　　　　　　　　 ; int 0x10</span><br><span class="line"></span><br><span class="line">;;;;;;;;;　　下面这三行代码获取光标位置　　;;;;;;;;;</span><br><span class="line">;.get_cursor获取当前光标位置,在光标位置处打印字符｡</span><br><span class="line">　 mov ah, 3　　　　　　   　　 ; 输入: 3号子功能是获取光标位置,需要存入ah寄存器</span><br><span class="line">　 mov bh, 0　　　　　　　　　  ; bh寄存器存储的是待获取光标的页号,这里是第0页</span><br><span class="line"></span><br><span class="line">　 int 0x10　　　　　　 　　　　; 输出: ch=光标开始行,cl=光标结束行</span><br><span class="line">　　　　　　　　　　　 　  　　　; dh=光标所在行号,dl=光标所在列号</span><br><span class="line"></span><br><span class="line">;;;;;;;;;　　获取光标位置结束　　;;;;;;;;;</span><br><span class="line"></span><br><span class="line">;;;;;;;;;　　打印字符串　　;;;;;;;;;</span><br><span class="line">　 ;还是用10h中断,不过这次调用13号子功能打印字符串</span><br><span class="line">　 mov ax, message</span><br><span class="line">　 mov bp, ax　　　　　 　　　　; es:bp 为串首地址,es此时同cs一致,</span><br><span class="line">　　　　　　　　　　　 　　　　  ; 开头时已经为sreg初始化</span><br><span class="line"></span><br><span class="line">   ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略</span><br><span class="line">　 mov cx, 5　　　　　　　　　　; cx 为串长度,不包括结束符0的字符个数</span><br><span class="line">　 mov ax, 0x1301　 　　　　   ; 子功能号13显示字符及属性,要存入ah寄存器,</span><br><span class="line">　　　　　　　　　　　　　  　　 ; al设置写字符方式 ah=01: 显示字符串,光标跟随移动</span><br><span class="line">　 mov bx, 0x2　　　　　　　　　; bh存储要显示的页号,此处是第0页,</span><br><span class="line">　　　　　　　　　　　 　　　　  ; bl中是字符属性,属性黑底绿字(bl = 02h)</span><br><span class="line">　 int 0x10　　　　　　 　　　　; 执行BIOS 0x10 号中断</span><br><span class="line">;;;;;;;;;　　打字字符串结束　　;;;;;;;;;</span><br><span class="line">                              ; $为eip地址,$$为本section的起始地址</span><br><span class="line">　 jmp $　　　　　　　　　　　　; 使程序无限循环,相当于jmp eip</span><br><span class="line"></span><br><span class="line">　 message db &quot;1 MBR&quot;         ; 打印的字符串</span><br><span class="line">　 times 510-($-$$) db 0      ; 用0填充本扇区空余的字节数,$-$$即为本行到本section的偏移</span><br><span class="line">　                            ; 510减去是为了腾出2字节存放0x55和0xaa魔数</span><br><span class="line">　                            ; 也就是覆盖除了最后两字节和上面已经写了的字节</span><br><span class="line">　 db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>命令<code>sudo nasm -o mbr.bin mbr.S</code>编译生成<code>mbr.bin</code>文件，然后用dd命令将其写入我们镜像中的第0行，512字节大小，也就是写入一开始BIOS执行的MBR</p>
<p><img src="/2020/05/07/简单内核实现笔记/5.png" alt="image-20200430104313495"></p>
<p>再次运行<code>sudo ./bochs -f bochsrc.disk</code>即可显示出我们写的内容，断下的时候输入c即可运行</p>
<p><img src="/2020/05/07/简单内核实现笔记/6.png" alt="image-20200430104739183"></p>
<h2 id="完善MBR"><a href="#完善MBR" class="headerlink" title="完善MBR"></a>完善MBR</h2><p>这里介绍一些显存相关内容，显存地址分布</p>
<table>
<thead>
<tr>
<th>起始</th>
<th>结束</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>C0000</td>
<td>C7FFF</td>
<td>32KB</td>
<td>显示适配器BIOS</td>
</tr>
<tr>
<td>B8000</td>
<td>BFFFF</td>
<td>32KB</td>
<td>用于文本模式显示适配器</td>
</tr>
<tr>
<td>B0000</td>
<td>B7FFF</td>
<td>32KB</td>
<td>用于黑白显示适配器</td>
</tr>
<tr>
<td>A0000</td>
<td>AFFFF</td>
<td>64KB</td>
<td>用于彩色显示适配器</td>
</tr>
</tbody>
</table>
<p>根据上表地址直接操作显卡显示文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序 </span><br><span class="line">;------------------------------------------------------------</span><br><span class="line">SECTION MBR vstart=0x7c00         </span><br><span class="line">   mov ax,cs      </span><br><span class="line">   mov ds,ax</span><br><span class="line">   mov es,ax</span><br><span class="line">   mov ss,ax</span><br><span class="line">   mov fs,ax</span><br><span class="line">   mov sp,0x7c00</span><br><span class="line">   mov ax,0xb800 ;参考上表的基址</span><br><span class="line">   mov gs,ax</span><br><span class="line"></span><br><span class="line">; 清屏</span><br><span class="line">;利用0x06号功能，上卷全部行，则可清屏。</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">;INT 0x10   功能号:0x06	   功能描述:上卷窗口</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;输入：</span><br><span class="line">;AH 功能号= 0x06</span><br><span class="line">;AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角的(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值：</span><br><span class="line">   mov     ax, 0600h</span><br><span class="line">   mov     bx, 0700h</span><br><span class="line">   mov     cx, 0               ; 左上角: (0, 0)</span><br><span class="line">   mov     dx, 184fh	       ; 右下角: (80,25),</span><br><span class="line">			       ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。</span><br><span class="line">			       ; 下标从0开始，所以0x18=24,0x4f=79</span><br><span class="line">   int     10h                 ; int 10h</span><br><span class="line"></span><br><span class="line">   ; 输出背景色绿色，前景色红色，并且跳动的字符串&quot;1 MBR&quot;</span><br><span class="line">   mov byte [gs:0x00],&apos;1&apos;      ; 一字节为数据,一字节为属性</span><br><span class="line">   mov byte [gs:0x01],0xA4     ; A表示绿色背景闪烁，4表示前景色为红色</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x02],&apos; &apos;</span><br><span class="line">   mov byte [gs:0x03],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x04],&apos;M&apos;</span><br><span class="line">   mov byte [gs:0x05],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x06],&apos;B&apos;</span><br><span class="line">   mov byte [gs:0x07],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x08],&apos;R&apos;</span><br><span class="line">   mov byte [gs:0x09],0xA4</span><br><span class="line"></span><br><span class="line">   jmp $		       ; 通过死循环使程序悬停在此</span><br><span class="line"></span><br><span class="line">   times 510-($-$$) db 0</span><br><span class="line">   db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>效果如下，红色字体，绿色背景闪烁</p>
<p><img src="/2020/05/07/简单内核实现笔记/7.png" alt="image-20200504083137724"></p>
<p>上面MBR实际上没做什么事情，只是单纯的实现了和显卡交互，和打印hello world区别不是很大，我们需要不断增加新的有实际用处的功能，MBR只有512字节，无法实现对内核的加载，所以我们下一步需要让其增加读写磁盘的功能，在硬盘中加载loader，然后用loader来加载我们的内核。</p>
<p>MBR在第0扇区(逻辑LBA编号)，loader理论上可以在1扇区，这里为了安全起见放在2扇区，预留出1扇区的空位。MBR将二扇区的内容读出来，放入实模式1MB内存分布中的可用区域(参见BIOS处的表格)，因为loader中还会加载一些GDT等的描述符表，这些表不能被覆盖，随着内核越来越完整，loader的内核也不断从低地址向高地址发展，所以需要选择一个稍安全的地方，留出一些空位，这里选择0x900，大致步骤如下：</p>
<ol>
<li><p>先选择通道，往该通道的sector count寄存器中写入待操作的扇区数，参考如下表格找到端口</p>
<p><img src="/2020/05/07/简单内核实现笔记/8.png" alt="img"></p>
</li>
<li><p>往该通道上的三个LBA寄存器写入扇区起始地址的低24位。</p>
</li>
<li><p>往device寄存器中写入LBA地址的24~27位，并置第6位为1，使其为LBA模式，设置第4位，选择操作的硬盘（master硬盘或slave硬盘）。</p>
</li>
<li><p>往该通道上的command寄存器写入操作命令。</p>
</li>
<li><p>读取该通道上的status寄存器，判断硬盘工作是否完成。</p>
</li>
<li><p>如果以上步骤是读硬盘，进入下一个步骤。否则，完工。</p>
</li>
<li><p>将硬盘数据读出。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序 </span><br><span class="line">;------------------------------------------------------------</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">SECTION MBR vstart=0x7c00         </span><br><span class="line">   mov ax,cs      </span><br><span class="line">   mov ds,ax</span><br><span class="line">   mov es,ax</span><br><span class="line">   mov ss,ax</span><br><span class="line">   mov fs,ax</span><br><span class="line">   mov sp,0x7c00</span><br><span class="line">   mov ax,0xb800</span><br><span class="line">   mov gs,ax</span><br><span class="line"></span><br><span class="line">;清屏</span><br><span class="line">;利用0x06号功能，上卷全部行，则可清屏。</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">;INT 0x10   功能号:0x06	   功能描述:上卷窗口</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;输入：</span><br><span class="line">;AH 功能号= 0x06</span><br><span class="line">;AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角的(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值：</span><br><span class="line">   mov     ax, 0600h</span><br><span class="line">   mov     bx, 0700h</span><br><span class="line">   mov     cx, 0                   ; 左上角: (0, 0)</span><br><span class="line">   mov     dx, 184fh		      ; 右下角: (80,25),</span><br><span class="line">				   ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。</span><br><span class="line">				   ; 下标从0开始，所以0x18=24,0x4f=79</span><br><span class="line">   int     10h                     ; int 10h</span><br><span class="line"></span><br><span class="line">   ; 输出字符串:MBR</span><br><span class="line">   mov byte [gs:0x00],&apos;1&apos;</span><br><span class="line">   mov byte [gs:0x01],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x02],&apos; &apos;</span><br><span class="line">   mov byte [gs:0x03],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x04],&apos;M&apos;</span><br><span class="line">   mov byte [gs:0x05],0xA4	   ;A表示绿色背景闪烁，4表示前景色为红色</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x06],&apos;B&apos;</span><br><span class="line">   mov byte [gs:0x07],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x08],&apos;R&apos;</span><br><span class="line">   mov byte [gs:0x09],0xA4</span><br><span class="line">   ; 寄存器传三个参数</span><br><span class="line">   mov eax,LOADER_START_SECTOR	 ; 起始扇区LBA地址</span><br><span class="line">   mov bx,LOADER_BASE_ADDR       ; 写入的地址</span><br><span class="line">   mov cx,1			            ; 待读入的扇区数,这里是简单的loader故一个扇区足够</span><br><span class="line">   call rd_disk_m_16		    ; 以下读取程序的起始部分（一个扇区）</span><br><span class="line">  </span><br><span class="line">   jmp LOADER_BASE_ADDR</span><br><span class="line">       </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;功能:读取硬盘n个扇区</span><br><span class="line">rd_disk_m_16:	   </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">				       ; eax=LBA扇区号</span><br><span class="line">				       ; ebx=将数据写入的内存地址</span><br><span class="line">				       ; ecx=读入的扇区数</span><br><span class="line">      mov esi,eax	  ;备份eax</span><br><span class="line">      mov di,cx		  ;备份cx</span><br><span class="line">;读写硬盘:</span><br><span class="line">;第1步：选择通道，往该通道的sector count寄存器中写入待操作的扇区数</span><br><span class="line">;因为bochs配置文件中虚拟硬盘属于ata0,是Primary通道,所以sector count寄存器由0x1f2端口访问</span><br><span class="line">      mov dx,0x1f2</span><br><span class="line">      mov al,cl</span><br><span class="line">      out dx,al            ;读取的扇区数</span><br><span class="line">      ;out 往端口中写数据</span><br><span class="line">      ;in  从端口中读数据</span><br><span class="line"></span><br><span class="line">      mov eax,esi	   ;恢复ax</span><br><span class="line"></span><br><span class="line">;第2步：将LBA地址写入三个LBA寄存器和device寄存器的低4位</span><br><span class="line"></span><br><span class="line">      ;LBA地址7~0位写入端口0x1f3</span><br><span class="line">      mov dx,0x1f3                       </span><br><span class="line">      out dx,al                          </span><br><span class="line"></span><br><span class="line">      ;LBA地址15~8位写入端口0x1f4</span><br><span class="line">      mov cl,8</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f4</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      ;LBA地址23~16位写入端口0x1f5</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f5</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      shr eax,cl</span><br><span class="line">      and al,0x0f	   ; lba第24~27位</span><br><span class="line">      or al,0xe0	   ; 设置7～4位为1110,表示lba模式</span><br><span class="line">      mov dx,0x1f6</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第3步：向command寄存器写入读命令，0x20 </span><br><span class="line">      mov dx,0x1f7 ;要写入的端口</span><br><span class="line">      mov al,0x20  ;要写入的数据          </span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第4步：检测硬盘状态，读取该通道上的status寄存器，判断硬盘工作是否完成</span><br><span class="line">  .not_ready:</span><br><span class="line">      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态</span><br><span class="line">      nop</span><br><span class="line">      in al,dx</span><br><span class="line">      and al,0x88	       ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙</span><br><span class="line">      cmp al,0x08</span><br><span class="line">      jnz .not_ready	   ;若未准备好，继续等。</span><br><span class="line"></span><br><span class="line">;第5步：从0x1f0端口读数据</span><br><span class="line">      mov ax, di</span><br><span class="line">      mov dx, 256</span><br><span class="line">      mul dx</span><br><span class="line">      mov cx, ax	   ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，</span><br><span class="line">			          ; 共需di*512/2次，所以di*256</span><br><span class="line">      mov dx, 0x1f0</span><br><span class="line">  .go_on_read: ; 循环写入bx指向的内存</span><br><span class="line">      in ax,dx</span><br><span class="line">      mov [bx],ax</span><br><span class="line">      add bx,2		  </span><br><span class="line">      loop .go_on_read</span><br><span class="line">      ret</span><br><span class="line"></span><br><span class="line">   times 510-($-$$) db 0</span><br><span class="line">   db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>我们需要在<code>boot.inc</code>中指定两句头文件参数，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOADER_BASE_ADDR equ 0x900</span><br><span class="line">LOADER_START_SECTOR equ 0x2</span><br></pre></td></tr></table></figure>
<p>这里编译需要加一个<code>-I</code>参数，这里我将<code>boot.inc</code>放在<code>include</code>目录下</p>
<p><img src="/2020/05/07/简单内核实现笔记/9.png" alt="image-20200505092951970"></p>
<p>编译成功之后，发现我们还没有写loader，这会导致CPU跳转到<code>0x900</code>处的地方，所以下一步我们就需要实现一个简单的loader，至少保证能简单运行下去。复习一下现在位置我们所知道的开机流程：BIOS -&gt; MBR -&gt; Loader</p>
<p>loader中的内容我们用之前MBR的即可，这里编译也是需要<code>sudo nasm -I include/ -o loader.bin loader.S</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">section loader vstart=LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x00],&apos;2&apos;</span><br><span class="line">mov byte [gs:0x01],0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x02],&apos; &apos;</span><br><span class="line">mov byte [gs:0x03],0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x04],&apos;L&apos;</span><br><span class="line">mov byte [gs:0x05],0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x06],&apos;O&apos;</span><br><span class="line">mov byte [gs:0x07],0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x08],&apos;A&apos;</span><br><span class="line">mov byte [gs:0x09],0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x0a],&apos;D&apos;</span><br><span class="line">mov byte [gs:0x0b],0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x0c],&apos;E&apos;</span><br><span class="line">mov byte [gs:0x0d],0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x0e],&apos;R&apos;</span><br><span class="line">mov byte [gs:0x0f],0xA4</span><br><span class="line"></span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure>
<p>dd命令指定seek参数将其放入第二个扇区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if=./loader.bin of=/home/guang/soft/bochs-2.6.2/bin/hd60M.img bs=512 count=1 seek=2 conv=notrunc</span><br></pre></td></tr></table></figure>
<p>最后的运行效果如下</p>
<p><img src="/2020/05/07/简单内核实现笔记/10.png" alt="image-20200505130009352"></p>
<p>实模式的安全缺陷总结：</p>
<ol>
<li>操作系统和用户属于同一特权级</li>
<li>用户程序引用的地址都是指向真实的物理地址</li>
<li>用户程序可以自由修改段基址，自由访问所有内存</li>
</ol>
<h1 id="保护模式初探"><a href="#保护模式初探" class="headerlink" title="保护模式初探"></a>保护模式初探</h1><p>32位CPU在16位模式下运行的状态为实模式，当CPU发展到32位的时候出现保护模式，保护模式下CPU变成了32根地址总线，32根地址总线足够访问4GB的空间，为了满足4GB空间寻址，寄存器宽度也增加了一倍，从原来的2字节变为4字节32位。除了段寄存器仍然使用16位，其余通用寄存器都提升到32位。<br>寄存器要保持向下兼容，不会重新构造原来的基础设备而是在原有的寄存器基础上进行了拓展。经过拓展后的寄存器在原有名字上加了个e，如图所示</p>
<p><img src="/2020/05/07/简单内核实现笔记/11.png" alt></p>
<h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p>保护模式中的段基址不再是像实模式那样直接存放物理地址，段寄存器中要记录32位地址的数据段基址，16位肯定是装不下的，所以段基址都存储在一个数据结构中——全局描述符表。其中每个表项称为段描述符，其大小为64字节，用来描述各个内存段的起始地址、大小、权限等信息。而这里段寄存器中存放的是段选择子 selector 。如果把全局描述符表当作数组来看的话，段选择子就是数组的下标，用来索引段描述符。该全局描述符表很大，所以放在内存中，由GDTR寄存器指向它。</p>
<p>Tip：因为段描述符是在内存中，CPU访问较慢，效率不高，故在80286的保护模式中增加了一个段描述符缓冲寄存器用来提高效率。CPU每次将获取到的内存信息整理之后存入此寄存器，之后每次访问相同的段时，直接读取对应的段描述符缓冲寄存器即可。</p>
<p>因为80286始终是16位CPU，通用寄存器还是16位宽，寻址空间为2的24次方也就是16MB，单个寄存器依旧无法访问到全部内存空间，这就有了80386的登场，参数总结如下</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>CPU位数</th>
<th>寄存器宽</th>
<th>地址线宽</th>
<th>寻址空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>8086</td>
<td>16</td>
<td>16</td>
<td>20</td>
<td>2^20 = 1MB</td>
</tr>
<tr>
<td>80286</td>
<td>16</td>
<td>16</td>
<td>24</td>
<td>2^24 = 16MB</td>
</tr>
<tr>
<td>80386</td>
<td>32</td>
<td>32</td>
<td>32</td>
<td>2^32 = 4GB</td>
</tr>
</tbody>
</table>
<p>实模式和保护模式的内存寻址方式如下图所示</p>
<p><img src="/2020/05/07/简单内核实现笔记/12.png" alt></p>
<p>32位CPU既支持实模式有支持保护模式，为了区分当前指令到底是哪个模式下运行的，编译器提供了伪指令<code>bits</code></p>
<blockquote>
<p>指令格式：[bits 16]或[bits 32]，分别对应16位和32位</p>
</blockquote>
<p>如下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[bits 16]</span><br><span class="line">mov ax, 0x1234</span><br><span class="line">mov dx, 0x1234</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">mov eax, 0x1234</span><br><span class="line">mov edx, 0x1234</span><br></pre></td></tr></table></figure>
<p>模式之间可以相互使用对方环境下的资源。比如，16位实模式下可以使用32位保护模式下的寄存器。如果要用另一模式下的操作数大小，需要在指令前添加指令前缀0x66，将当前指令模式临时转变为另一种模式。这就是反转的意义，不管当前模式是什么，总是转变成相反的运行模式。这个转换是临时的，只有在当前指令才有效。如下图<br>比如，在指令中添加了0x66反转前缀后：<br>假如当前运行模式是16位实模式，操作数大小变为32位。<br>假设当前运行模式是32位保护模式，操作数大小变为16位。</p>
<p><img src="/2020/05/07/简单内核实现笔记/13.png" alt></p>
<p>操作数可以在模式间相互转换，那么寻址方式一样可以，只需要在它的指令前加上0x67反转前缀即可。如下图</p>
<p><img src="/2020/05/07/简单内核实现笔记/14.png" alt></p>
<p>下面总结一下，保护模式首先是必须向前兼容的，故其访问内存依然是<code>段基址:段内偏移</code>的方式，结合前面总结过实模式的一些安全问题，想要解决这些问题就得既保证向前兼容，又保证安全性。CPU工程师想到的方法就是增加更多的安全属性位，下图即是段描述符格式：</p>
<p><img src="/2020/05/07/简单内核实现笔记/15.png" alt></p>
<p>其实对于各个字段的解释，我更倾向于用的时候去查，因为随着CPU的更新换代，如今的一些位可能有变化，要参考当然是参考最新的比较好，比如参考intel手册之类的权威资料，无非就是保存一些段的属性(可读、可写、是否存在等)，权限(Ring0-Ring3)，基址，界限范围等信息。其访问内存的形式如下图所示</p>
<p><img src="/2020/05/07/简单内核实现笔记/16.png" alt></p>
<h2 id="全局描述符"><a href="#全局描述符" class="headerlink" title="全局描述符"></a>全局描述符</h2><p>全局描述符表GDT相当于是一个描述符的数组，数组每一个元素都是8个字节的描述符，而选择子则是提供下标在GDT中索引描述符。假设 A[10] 数组即为GDT表，则</p>
<ul>
<li>GDT表相当于数组A</li>
<li>数组中每个数据A[0]~A[10]相当于描述符</li>
<li>A[0]~A[10]中的0~10索引下标则是选择子</li>
</ul>
<p>全局描述符表是公用的，GDTR这个专门的寄存器则存放GDT表的内存地址和大小，是一个48位的寄存器，对这个寄存器操作无法用mov等指令，这里用的是<code>lgdt</code>指令初始化，指令格式是：<code>lgdt 48位内存数据</code></p>
<p><img src="/2020/05/07/简单内核实现笔记/17.png" alt></p>
<p>其中前16位是GDT以字节为单位的界限值，相当于GDT字节大小减1。后32位是GDT的起始地址。由于GDT的大小是16位二进制，表示范围是2^16 = 65536字节。每个描述符大小是8字节，故GDT中最多可容纳的描述符数量是<code>65536/8 = 8198</code>，也就是可以容纳8192个段或门。</p>
<h2 id="局部描述符表"><a href="#局部描述符表" class="headerlink" title="局部描述符表"></a>局部描述符表</h2><p>按照CPU的设想，一个任务对应一个局部描述符表LDT，切换任务的时候也会切换LDT，LDT也存放在内存中，由LDTR寄存器指向，加载的指令为<code>lldt</code>。对于操作系统来说，每个系统必须定义一个GDT，用于系统中的所有任务和程序。可选择性定义若干个LDT。LDT本身是一个段，而GDT不是。这种表在这里并不常用所以就不继续展开了，感兴趣的小伙伴可以自行百度。</p>
<h2 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h2><p>首先复习一下段寄存器CS、DS、ES、FS、GS、SS，保护模式下段寄存器中存放的即是段选择子，结构如下，其中0-1位表示特权级，2位TI表示选择子是在GDT中，还是在LDT中索引描述符，剩下的13位就是索引部分，2^13 = 8192，这也刚好和GDT最多容纳的段或门的数量相符。</p>
<p><img src="/2020/05/07/简单内核实现笔记/18.png" alt></p>
<p>举个访问内存的例子，例如选择子是 0x8，将其加载到 ds 寄存器后，访问 ds: 0x9 这样的内存，其过程是首先拆分 0x8 为二进制 <code>0000 0000 0000 1000</code> 然后得到 0x8 的低 2 位是RPL，其值为 00。第 2 是 TI ，其值 0，表示是在 GOT 中索引段描述符。用 0x8 的高 13 位 0x1 在 GOT 中索引，也就是 GOT 中的第 1 个段描述符(GDT 中第 0 个段描述符不可用)。假设第 1 个段描述符中的 3个段基址部分，其值为 0xl234oCPU 将 0xl234 作为段基址，与段内偏移地址 0x9 相加， <code>0x1234 + 0x9 = 0x123d</code>。用所得的和 0x123d 作为访存地址。</p>
<p>Tip：GDT中第0个段描述符不可用是为了防止未初始化段选择子，如果未初始化段选择子就会访问到第0个段描述符从而抛出异常。</p>
<p>为了让<code>段基址:段内偏移</code>策略继续可用，CPU采取的做法是将超过1MB的部分自动绕回到0地址，继续从0地址开始映射。相当于把地址对1MB求模。超过1MB多余出来的内存被称为高端内存区HMA。</p>
<p>这种地址绕回的做法需要通过两种情况分别讨论：</p>
<ul>
<li><p>对于只有20位地址线的CPU，不需要任何操作便能自动实现地址绕回</p>
</li>
<li><p>当其他有更多地址总线的时候，因为CPU可以访问更多的内存，所以不会产生地址回滚。这种情况下的解决方案就是对第21根地址线进行操作。开启A20则直接访问物理地址即可，关闭A20则使用回绕方式访问。</p>
</li>
</ul>
<p>打开A20的操作方法有以下三个步骤，主要是将0x92端口第一位置一即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in al, 0x92</span><br><span class="line">or al, 0000_0010B</span><br><span class="line">out 0x92, al</span><br></pre></td></tr></table></figure>
<h2 id="CR0寄存器"><a href="#CR0寄存器" class="headerlink" title="CR0寄存器"></a>CR0寄存器</h2><p>CRx系列寄存器属于控制寄存器一类，这里主要介绍CR0寄存器，这个寄存器如下图所示，其中第0位PE位表示是否开启保护模式</p>
<p><img src="/2020/05/07/简单内核实现笔记/19.png" alt></p>
<p>其他位如下图所示，这里暂时不深入讨论</p>
<p><img src="/2020/05/07/简单内核实现笔记/20.png" alt></p>
<p>对CR0的PE位操作如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9mov eax,cr0</span><br><span class="line">or eax,0x00000001</span><br><span class="line">mov cr0,eax</span><br></pre></td></tr></table></figure>
<h2 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h2><p>现在基础知识总结的差不多了，进入下一个实验阶段，更新我们的mbr和loader，因为我们的loader.bin会超过512字节，所以要把mbr.S中加载loader.bin的读入扇区数增大，目前是1扇区，这里直接改为4扇区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">52 mov cx, 4         ; 带读入的扇区数</span><br><span class="line">53 call rd_disk_m_16 ; 以下读取程序的起始部分(一个扇区)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如下图所示，cx 寄存器中存放的这个参数非常重要，代表读入扇区数，如果<code>loader.bin</code>的大小超过mbr读入的扇区数，就需要对这个参数进行修改</p>
<p><img src="/2020/05/07/简单内核实现笔记/21.png" alt="image-20200506225157139"></p>
<p>接下来就是更新<code>boot.inc</code>，里面存放的是<code>loader.S</code>的一些符号信息，相当于头文件，比之前主要多定义了GDT描述符的属性和选择子的属性。Linux使用的是平坦模型，整个内存都在一个段里，这里平坦模型在我们定义的描述符中，段基址是0，<code>段界限 * 粒度 = 4G</code> 粒度选的是4k，故段界限是 0xFFFFF</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">;--------------------- loader 和 kernel---------------------</span><br><span class="line"></span><br><span class="line">LOADER_BASE_ADDR equ 0x900</span><br><span class="line">LOADER_START_SECTOR equ 0x2</span><br><span class="line"></span><br><span class="line">;--------------------  gdt 描述符属性  ----------------------</span><br><span class="line">DESC_G_4K         equ 1_00000000000000000000000b        ;描述符的G位为4k粒度，以二进制表示，下划线可去掉</span><br><span class="line">DESC_D_32         equ  1_0000000000000000000000b</span><br><span class="line">DESC_L            equ   0_000000000000000000000b        ;64位代码标记，此处标记为0便可</span><br><span class="line">DESC_AVL          equ    0_00000000000000000000b        ;CPU不用此位，暂置为0</span><br><span class="line">DESC_LIMIT_CODE2  equ     1111_0000000000000000b        ;段界限，需要设置为0xFFFFF</span><br><span class="line">DESC_LIMIT_DATA2  equ     DESC_LIMIT_CODE2</span><br><span class="line">DESC_LIMIT_VIDEO2 equ      0000_000000000000000b</span><br><span class="line">DESC_P			  equ         1_000000000000000b</span><br><span class="line">DESC_DPL_0        equ          00_0000000000000b</span><br><span class="line">DESC_DPL_1		  equ          01_0000000000000b</span><br><span class="line">DESC_DPL_2        equ		   10_0000000000000b</span><br><span class="line">DESC_DPL_3        equ          11_0000000000000b</span><br><span class="line">DESC_S_CODE		  equ            1_000000000000b</span><br><span class="line">DESC_S_DATA       equ            DESC_S_CODE</span><br><span class="line">DESC_S_sys        equ            0_000000000000b</span><br><span class="line">DESC_TYPE_CODE    equ             1000_00000000b		;x=1,c=0,r=0,a=0 代码段是可执行的,非一致性,不可读,已访问位a清0.  </span><br><span class="line">DESC_TYPE_DATA    equ             0010_00000000b		;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写,已访问位a清0.</span><br><span class="line"></span><br><span class="line">DESC_CODE_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00 ;定义代码段的高四字节，(0x00 &lt;&lt; 24)表示&quot;段基址的24~31&quot;字段，该字段位于段描述符高四字节24~31位，平坦模式段基址为0，所以这里用0填充，最后的0x00也是</span><br><span class="line">DESC_DATA_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00</span><br><span class="line">DESC_VIDEO_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b</span><br><span class="line"></span><br><span class="line">;--------------   选择子属性  ---------------</span><br><span class="line">RPL0  equ   00b</span><br><span class="line">RPL1  equ   01b</span><br><span class="line">RPL2  equ   10b</span><br><span class="line">RPL3  equ   11b</span><br><span class="line">TI_GDT	 equ   000b</span><br><span class="line">TI_LDT	 equ   100b</span><br></pre></td></tr></table></figure>
<p>下面修改 <code>loader.S</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">section loader vstart=LOADER_BASE_ADDR</span><br><span class="line">LOADER_STACK_TOP equ LOADER_BASE_ADDR ;初始化的栈顶</span><br><span class="line">jmp loader_start</span><br><span class="line"></span><br><span class="line">;构建gdt以及内部的描述符，每个8字节，由两个四字节组成</span><br><span class="line">;第0个描述符不可用,置为0</span><br><span class="line">GDT_BASE: dd 0x00000000 ;低四字节</span><br><span class="line">          dd 0x00000000 ;高四字节</span><br><span class="line">;代码段描述符</span><br><span class="line">CODE_DESC: dd 0x0000FFFF      ;0xFFFF是段界限的0~15位，0x0000是段基址的0~15位</span><br><span class="line">           DESC_CODE_HIGH4    ;boot.inc中定义的高四字节</span><br><span class="line">;数据段和栈段描述符</span><br><span class="line">DATA_STACK_DESC: dd 0x0000FFFF</span><br><span class="line">                 dd DESC_DATA_HIGH4</span><br><span class="line">;显存段描述符，为了方便显存操作，显存段不用平坦模型</span><br><span class="line">VIDEO_DESC: dd 0x80000007        ;参考1MB实模式内存分布，limit=(0xbffff-0xb8000)/4k=0x7</span><br><span class="line">            dd DESC_VIDEO_HIGH4  ;此时dpl为0</span><br><span class="line">GDT_SIZE equ $ - GDT_BASE  ;地址差获得GDT大小</span><br><span class="line">GDT_LIMIT equ GDT_SIZE - 1 ;大小减1获得段界限</span><br><span class="line">times 60 dq 0 ;此处预留60个描述符空位，为以后做准备，times相当于是循环执行命令</span><br><span class="line">;构建代码段、数据段、显存段的选择子</span><br><span class="line">SELECTOR_CODE equ (0x0001&lt;&lt;3)+TI_GDT+RPL0	;相当于（CODE_DESC-GDT_BASE）/8+TI_GDT+RPL0</span><br><span class="line">SELECTOR_DATA equ (0x0002&lt;&lt;3)+TI_GDT+RPL0</span><br><span class="line">SELECTOR_VIDEO equ (0x0003&lt;&lt;3)+TI_GDT+RPL0</span><br><span class="line"></span><br><span class="line">;以下是gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line">gdt_ptr dw GDT_LIMIT</span><br><span class="line">        dd GDT_BASE</span><br><span class="line">loadermsg db &apos;2 loader in real.&apos;</span><br><span class="line">loader_start:</span><br><span class="line">;---------------------------------------------------------</span><br><span class="line">;INT 0x10	功能号:0x13	功能描述符:打印字符串</span><br><span class="line">;---------------------------------------------------------</span><br><span class="line">;输入:</span><br><span class="line">;AH 子功能号=13H</span><br><span class="line">;BH = 页码</span><br><span class="line">;BL = 属性（若AL=00H或01H）</span><br><span class="line">;CX = 字符串长度</span><br><span class="line">;(DH,DL)=坐标(行，列)</span><br><span class="line">;ES:BP=字符串地址</span><br><span class="line">;AL=显示输出方式</span><br><span class="line">;0——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变</span><br><span class="line">;1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变</span><br><span class="line">;2——字符串中只含显示字符和显示属性。显示后，光标位置不变。</span><br><span class="line">;3——字符串中只含显示字符和显示属性。显示后，光标位置改变。</span><br><span class="line">;无返回值</span><br><span class="line">mov sp,LOADER_BASE_ADDR</span><br><span class="line">mov bp,loadermsg		;ES:BP=字符串地址</span><br><span class="line">mov cx,17				;CX=字符串长度</span><br><span class="line">mov ax,0x1301			;AH=13,AL=01h</span><br><span class="line">mov bx,0x001f			;页号为0(BH=0)蓝底分红子(BL=1fh)</span><br><span class="line">mov dx,0x1800</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;---------------------准备进入保护模式-------------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">;-----------------------打开A20--------------------------</span><br><span class="line">in al,0x92</span><br><span class="line">or al,0000_0010B</span><br><span class="line">out 0x92,al</span><br><span class="line">;-----------------------加载GDT--------------------------</span><br><span class="line">lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">;----------------------cr0 第 0 位置 1-------------------</span><br><span class="line">mov eax,cr0</span><br><span class="line">or eax,0x00000001</span><br><span class="line">mov cr0,eax</span><br><span class="line"></span><br><span class="line">jmp dword SELECTOR_CODE:p_mode_start		;下面指令又有16位又有32位，故需要刷新流水线</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">;选择子初始化段寄存器</span><br><span class="line">	mov ax,SELECTOR_DATA</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov esp,LOADER_STACK_TOP</span><br><span class="line">	mov ax,SELECTOR_VIDEO</span><br><span class="line">	mov gs,ax</span><br><span class="line">	</span><br><span class="line">	mov byte [gs:160],&apos;P&apos; ;显存第80个字符的位置写一个P</span><br><span class="line">	</span><br><span class="line">	jmp $</span><br></pre></td></tr></table></figure>
<p>同之前的方法编译，注意这里loader.bin编译后为615个字节，需要2个扇区大小，写入磁盘时要给count赋值为2</p>
<p><img src="/2020/05/07/简单内核实现笔记/22.png" alt="image-20200507101206860"></p>
<p>运行结果如下，其中<code>1 MBR</code>来自实模式下的mbr.S，<code>2 loader in real</code>来自实模式下用BIOS中断0x10实现的，左上角第二行的<code>P</code>是在保护模式下输出的。</p>
<p><img src="/2020/05/07/简单内核实现笔记/23.png" alt="image-20200507102103054"></p>
<p>查看GDT表中的内容和我们设置的相符，其中第0个不可用。查看寄存器信息PE位设置为1表示已经进入保护模式。</p>
<p><img src="/2020/05/07/简单内核实现笔记/24.png" alt="24"></p>
<p>保护模式对内存的保护体现在如下几个方面，这里简单总结一下，更详细的内容网上有很多更详细的说明，当然最权威的还是intel手册。</p>
<p><strong>向段寄存器加载段选择子时的保护</strong></p>
<p>当引用一个内存段时，实际上就是往段寄存器中加载个段选择子，为了避免非法引用内存段的情况，会检查选择子是否合理，判断方法就是通过验证索引值是否出现越界，越界则抛出异常。有如下表达式</p>
<blockquote>
<p>描述符表基地址+选择子中的索引值*8+7&lt;=描述符表基地址+描述符表界限值</p>
</blockquote>
<p>总结如下图</p>
<p><img src="/2020/05/07/简单内核实现笔记/25.png" alt="image-20200507174438486"></p>
<p>检查完选择子就该检查段描述符中 type 字段，也就是段的类型，如下图所示</p>
<p><img src="/2020/05/07/简单内核实现笔记/26.png" alt="image-20200507174438486"></p>
<p>检查完类型后检查P位，P位表示该段是否存在，1表示存在，0表示不存在。</p>
<p><strong>代码段和数据段的保护</strong></p>
<p>代码段和数据段主要保护措施是当CPU访问一个地址的时候，判断该地址不能超过所在内存段的范围。简单总结如下图所示，出现这种跨段操作就会出现异常。</p>
<p><img src="/2020/05/07/简单内核实现笔记/27.png" alt="image-20200507174438486"></p>
<p><strong>栈段的保护</strong></p>
<p>段描述符type中的e位表示扩展方向，栈可以向上扩展和向下扩展，下面就是检查方式</p>
<ul>
<li>对于向上拓展的段，实际段界限是段内可以访问的最后一个字节</li>
<li>对于向下拓展的段，实际段界限是段内不可以访问的第一个字节</li>
</ul>
<p>等价于如下表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际段界限+1&lt;=esp-操作数大小&lt;=0xFFFFFFFF</span><br></pre></td></tr></table></figure>
<h1 id="保护模式进阶"><a href="#保护模式进阶" class="headerlink" title="保护模式进阶"></a>保护模式进阶</h1><h2 id="获取物理内存容量"><a href="#获取物理内存容量" class="headerlink" title="获取物理内存容量"></a>获取物理内存容量</h2><p>Linux获取内存容量方法有三种，本质上分别是BIOS中断0x15的3个子功能，BIOS是实模式下的方法，只能在保护模式之前调用。总结如下</p>
<p><strong>利用BIOS中断0x15子功能0xe820获取内存</strong></p>
<p>此方法最灵活，返回的内容也最丰富，内存信息的内容是地址范围描述符来描述的(ARDS)，每个字段4字节，一共20字节，调用0x15返回的也就是这个结构。其中Type字段表示内存类型，1表示这段内存可以使用；2表示不可用使用此内存；其它表示未定义，将来会用到</p>
<table>
<thead>
<tr>
<th>字节偏移量</th>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>BaseAddrLow</td>
<td>基地址的低32位</td>
</tr>
<tr>
<td>4</td>
<td>BaseAddrHigh</td>
<td>基地址的高32位</td>
</tr>
<tr>
<td>8</td>
<td>LengthLow</td>
<td>内存长度的低32位，以字节为单位</td>
</tr>
<tr>
<td>12</td>
<td>LengthHigh</td>
<td>内存长度的高32位，以字节为单位</td>
</tr>
<tr>
<td>16</td>
<td>Type</td>
<td>本段内存的类型</td>
</tr>
</tbody>
</table>
<p>用0x15子功能0xe820调用说明和调用步骤如下</p>
<ol>
<li>填写好”调用前输入”中列出的寄存器</li>
<li>执行中断调用 int 0x15</li>
<li>在CF位为0的情况下，”返回后输出”中对应的寄存器中就有结果</li>
</ol>
<p><img src="/2020/05/07/简单内核实现笔记/28.png" alt="image-20200508082615611"></p>
<p><strong>利用BIOS中断0x15子功能0xe801获取内存</strong></p>
<p>此方法最多识别4G的内存，结果存放在两组寄存器中，操作起来要简便一些，调用说明和调用步骤如下</p>
<ol>
<li>AX寄存器写入0xE801</li>
<li>执行中断调用 int 0x15</li>
<li>在CF位为0的情况下，”返回后输出”中对应的寄存器中就有结果</li>
</ol>
<p><img src="/2020/05/07/简单内核实现笔记/29.png" alt="image-20200508083428601"></p>
<p><strong>利用BIOS中断0x15子功能0x88获取内存</strong></p>
<p>此方法最多识别64MB内存，操作起来最简单，调用说明和调用步骤如下</p>
<ol>
<li>AX寄存器写入0x88</li>
<li>执行中断调用 int 0x15</li>
<li>在CF位为0的情况下，”返回后输出”中对应的寄存器中就有结果</li>
</ol>
<p><img src="/2020/05/07/简单内核实现笔记/30.png" alt="image-20200508083919353"></p>
<p>下面结合这三种方式改进我们的实验代码，下面是<code>loader</code>，我们将结果保存在了<code>total_mem_bytes</code>中，重要的一些地方都有注释，更详细的内容建议参考书中P183</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">   %include &quot;boot.inc&quot;</span><br><span class="line">   section loader vstart=LOADER_BASE_ADDR</span><br><span class="line">   LOADER_STACK_TOP equ LOADER_BASE_ADDR</span><br><span class="line">   </span><br><span class="line">;构建gdt及其内部的描述符</span><br><span class="line">   GDT_BASE:   dd    0x00000000 </span><br><span class="line">	       dd    0x00000000</span><br><span class="line"></span><br><span class="line">   CODE_DESC:  dd    0x0000FFFF </span><br><span class="line">	       dd    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">   DATA_STACK_DESC:  dd    0x0000FFFF</span><br><span class="line">		     dd    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">   VIDEO_DESC: dd    0x80000007	   ; limit=(0xbffff-0xb8000)/4k=0x7</span><br><span class="line">	       dd    DESC_VIDEO_HIGH4  ; 此时dpl为0</span><br><span class="line"></span><br><span class="line">   GDT_SIZE   equ   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   equ   GDT_SIZE -	1 </span><br><span class="line">   times 60 dq 0					 ; 此处预留60个描述符的空位(slot)</span><br><span class="line">   SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0     ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span><br><span class="line">   SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br><span class="line">   SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0	 ; 同上 </span><br><span class="line"></span><br><span class="line">   ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span><br><span class="line">   ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span><br><span class="line">   ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span><br><span class="line">   total_mem_bytes dd 0					 </span><br><span class="line">   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line">   gdt_ptr  dw  GDT_LIMIT </span><br><span class="line">	    dd  GDT_BASE</span><br><span class="line"></span><br><span class="line">   ;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span><br><span class="line">   ards_buf times 244 db 0</span><br><span class="line">   ards_nr dw 0		      ;用于记录ards结构体数量</span><br><span class="line"></span><br><span class="line">   loader_start:</span><br><span class="line">   </span><br><span class="line">;-------  int 15h eax = 0000E820h ,edx = 534D4150h (&apos;SMAP&apos;) 获取内存布局  -------</span><br><span class="line"></span><br><span class="line">   xor ebx, ebx		      ;第一次调用时，ebx值要为0</span><br><span class="line">   mov edx, 0x534d4150	  ;edx只赋值一次，循环体中不会改变</span><br><span class="line">   mov di, ards_buf	      ;ards结构缓冲区</span><br><span class="line">.e820_mem_get_loop:	      ;循环获取每个ARDS内存范围描述结构</span><br><span class="line">   mov eax, 0x0000e820	  ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span><br><span class="line">   mov ecx, 20		      ;ARDS地址范围描述符结构大小是20字节</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能</span><br><span class="line">   add di, cx		      ;使di增加20字节指向缓冲区中新的ARDS结构位置</span><br><span class="line">   inc word [ards_nr]	  ;记录ARDS数量</span><br><span class="line">   cmp ebx, 0		      ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span><br><span class="line">   jnz .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span><br><span class="line">   mov cx, [ards_nr]	  ;遍历每一个ARDS结构体,循环次数是ARDS的数量</span><br><span class="line">   mov ebx, ards_buf </span><br><span class="line">   xor edx, edx		      ;edx为最大的内存容量,在此先清0</span><br><span class="line">.find_max_mem_area:	      ;无须判断type是否为1,最大的内存块一定是可被使用</span><br><span class="line">   mov eax, [ebx]	      ;base_add_low</span><br><span class="line">   add eax, [ebx+8]	      ;length_low</span><br><span class="line">   add ebx, 20		      ;指向缓冲区中下一个ARDS结构</span><br><span class="line">   cmp edx, eax		      ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span><br><span class="line">   jge .next_ards</span><br><span class="line">   mov edx, eax		      ;edx为总内存大小</span><br><span class="line">.next_ards:</span><br><span class="line">   loop .find_max_mem_area</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span><br><span class="line">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span><br><span class="line">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span><br><span class="line">.e820_failed_so_try_e801:</span><br><span class="line">   mov ax,0xe801</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法</span><br><span class="line"></span><br><span class="line">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span><br><span class="line">   mov cx,0x400	     ;cx和ax值一样,cx用做乘数</span><br><span class="line">   mul cx </span><br><span class="line">   shl edx,16</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">   or edx,eax</span><br><span class="line">   add edx, 0x100000 ;ax只是15MB,故要加1MB</span><br><span class="line">   mov esi,edx	     ;先把低15MB的内存容量存入esi寄存器备份</span><br><span class="line"></span><br><span class="line">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span><br><span class="line">   xor eax,eax</span><br><span class="line">   mov ax,bx		</span><br><span class="line">   mov ecx, 0x10000	;0x10000十进制为64KB</span><br><span class="line">   mul ecx		    ;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span><br><span class="line">   add esi,eax		;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span><br><span class="line">   mov edx,esi		;edx为总内存大小</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88: </span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">      </span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16	     ;把dx移到高16位</span><br><span class="line">   or edx, eax	     ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx	 ;将内存换为byte单位后存入total_mem_bytes处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------   准备进入保护模式   -------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">   ;-----------------  打开A20  ----------------</span><br><span class="line">   in al,0x92</span><br><span class="line">   or al,0000_0010B</span><br><span class="line">   out 0x92,al</span><br><span class="line"></span><br><span class="line">   ;-----------------  加载GDT  ----------------</span><br><span class="line">   lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   ;-----------------  cr0第0位置1  ----------------</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x00000001</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   jmp dword SELECTOR_CODE:p_mode_start	   ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br><span class="line">					                     ; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="line">.error_hlt:		      ;出错则挂起</span><br><span class="line">   hlt</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">   mov ax, SELECTOR_DATA</span><br><span class="line">   mov ds, ax</span><br><span class="line">   mov es, ax</span><br><span class="line">   mov ss, ax</span><br><span class="line">   mov esp,LOADER_STACK_TOP</span><br><span class="line">   mov ax, SELECTOR_VIDEO</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">   mov byte [gs:160], &apos;P&apos;</span><br><span class="line"></span><br><span class="line">   jmp $</span><br></pre></td></tr></table></figure>
<p>在<code>mbr.S</code>中也需要修改一处内容，我们跳转的内容要加上0x300，原因是在 loader.S 中<code>loader_start</code>计算如下</p>
<blockquote>
<p>(4个段描述符 + 60个段描述符槽位) * 8字节 = total_mem_bytes_offset</p>
<p>(4 + 60) * 8 = 512 = 0x200</p>
<p>total_mem_bytes + gdt_ptr + ards_buf + adrs_nr + total_mem_bytes_offset = loader_start</p>
<p>4 + 6 + 244 + 2 + 0x200 = 0x300</p>
</blockquote>
<p>修改片断如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[...] </span><br><span class="line">   mov eax,LOADER_START_SECTOR</span><br><span class="line">   mov bx,LOADER_BASE_ADDR</span><br><span class="line">   mov cx,4</span><br><span class="line">   call rd_disk_m_16</span><br><span class="line">  </span><br><span class="line">   jmp LOADER_BASE_ADDR+0x300 ; 这里</span><br><span class="line"></span><br><span class="line">rd_disk_m_16:	   </span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>运行结果如下，这里我们用<code>xp 0xb00</code>查看我们的结果，<code>0x02000000</code>换算过来刚好是我们<code>bochsrc.disk</code>中 megs 设置的32MB大小</p>
<p><img src="/2020/05/07/简单内核实现笔记/31.png" alt="image-20200508083919353"></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OS-Learning/" rel="tag"><i class="fa fa-tag"></i> OS Learning</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/21/CVE-2019-1458-从-漏洞报告-到POC的编写过程/" rel="next" title="CVE-2019-1458: 从'漏洞报告'到POC的编写过程">
                <i class="fa fa-chevron-left"></i> CVE-2019-1458: 从'漏洞报告'到POC的编写过程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2099/01/01/My-Articles/" rel="prev" title="My Articles">
                My Articles <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Thunder_J</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/ThunderJie" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/thunder-j/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-compass"></i>知乎</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://blog.csdn.net/CharlesGodX/" target="_blank" title="csdn"><i class="fa fa-fw fa-copyright"></i>csdn</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/ThunderJ17" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#环境搭建"><span class="nav-number">1.</span> <span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实模式"><span class="nav-number">2.</span> <span class="nav-text">实模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BIOS"><span class="nav-number">2.1.</span> <span class="nav-text">BIOS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一个MBR"><span class="nav-number">2.2.</span> <span class="nav-text">第一个MBR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完善MBR"><span class="nav-number">2.3.</span> <span class="nav-text">完善MBR</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#保护模式初探"><span class="nav-number">3.</span> <span class="nav-text">保护模式初探</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#段描述符"><span class="nav-number">3.1.</span> <span class="nav-text">段描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局描述符"><span class="nav-number">3.2.</span> <span class="nav-text">全局描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部描述符表"><span class="nav-number">3.3.</span> <span class="nav-text">局部描述符表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#段选择子"><span class="nav-number">3.4.</span> <span class="nav-text">段选择子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CR0寄存器"><span class="nav-number">3.5.</span> <span class="nav-text">CR0寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进入保护模式"><span class="nav-number">3.6.</span> <span class="nav-text">进入保护模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#保护模式进阶"><span class="nav-number">4.</span> <span class="nav-text">保护模式进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取物理内存容量"><span class="nav-number">4.1.</span> <span class="nav-text">获取物理内存容量</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thunder_J</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">359k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">5:26</span>
  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.2</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:
  <span id="busuanzi_value_site_uv"></span>
  人
</span>
</div>

<span id="busuanzi_container_site_pv">
    总访问量
    <span id="busuanzi_value_site_pv"></span>
    次
</span>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>